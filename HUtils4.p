unit HUtils4;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, NodePrefs, inpout2, InpOut, User, terminal, SystemPrefs, Message_Editor, fileTrans, FileTrans2, HUtilsTWO, HermesUtils, notification, PPCToolbox, Processes, EPPC, AppleEvents, HUtils3;	procedure doSysopKey (key: char; isControl: boolean);	procedure DoKeyDetect (event: eventRecord);	procedure CheckForChars;	procedure doSerialChar (SerKe: char);	procedure DoDailyMaint;	procedure LaunchTabby;	procedure SetBookmark;implementation	function Launchit (pLnch: pLaunchStruct): OSErr;	inline		$205F, $A9F2, $3E80;	procedure LaunchTabby;		var			pMyLaunch: pLaunchStruct;			myLaunch: LaunchStruct;			MyPB: CInfoPBRec;			LaunchString: str255;	begin		LaunchString := 'TabbyNet';		with MyPB do		begin			ioNamePtr := @LaunchString;			ioVRefNum := 0;			ioFDirIndex := 0;			ioDirID := 0;		end;	{	with	}		result := PBGetCatInfo(@MyPB, false);		pMyLaunch := @myLaunch;		with pMyLaunch^ do		begin			pfName := @LaunchString;			param := 0;			LC[0] := 'L';			LC[1] := 'C';			extBlockLen := 6;			fFlags := myPB.ioFlFndrInfo.fdFlags;			if intSystRec.subLaunchTabby and not tabbyQuit then				LaunchFlags := $C0000000			else				LaunchFlags := $00000000;		end;		{	with pMyLaunch^	}		result := Launchit(pMyLaunch);	end;	procedure DoPrompt (pressedKey: char);		label			300;		var			toOutput: char;			endPrompt: boolean;			ts: str255;			tl, tempPos: longint;			i: integer;	begin		with curglobs^ do		begin			with myPrompt do			begin				endprompt := false;				if inPause then				begin					pressedKey := char(13);					endprompt := true;					goto 300;				end;				if pressedKey = char(127) then					pressedKey := char(8);				toOutput := pressedKey;				if pressedKey <> char(13) then				begin					if (length(curprompt) < maxChars) or (pressedKey = char(8)) then					begin						ts := ' ';						ts[1] := pressedKey;						if capitalize then							UprString(ts, true);						pressedKey := ts[1];						toOutput := PressedKey;						if replaceChar <> char(0) then							toOutput := replaceChar;						if (BoardSection = MainMenu) and (pos('/', curPrompt) = 1) and (length(curPrompt) = 1) and (pressedKey = 'O') then						begin							HangUpAndReset;							exit(doPrompt);						end;						if ((pressedKey >= char(48)) and (pressedKey <= char(57))) then						begin							StringToNum(concat(curprompt, pressedKey), tl);							if ((tl >= numericLow) and (tl <= numericHigh)) or not enforceNumeric then							begin								curprompt := concat(curprompt, pressedKey);								if (length(curprompt) = 1) and thisUser.canANSI and (inputColor >= 0) then									dom(inputColor);								if (replaceChar <> char(0)) then								begin									ts := pressedKey;									ProcessData(activeNode, @ts[1], 1);									tempPos := 1;									ts := toOutput;									if not sysopLogon then										result := AsyncMWrite(outputRef, tempPos, @ts[1]);								end								else									OutLine(toOutput, false, -1);								if autoAccept and enforceNumeric then								begin									if ((numericHigh - 9) < tl) or ((tl * 10) > numericHigh) or ((numericLow = 0) and (tl = 0)) then									begin										endPrompt := true;										goto 300;									end;								end;							end;						end						else if ((allowedChars = '') and not enforceNumeric) or (pos(pressedKey, allowedChars) > 0) or ((length(curPrompt) > 0) and (pos(breakChar, curPrompt) = 1)) then						begin							if pressedKey <> char(8) then							begin								if autoAccept and (pressedKey <> breakChar) and (pos(breakChar, curPrompt) <> 1) then								begin									if ((pressedKey < char(48)) or (pressedKey > char(57))) then									begin										OutLine(pressedKey, false, inputColor);										if keyString1[1] = char(13) then											delete(keyString1, 1, 1);										if keyString2[1] = char(13) then											delete(keyString2, 1, 1);										if keyString3[1] = char(13) then											delete(keyString3, 1, 1);										if pressedKey = keyString1[1] then											OutLine(copy(keyString1, 2, length(keyString1) - 1), false, -1);										if pressedKey = keyString2[1] then											OutLine(copy(keyString2, 2, length(keyString2) - 1), false, -1);										if pressedKey = keyString3[1] then											OutLine(copy(keyString3, 2, length(keyString3) - 1), false, -1);										endPrompt := true;										curprompt := concat(curprompt, pressedKey);										goto 300;									end									else									begin										StringToNum(curPrompt, tl);										if (tl <= numericHigh) and (tl >= numericLow) then										begin											endprompt := true;										end;									end;								end;								curprompt := concat(curprompt, pressedKey);								if (length(curprompt) = 1) and thisUser.canANSI and (inputColor >= 0) then									dom(inputColor);								if (replaceChar <> char(0)) then								begin									ts := pressedKey;									ProcessData(activeNode, @ts[1], 1);									tempPos := 1;									ts := toOutput;									if not sysopLogon then										result := AsyncMWrite(outputRef, tempPos, @ts[1]);								end								else									OutLine(toOutput, false, -1);							end							else							begin								if length(curprompt) > 0 then								begin									delete(curPrompt, length(curprompt), 1);									backSpace(1);								end;							end;						end						else if (pressedKey = char(8)) then						begin							if length(curprompt) > 0 then							begin								delete(curPrompt, length(curprompt), 1);								backSpace(1);							end;						end;					end					else if wrapAround then					begin						excess := ' ';						excess[1] := pressedKey;						tempPos := length(curPrompt);						while (curPrompt[tempPos] <> char(32)) and (tempPos > 5) do						begin							excess := concat(curPrompt[tempPos], excess);							tempPos := tempPos - 1;						end;						if length(excess) > 1 then							delete(curprompt, length(curPrompt) - length(excess) + 1, length(excess));						if tempPos > 5 then						begin							backSpace(length(excess));						end;						endPrompt := true;					end;				end				else				begin					if (char(13) = keyString1[1]) and (length(keyString1) > 0) then					begin						OutLine(copy(keyString1, 2, length(keyString1) - 1), false, inputColor);						curPrompt := keyString1[2];					end;					if (char(13) = keyString2[1]) and (length(keyString2) > 0) then					begin						OutLine(copy(keyString2, 2, length(keyString2) - 1), false, inputColor);						curPrompt := keyString2[2];					end;					if (char(13) = keyString3[1]) and (length(keyString3) > 0) then					begin						OutLine(copy(keyString3, 2, length(keyString3) - 1), false, inputColor);						curprompt := keyString3[2];					end;					endprompt := true;				end;				if endprompt then				begin300:					OutLine('', false, 0);					if wrapsonCR then						bCR;					BoardAction := none;					if inPause then					begin						for i := 1 to length(promptLine) do							backSpace(1);						BoardAction := SavedBDaction;						if BoardAction <> ListText then							negateBCR := true;						InPause := false;					end;					prompting := false;					if (BoardSection = MainMenu) then						DoMainMenu;				end;			end;		end;	end;	procedure DoDailyMaint;		var			tempString, tempString2: str255;			result: OSerr;			tempDate: DateTimeRec;			i: integer;			templong, tl2: longint;			tempM: menuHandle;	begin		tempString := concat(sharedPath, 'Brief Log');		result := FSDelete(tempString, 0);		result := Create(tempString, 0, 'HRMS', 'DATA');		NumToString(intSystRec.callsToday, tempString);		numToString(intSystRec.minsToday, tempString2);		writeDirectToLog := true;		LogThis('', 0);		LogThis(concat('Calls Today: ', tempString, '     Active Today: ', tempString2), 0);		LogThis('----------------------------------', 0);		NumToString(intSystRec.mPostedToday, tempString);		LogThis(concat('Posts Today: ', tempString), 0);		NumToString(intSystRec.eMailToday, tempString);		LogThis(concat('Email Today: ', tempString), 0);		NumToString(intSystRec.uploadsToday, tempString);		LogThis(concat('Uplds Today: ', tempString), 0);		writeDirectToLog := false;		Write2ZLog;		intSystRec.callsToday := 0;		intSystRec.mPostedToday := 0;		intSystRec.eMailToday := 0;		intSystRec.uploadsToday := 0;		intSystRec.minsToday := 0;		Date2Secs(intSystRec.lastmaint, tempLong);		IUDateString(tempLong, shortDate, tempstring);		tempstring2 := concat(sharedPath, 'Today Log');		result := copy1File(tempstring2, concat(sharedPath, 'Logs:', tempstring));		result := FSDelete(tempstring2, 0);		tempM := GetMHandle(mLog);		GetItem(tempM, countMItems(tempM), tempstring2);		result := FSDelete(concat(sharedPath, 'Logs:', tempstring2), 0);		DelMenuItem(tempM, countMItems(tempM));		InsMenuItem(tempM, ' ', 3);		SetItem(tempM, 4, tempstring);		GetTime(tempDate);		Date2Secs(intSystRec.lastMaint, tempLong);		GetDateTime(tl2);		intSystRec.Lastmaint := tempDate;		doSystRec(true);		for i := 1 to intSystRec.numNodes do		begin			with theNodes[i]^ do			begin				thisUser.onToday := 1;				thisUser.minOnToday := 0;				thisUser.EMsentToday := 0;				thisUser.MPostedToday := 0;				if (thisUser.userNum > 0) and (boardMode = User) and (intSystRec.secLevels[thisUser.secLevel].useDayorCall) then				begin					SubtractOn := tickCount - timeBegin;				end;			end;		end;	end;	procedure doSerialChar (SerKe: char);		var			count, tempint2: longInt;			i, tempPos, tempint: integer;			dumRect, tempRect: rect;			yaba, tempString: str255;			flipped, didTwoCol: boolean;			myByte: byte;	begin		with curglobs^ do		begin			if (serKe <> char(17)) and (serKe <> char(19)) then				lastKeyPressed := tickCount;			didTwoCol := false;			flipped := false;			timeFlagged := false;			if (BoardMode = User) then			begin				if (serKe = char(15)) then				begin					if (BoardAction = Prompt) and (HelpNum > 0) then					begin						if LoadSpecialText(HelpFile, HelpNum) then						begin							if thisUser.canANSI then								doM(0);							BoardAction := ListText;							ListingHelp := true;							Prompting := false;							bCR;							ListTextFile;						end;					end;				end				else if (serKe = char(19)) then				begin					if ((((BoardSection = ListFiles) and (ListDo = ListFour)) or continuous or (BoardAction = Repeating) or (BoardAction = ListText))) then						sysopStop := not SysopStop;				end				else if (serKe = char(17)) then				begin					sysopStop := false;				end				else if (serKe = char(20)) then				begin					if (BoardSection <> Logon) and (BoardSection <> NewUser) then					begin						savedBDAction := BoardAction;						BoardAction := none;						bCR;						GetDateTime(count);						IUDateString(count, abbrevDate, yaba);						IUTimeString(count, true, tempString);						OutLine(concat(yaba, '  ', tempstring), true, 0);						OutLine(concat('Time on  : ', tickToTime(tickCount - timeBegin)), true, 0);						OutLine(concat('Time Left: ', TickToTime(ticksLeft(activeNode))), true, 0);						bCR;						bCR;						BoardAction := savedBDAction;						if prompting then							ReprintPrompt						else if (BoardAction = Writing) then							ListLine(online);					end;				end				else if (serKe = char($AE)) and (BoardSection = Logon) and ((LogonStage = Welcome) or (LogonStage = Name)) then				begin					if IntSystRec.tabbyNet and doCrashmail then					begin						result := SetVol(nil, homeVol);						result := Create('connect.bbs', 0, 'HRMS', 'CNCT');						result := FSOpen('connect.bbs', 0, tempint);						NumToString(currentBaud, tempstring);						NumToBaud(maxBaud, tempint2);						if not matchInterface then							NumToString(tempint2, tempstring);						if inportName = '.AIn' then							tempstring := concat('a', tempstring)						else							tempstring := concat('b', tempstring);						tempint2 := length(tempstring);						result := FSWrite(tempint, tempint2, @tempstring[1]);						result := FSClose(tempint);						LogThis(retinstr(17, 8), 6);						if intSystRec.subLaunchTabby then						begin							TabbyQuit := true;							CloseComPort;							TabbyPaused := true;							TabbyQuit := false;							SavedInPort := InportName;							InPortName := '';							OpenComPort;							HangUpAndReset;							LaunchTabby;						end						else						begin							tabbyQuit := true;							quit := 1;						end;					end;				end				else if (BoardAction = Writing) then				begin					LineChar(serKe);				end				else if (BoardAction = Chat) then				begin					DoChatShow(false, false, serKe);				end				else if ((serKe = char(24)) or ((serKe = char(32)) and (BoardAction <> chat) and (BoardAction <> writing))) and ((BoardAction = ListText) or (BoardAction = Repeating) or continuous or (BoardAction = Writing) or (BoardAction = Chat)) then				begin					if (BoardSection = ListFiles) and (ListDo = ListFour) then						curTextPos := -100					else if continuous then					begin						inZScan := false;						continuous := false;					end					else if (BoardAction = ListText) then					begin						ClearInBuf;						CurTextPos := OpenTextSize;						ListTextFile;					end;					aborted := true;				end				else if (BoardAction = Prompt) and ((serKe > char(31)) or (serKe = char(13)) or (serKe = char(8))) then				begin					DoPrompt(serKe);				end;			end			else if (BoardMode = Waiting) then			begin				BoardMode := Waiting;				if (serKe = '2') and not inDownTime then					AnswerCall;			end			else if (BoardMode = Answering) then			begin				ConnectMade(serKe);			end;		end;	end;	procedure CheckforChars;		label			100;		var			count: longInt;			b, i: integer;			dumRect: rect;			yaba: str255;			tc1: char;	begin		with curglobs^ do		begin			if nodeType = 2 then			begin				if (BoardMode = User) then				begin					i := ADSPBytesToRead;					if (i > 0) then					begin						b := 250 - length(typeBuffer);						if i > b then							i := b;						with nodeDSPPBPtr^ do						begin							ioCompletion := nil;							csCode := dspRead;							reqCount := i;							dataPtr := @incoming;							ioCRefNum := dspDrvrRefNum;							ccbRefNum := nodeCCBRefNum;						end;						result := PBControl(ParmBlkPtr(nodeDSPPBPtr), false);						if (result = noErr) then						begin							count := nodeDSPPBPtr^.actCount;							goto 100;						end;					end;				end;			end			else if nodeType = 1 then			begin				result := mySDGetBuf(count);				if count > 0 then				begin					if count > 3072 then						count := 3072;					i := 250 - length(typeBuffer);					if (BoardMode = User) and (count > i) then						count := i;					if (mySyncRead(inputRef, count, @incoming) = noErr) then					begin						if (BoardMode <> Terminal) then						begin100:							if (batDo = BatSeven) and (BoardSection = Batch) and (boardMode = User) then								lastKeypressed := tickCount;							for i := 0 to (count - 1) do							begin								if incoming[i] = char(127) then									incoming[i] := char(8);								if ((incoming[i] > char(31)) or ((incoming[i] = char(8)) or (incoming[i] = char(13)))) and (BoardMode = User) and (BoardAction <> ListText) then									typeBuffer := concat(typeBuffer, incoming[i])								else								begin									DoSerialChar(incoming[i]);								end;							end;						end						else if (BoardMode = Terminal) then						begin							if not in8BitTerm then								for i := 0 to (count - 1) do									incoming[i] := char(BitAnd(ord(incoming[i]), $7F));							ProcessData(activeNode, @incoming[0], count);						end;					end;				end;			end;		end;	end;	procedure doSysopKey (key: char; isControl: boolean);		var			yaba, tempString, TEMPST: str255;			strLeng, count: longInt;			i, tempPos: integer;	begin		with curglobs^ do		begin			if (BoardMode = Answering) then			begin				if (Key = 'H') or (Key = 'h') then				begin					HangupAndReset;				end;			end			else if (BoardMode = Waiting) or (BoardMode = Failed) then			begin				if (Key = char(13)) then				begin					HangupAndReset;				end;			end			else if (BoardMode = Terminal) then			begin				count := 1;				yaba := key;				result := FSWrite(outputRef, count, @yaba[1]);				if inHalfDuplex then					ProcessData(activeNode, @yaba[1], 1);			end			else if not (myTrans.active) and (Key = char(15)) and isControl then			begin				if (BoardAction = Prompt) and (helpNum > 0) then				begin					if LoadSpecialText(HelpFile, HelpNum) then					begin						if thisUser.canANSI then							doM(0);						BoardAction := ListText;						ListingHelp := true;						Prompting := false;						bCR;						ListTextFile;					end;				end;			end			else if not (myTrans.active) and (((Key = char(24)) and isControl) or ((key = char(32)) and (BoardAction <> chat))) and ((BoardAction = Chat) or (BoardAction = ListText) or (BoardAction = Repeating) or continuous) and (BoardMode = User) then			begin				if continuous then				begin					inZScan := false;					continuous := false;				end				else if (BoardAction = ListText) then				begin					if not sysopLogon then					begin						ClearInBuf;					end;					CurTextPos := OpenTextSize;					ListTextFile;				end				else if (BoardSection = ListFiles) and (ListDo = ListFour) then				begin					curTextPos := -100;				end;				aborted := true;			end			else if not (myTrans.active) and ((Key = char(19)) and (isControl)) and ((BoardAction = Repeating) or (BoardAction = ListText) or ((BoardSection = ListFiles) and (ListDo = ListFour))) then			begin				SysopStop := not SysopStop;			end			else if not (myTrans.active) and (Key = char(17)) and isControl then			begin				SysopStop := false;			end			else if not (myTrans.active) and (Key = char(20)) and IsControl and (BoardMode = User) then			begin				savedBDAction := BoardAction;				BoardAction := none;				bCR;				GetDateTime(count);				IUDateString(count, abbrevDate, yaba);				IUTimeString(count, true, tempString);				OutLine(concat(yaba, '  ', tempstring), true, 0);				OutLine(concat('Time on  : ', tickToTime(tickCount - timeBegin)), true, 0);				OutLine(concat('Time Left: ', TickToTime(ticksLeft(activeNode))), true, 0);				bCR;				BoardAction := savedBDaction;				if prompting then					RePrintPrompt				else if (BoardAction = Writing) then					ListLine(online);			end			else if (BoardAction = Writing) then			begin				LineChar(key);				exit(doSysopKey);			end			else if (BoardAction = Chat) then			begin				DoChatShow(false, true, key);				exit(doSysopKey);			end			else if (BoardAction = Prompt) then				DoPrompt(key);		end;	end;	procedure DoKeyDetect (event: eventRecord);		var			isControl: boolean;			altKey, key: char;			yaba, tempString, TEMPST: str255;			strLeng, count: longInt;			dumRect: Rect;			i, tempPos: integer;	begin		with curglobs^ do		begin			if BAnd(event.modifiers, cmdKey) <> 0 then			begin				if event.what = keyDown then				begin					key := CHR(BAnd(event.message, charCodeMask));					if BAnd(event.modifiers, optionKey) <> 0 then						SwitchNode(conopt2Num(key))					else						DoMenuCommand(MenuKey(key));					exit(doKeyDetect);				end;			end;			ObscureCursor;			i := isMyTextWindow(frontWindow);			if (i >= 0) then			begin				with textWinds[i] do				begin					if editable then					begin						key := CHR(BAnd(event.message, charCodeMask));						if (key = CHR(8)) | (t^^.teLength - (t^^.selEnd - t^^.selStart) + 1 < 32000) then						begin	{but check haven't gone past}							dirty := true;							TEKey(key, t);							AdjustScrollbars(i, FALSE);							AdjustTE(i);						end						else							SysBeep(10);						exit(doKeyDetect);					end;				end;			end;			bullbool := false;			strLeng := event.message;			strLeng := BitShift(strLeng, -8);			AltKey := CHR(BAnd(strLeng, $000000FF));			case ord(altkey) of				$7A: 					SwitchNode(1);				$78: 					Switchnode(2);				$63: 					switchnode(3);				$76: 					switchnode(4);				$60: 					switchnode(5);				$61: 					switchnode(6);				$62: 					switchnode(7);				$64: 					switchnode(8);				$65: 					switchnode(9);				$6D: 					switchnode(10);				otherwise			end;			if bullBool then				exit(doKeyDetect);			if (BAnd(event.modifiers, controlKey) <> 0) then				isControl := true			else				isControl := false;			key := CHR(BAnd(event.message, charCodeMask));			if (gMac.keyboardType < 4) and (BAnd(event.modifiers, optionKey) <> 0) and not (BAnd(event.modifiers, shiftKey) <> 0) then			begin				ConOpt2Con(key);				if key <> ' ' then					isControl := true;			end;			if (ismyBBSwindow(frontWindow) = activeNode) then			begin				if not gBBSwindows[activeNode]^.scrollFreeze then				begin					if myTrans.active then					begin						if (key = char(3)) then							AbortTrans;					end					else					begin						lastKeyPressed := tickCount;						timeFlagged := false;						if ((key > char(31)) or ((key = char(8)) or (key = char(13)))) and (BoardMode = User) and (BoardAction <> ListText) then						begin							SetHandleSize(handle(sysopKeyBuffer), GetHandleSize(handle(sysopKeyBuffer)) + 1);							sysopKeyBuffer^^[getHandleSize(handle(sysopKeyBuffer)) - 1] := key;						end						else							doSysopKey(key, isControl);					end;				end				else				begin					SetPort(gBBSwindows[activeNode]^.ansiPort);					SetCtlValue(gBBSwindows[activeNode]^.ansiVScroll, GetCtlMax(gBBSwindows[activeNode]^.ansiVScroll));					InvalRect(gBBSwindows[activeNode]^.ansiPort^.portRect);					gBBSwindows[activeNode]^.scrnTop := 24 - gBBSwindows[activeNode]^.scrnLines;					gBBSwindows[activeNode]^.scrnBottom := 24;					gBBSwindows[activeNode]^.scrollFreeze := false;				end;			end;		end;	end;	procedure SetBookmark;		var			WelcomeName, tempstring, tempString2, tempString3, tempString4: str255;			tempInt, tempLong: longInt;			tempDate, tempDate2, tempDate3: DateTimeRec;			tempChar: char;			tempShort, i, LastRef, tempnumem, tempInt2, tempInt3: integer;			myR: real;			f: DecForm;			s: DecStr;			teEM, tempEMa: eMailRec;			tempBool, tb2: boolean;	begin		with curglobs^ do		begin			case BoardSection of				ScanNew: 					ScanNewMess;				AutoVal: 				begin					case valDo of						Val2: 						begin							if AutoValAs(ansInProgress, curprompt, true) then							begin								OutLine(retinstr(17, 9), true, 3);								SysopLog(concat('      Auto validated as ', ansInProgress), 0);							end							else							begin								OutLine(retinstr(17, 10), true, 3);								SysopLog(concat('      Tried to auto validate as ', ansinprogress), 0);							end;							GoHome;						end;						Val1: 						begin							ansInProgress := curPrompt;							if length(curprompt) > 0 then							begin								OutLine(retinstr(17, 11), true, 2);								bCR;								LettersPrompt(': ', '', 13, false, false, true, char(0));								ValDo := Val2;							end							else								GoHome;						end;						otherwise					end;				end;				ext: 					EnterExtended;				MultiChat: 					MultiNodeChat;				GFiles: 					DoGFiles;				batch: 					DoBatchCommands;				MultiMail: 					doMultiMail;				Noder: 					DoNodeStuff;				MessUp: 					DoUpMess;				tranDef: 					DOTransDefs;				renFiles: 					DoRename;				KillMail: 					doKillMail;				MoveFiles: 					doMove;				ReadAll: 					DoAllRead;				limDate: 				begin					if (length(curPrompt) = 8) then					begin						tempString := '  ';						tempString[1] := curPrompt[1];						tempString[2] := curPrompt[2];						StringToNum(tempString, tempInt);						Secs2Date(lastFScan, tempDate);						tempDate.month := tempInt;						tempString := '  ';						tempString[1] := curPrompt[4];						tempString[2] := curPrompt[5];						StringToNum(tempString, tempInt);						tempDate.day := tempInt;						tempString := '  ';						tempString[1] := curPrompt[7];						tempString[2] := curPrompt[8];						StringToNum(tempString, tempInt);						tempDate.year := tempint + 1900;						Date2Secs(tempDate, lastFScan);						IUDateString(lastFScan, shortDate, tempstring);						Outline(concat(retinstr(17, 12), tempString), true, 0);					end;					GoHome;				end;				chUser: 				begin					if FindUser(curprompt, tempUser) then					begin						if not tempUser.deleting then						begin							sysopLog(concat('      #*#*#* Changed to ', tempUser.userName), 6);							thisUser.secLevel := realSL;							WriteUser(thisUser);							thisUser := tempUser;							realSL := thisUser.secLevel;							thisUser.secLevel := 255;						end						else						begin							OutLine('Deleted user.', true, 0);							GoHome;						end;					end					else						OutLine('Unknown user.', true, 0);					GoHome;				end;				Logon: 				begin					LogonStage := succ(LogonStage);					case LogonStage of						Name: 						begin							bCR;							thisUser.UserNum := -1;							OutLine(retinstr(17, 13), false, -1);							bCR;							LettersPrompt(retinstr(17, 14), '', 31, false, false, true, char(0));						end;						CheckName: 						begin							if EqualString(CurPrompt, retinstr(17, 15), false, false) then							begin								statChanged := true;								BoardSection := NewUser;								WelcomeName := '';								if IntSystRec.closed then								begin									NewUserStage := NewuserPass;									bCR;									if ReadTextFile('No New User', 1, false) then									begin										ListTextFile;										BoardAction := ListText;									end									else									begin										BoardAction := none;										OutLine('''No New User'' file not found.', true, 0);									end;								end								else								begin									newUserStage := CheckNewPass;									curPrompt := intSystRec.newUserPass;								end;							end							else							begin								if (curPrompt[length(curPrompt)] = '*') then									delete(curPrompt, length(curPrompt), 1);								tempBool := FindUser(CurPrompt, tempUser);								tb2 := UserOnSystem(tempUser.userName);								if not tempBool then									tb2 := false;								if tempBool and not tempUser.Deleting and not tb2 then								begin									thisUser := tempUser;									statChanged := true;								end								else								begin									if tb2 then										OutLine(retinstr(17, 16), false, -1)									else										OutLine(retinstr(17, 17), false, -1);									bCR;									thisUser.userNum := -1;									bCR;									NumRptPrompt := NumRptPrompt - 1;									if numRptPrompt <> 0 then									begin										OutLine(retinstr(17, 13), false, -1);										bCR;										LettersPrompt(retinstr(17, 14), '', 31, false, false, true, char(0));										LogonStage := Name;									end									else									begin										HangupAndReset;									end;								end;							end;						end;						Password: 						begin							RealSL := thisUser.SecLevel;							LettersPrompt(retinstr(17, 18), '', 9, false, false, true, 'X');						end;						Phone: 						begin							EnteredPass := CurPrompt;							tempString := thisUser.phone;							if (thisUser.restrics[10]) then								tempString := 'XXX-XXX-'							else								delete(tempString, 9, 4);							LettersPrompt(concat(retinstr(17, 19), tempstring), '', 4, false, false, true, 'X');						end;						SysPass: 						begin							EnteredPass2 := CurPrompt;							if (thisUser.SecLevel = 255) and not SysopLogon then							begin								LettersPrompt(retinstr(17, 20), '', 9, false, false, true, 'X');							end;						end;						ChkSysPass: 						begin							if (thisUser.secLevel = 255) and not SysopLogon then							begin								if not EqualString(curPrompt, intSystRec.overridePass, false, false) then								begin									EnteredPass2 := '    ';									EnteredPass2[1] := char(0);									EnteredPass2[2] := char(0);									EnteredPass2[3] := char(0);									EnteredPass2[4] := char(0);								end;							end;						end;						CheckStuff: 						begin							if concat(copy(thisUser.phone, 1, 8), enteredPass2) = thisUser.phone then								tempBool := true							else								tempbool := false;							if tempbool and (enteredPass = thisUser.password) then							begin								validLogon := true;								thisUser.totalLogons := thisUser.totalLogons + 1;								thisUser.lastBaud := currentBaud;								timebegin := tickCount;								GetDateTime(tempLong);								getTime(tempDate);								Secs2Date(thisUser.lastOn, tempdate2);								if tempDate.day = tempDate2.day then									thisuser.OnToday := thisUser.OnToday + 1								else								begin									thisUser.onToday := 1;									thisUser.minOnToday := 0;									thisUser.EMsentToday := 0;									thisUser.MPostedToday := 0;								end;								if not thisUser.cosysop then								begin									if IntSystRec.SecLevels[thisUser.SecLevel].CallsPrDay < (thisUser.onToday) then									begin										bCR;										OutLine(retinstr(17, 21), false, -1);										NumToString(thisUser.UserNum, tempString);										LogThis(concat(thisUser.Username, ' #', tempString, ' tried logging on.'), 0);										thisUser.UserNum := -1;										delay(60, templong);										HangupAndReset;									end;								end;								if thisUser.UserNum > 0 then								begin									if thisUser.userNum > 1 then									begin										IntSystRec.numCalls := IntSystRec.numCalls + 1;										doSystRec(true);									end;									getDateTime(templong);									NumToString(IntSystRec.numCalls, tempString);									tempString := concat(tempString, ':  ', thisUser.userName, ' #');									NumToString(thisUser.UserNum, tempString2);									tempString := concat(tempString, tempString2, '   ');									IUTimeString(tempLong, false, tempstring2);									tempString := concat(tempString, tempString2, ' ');									IUDateString(templong, ShortDate, tempstring2);									tempString := concat(tempString, tempString2, ' ');									tempString := concat(tempString, curBaudNote);									NumToString(thisUser.ontoday, tempstring2);									tempString := concat(tempstring, ' - ', tempstring2);									if intSystRec.numNodes > 1 then									begin										NumToString(activeNode, tempstring2);										tempstring := concat(tempstring, '  @', tempstring2);									end;									sysopLog('', 0);									sysopLog(tempString, 1);								end;							end							else							begin								bCR;								OutLine(retinstr(17, 22), false, -1);								if sysopLogon then									SysBeep(10)								else									OutChr(char(7));								bCR;								NumToString(thisUser.UserNum, tempString2);								sysopLog(concat('### ILLEGAL LOGON for ', thisUser.UserName, ' #', tempString2, ' Tried PW: ', EnteredPass, ' Tried PH: ', enteredPass2), 0);								thisUser.illegalLogons := thisUser.illegalLogons + 1;								WriteUser(thisUser);								thisUser.UserNum := -1;								NumRptPrompt := NumRptPrompt - 1;								if NumRptPrompt > 0 then									LogonStage := Welcome								else								begin									HangupAndReset;								end;							end;						end;						Hello: 						begin							GetDateTime(templong);							NumToString(activeNode, tempString);							if gBBSwindows[activeNode]^.ansiPort <> nil then								SetWTitle(gBBSwindows[activeNode]^.ansiPort, concat(tempString, ': ', thisUser.userName));							lastFScan := thisUser.lastFileScan;							statChanged := true;							OutLine('', false, 0);							ClearScreen;							if not sysopLogon then							begin								if ReadTextFile('Log On', 1, false) then								begin									BoardAction := ListText;									ListTextFile;								end;								MultinodeOutput(concat('< ', thisUser.userName, retinstr(17, 41), ' >'));							end;						end;						Stats: 						begin							if (thisUser.alertOn) and not alerted then							begin								if (GetNamedResource('snd ', 'Alert User')) <> nil then									StartMySound('Alert User', false)								else									for i := 1 to 5 do										SysBeep(1);								alerted := true;							end;							OutLine(retinstr(17, 23), true, 0);							bCR;							bCR;							if ReadTextFile('Last Users', 0, true) then							begin								if not (thisUser.coSysop) then								begin									i := 0;									if OpenTextSize > 8 then									begin										curTextPos := openTextSize;										repeat											repeat												curTextPos := curTextPos - 1;											until (textHnd^^[curTextPos] = char(13)) or (curTextPos = 0);											i := i + 1;										until i = 5;										curTextPos := curTextPos + 1;									end;								end;								if curTextPos < OpenTextSize then								begin									BoardAction := ListText;									ListTextFile;								end								else								begin									BoardAction := none;									OutLine(retinstr(17, 24), true, 0);								end;							end							else							begin								BoardAction := none;								OutLine(retinstr(17, 24), true, 0);							end;						end;						StatAuto: 						begin							if intSystRec.numNodes > 1 then							begin								tempInt := 0;								for i := 1 to intSystRec.numNodes do								begin									if not (theNodes[i]^.nodeType < 0) and (theNodes[i]^.boardMode = User) and (i <> activeNode) and (theNodes[i]^.thisUser.userNum > 1) then									begin										if tempInt = 0 then										begin											bCR;											OutLine(retinstr(17, 25), true, 0);											tempint := 1;											bCR;										end;										NumToString(theNodes[i]^.thisUser.userNum, tempString);										NumToString(i, tempstring2);										OutLine(concat('Node: ', tempstring2, ' : ', theNodes[i]^.thisUser.userName, ' #', tempString), true, 0);									end;								end;								if tempint = 1 then									bCR;							end;							EnterLastUser;							bCR;							bCR;							ReadAutoMessage;						end;						Transition: 						begin							bCR;							bCR;							NumToString(thisUser.UserNum, tempString2);							tempString := concat(retinstr(17, 26), thisUser.UserName, ' #', TempString2);							bufferIt(tempString, false, 0);							if intSystRec.secLevels[thisUser.secLevel].useDayorCall then								NumToString(intSystRec.secLevels[thisUser.secLevel].timeAllowed - thisUser.minOnToday, tempString2)							else								NumToString(IntSystRec.secLevels[thisUser.SecLevel].timeAllowed, tempString2);							tempString := concat(retinstr(17, 27), tempString2);							bufferIt(tempString, true, 0);							if thisUser.illegalLogons > 0 then							begin								NumToString(thisUser.IllegalLogons, tempString);								tempString := concat(retinstr(17, 28), tempString);								bufferIt(tempString, true, 0);								if sysopLogon then									SysBeep(10)								else									bufferIt(char(7), false, -1);							end;							thisUser.illegalLogons := 0;							FindMyEmail;							tempInt := GetHandleSize(handle(myEmailList)) div 2;							if tempint > 0 then							begin								NumToString(tempInt, tempString);								tempString := concat(retinstr(17, 29), tempString);								bufferIt(tempString, true, 0);							end;							if thisUser.onToday = 1 then							begin								if thisUser.totalLogons > 1 then								begin									IUDateString(thisUser.lastOn, shortdate, tempstring2);								end								else									tempString2 := retinstr(17, 31);								tempString := concat(retinstr(17, 30), tempString2);								bufferIt(tempString, true, 0);							end							else							begin								NumToString(thisUser.onToday, tempString);								tempString := concat(retinstr(17, 32), tempString);								bufferIt(tempString, true, 0);							end;							if SysopAvailable and not thisUser.restrics[2] then								bufferIt(retinstr(17, 33), true, 0)							else								bufferIt(retinstr(17, 34), true, 0);							if (thisUser.Restrics[3]) and not (thisUser.coSysop) then							begin								DLratioStr(tempString2, activeNode);								tempString := concat(retinstr(17, 35), tempstring2);								bufferIt(tempString, true, 0);								myR := 1 / (IntSystRec.SecLevels[thisUser.SecLevel].DLRatioOneTo);								F.style := FixedDecimal;								F.digits := 3;								if myR > 99.998 then									myR := 99.999;								Num2Str(f, myR, s);								tempString2 := s;								tempString := concat(retinstr(17, 36), tempString2);								bufferIt(tempString, true, 0);							end;							if (thisUser.Restrics[4]) and (not thisUser.coSysop) then							begin								myR := thisUser.messagesPosted / thisUser.totalLogons;								F.style := FixedDecimal;								F.digits := 2;								Num2Str(f, myR, s);								tempString2 := s;								tempString := concat(retinstr(17, 37), tempString2);								bufferIt(tempString, true, 0);							end;							if intSystRec.numNodes > 1 then							begin								NumToString(activeNode, tempString);								bufferIt(concat(retinstr(17, 38), tempString), true, 0);							end;							bufferIt(concat('System is      : Hermes v', HERMES_VERSION), true, 0);							if thisUser.mailbox then							begin								NumToString(thisUser.forwardedTo, tempString);								bufferIt(concat(retinstr(17, 39), tempString, '.'), true, 0);							end;							yearsOld(thisUser);							getTime(tempdate);							if (tempdate.month = integer(thisUser.birthMonth)) and (tempdate.day = integer(thisUser.birthDay)) then							begin								bufferIt(retinstr(17, 40), true, 6);								bufferIt(char(7), false, -1);								bufferIt(char(7), false, -1);								bufferIt('', false, 0);							end;							ReleaseBuffer;						end;						Trans1: 						begin							bCR;							i := 0;							while (i < availEmails) do							begin								if (theEmail^^[i].MType = 0) and (theEmail^^[i].toUser = thisUser.userNum) then								begin									if not theEmail^^[i].anonyFrom then									begin										tempString := MyUsers^^[theEmail^^[i].fromUser - 1].UName;									end									else										tempString := '>UNKNOWN<';									IUDateString(theEmail^^[i].dateSent, shortDate, tempString2);									NumToString(theEmail^^[i].fromUser, tempString4);									if length(theEmail^^[i].title) = 0 then									begin										if not theEmail^^[i].anonyFrom or (intSystRec.secLevels[thisUser.secLevel].readAnon) or (thisUser.coSysop) then											tempString3 := concat(tempString, ' #', tempString4, retinstr(18, 1), tempString2)										else											tempString3 := concat(tempString, retinstr(18, 1), tempString2);									end									else										tempString3 := concat(tempString, ' #', tempstring4, ' downloaded ', theEmail^^[i].title, ' on ', tempstring2);									OutLine(tempString3, true, 0);									if (availEmails - 1) > i then									begin										BlockMove(@theEmail^^[i + 1], @theEmail^^[i], longint(availEmails - 1 - i) * SizeOf(emailRec));									end;									SetHandleSize(handle(theEmail), GetHandleSize(handle(theEmail)) - SizeOf(emailRec));									availEmails := availEmails - 1;								end								else									i := i + 1;							end;							emailDirty := true;							SaveEmailData;							emailDirty := false;							if intSystRec.secLevels[thisUser.secLevel].useDayorCall then								templong := (longint(intSystRec.secLevels[thisUser.secLevel].timeAllowed - (thisUser.minOnToday div 60 div 60)) * 60 * 60)							else								templong := (longint(intSystRec.secLevels[thisUser.secLevel].timeAllowed) * 60 * 60) + extraTime;							tempint := tickCount - timebegin;							templong := Templong - tempint;							if (templong > nextDownTicks) and (nextdownticks > 0) then							begin								tempLong := nextdownticks div 60 div 60;								bCR;								NUMTOSTRING(templong, tempstring);								outChr(char(7));								OutLine(concat(retinstr(18, 2), tempstring, retinstr(18, 3)), true, 6);								OutLine('', false, 0);								shutdownsoon := true;							end;							bCR;							bCR;							i := 1;							while not thisUser.msgFrmAccess[i] and (i < 10) do								i := i + 1;							inForum := i;							if not thisUser.msgFrmAccess[inForum] then								inForum := 1;							FindMyEmail;							tempint := GetHandleSize(handle(myEmailList)) div 2;							if tempInt > 0 then							begin								bCR;								YesNoQuestion(retinstr(18, 4), false);							end							else								curPrompt := 'N';						end;						Trans2: 						begin							if curPrompt = 'Y' then							begin								bCR;								goBackToLogon := true;								LogonStage := Trans1;								Read_Mail;							end							else							begin								curPrompt := 'N';								if length(thisUser.computerType) = 0 then								begin									OutLine('Your computer type is unknown.  Please set it in "D"efaults.', true, 0);									bCR;								end;								GetTime(tempDate);								Secs2Date(thisUser.lastPWChange, tempDate2);								Secs2Date(thisUser.firstOn, tempDate3);								if (tempDate.year <> tempDate2.year) and (tempDate3.year < tempDate.year) then								begin									bCR;									IUDateString(tempLong, shortDate, tempstring);									if thisUser.lastPWChange = 0 then										OutLine(concat('Your last password update is unrecorded.'), true, 0)									else										OutLine(concat('Your last password update was: ', tempstring), true, 0);									bCR;									OutLine('You should update it now.', true, 0);									bCR;									YesNoQuestion(retinstr(18, 82), false);								end;							end;						end;						Trans3: 						begin							if (curPrompt = 'Y') then							begin								DefaultDo := DefaultSeven;								BoardSection := Defaults;							end							else							begin								BoardSection := ScanNew;								ScanNewDo := Scan1;								bCR;								YesNoQuestion(retinstr(18, 5), false);							end;						end;						otherwise					end;				end;				NewUser: 				begin					DoNewUser;				end;				Amsg: 				begin					case AutoDo of						AutoOne: 						begin							bCR;							if not thisUser.restrics[7] then							begin								LettersPrompt('A-msg: R:ead, W:rite, A:uto-reply, Q:uit  : ', 'RAWQ', 1, true, false, true, char(0));							end							else							begin								LettersPrompt('A-msg: R:ead, A:uto-reply, Q:uit  : ', 'RAQ', 1, true, false, true, char(0));							end;							AutoDo := AutoTwo;						end;						AutoTwo: 						begin							case curPrompt[1] of								'R': 								begin									bCR;									ReadAutoMessage;									GoHome;								end;								'W': 								begin									OutLine(retinstr(18, 6), true, 0);									bCR;									LettersPrompt('1:', '', 60, false, true, false, char(0));									excess := '';									AutoDo := AutoThree;								end;								'A': 								begin									sentAnon := IntSystRec.anonyAuto;									CallFMail := false;									NumToString(intSystRec.anonyUser, curPrompt);									EmailDo := EmailOne;									BoardSection := EMail;								end;								'Q': 								begin									GoHome;								end;								otherwise									autoDo := autoOne;							end;						end;						AutoThree: 						begin							autoMess := concat(curPrompt, char(13));							LettersPrompt('2:', '', 60, false, true, false, char(0));							if length(excess) > 0 then								OutLine(excess, false, myPrompt.inputColor);							curPrompt := excess;							excess := '';							AutoDo := AutoFour;						end;						AutoFour: 						begin							autoMess := concat(autoMess, curPrompt, char(13));							LettersPrompt('3:', '', 60, false, false, false, char(0));							if length(excess) > 0 then								OutLine(excess, false, myPrompt.inputColor);							curPrompt := excess;							excess := '';							AutoDo := AutoFive;						end;						AutoFive: 						begin							autoMess := concat(autoMess, curPrompt, char(13));							if not thisUser.Restrics[5] then							begin								YesNoQuestion(retinstr(18, 7), false);							end;							AutoDo := AutoSix;						end;						AutoSix: 						begin							if curPrompt = 'Y' then								retob := true							else								retob := false;							bCR;							YesNoQuestion(retinstr(18, 8), true);							AutoDo := AutoSeven;						end;						AutoSeven: 						begin							if curprompt = 'Y' then							begin								intSystRec.anonyUser := thisUser.UserNum;								intSystRec.anonyAuto := retob;								doSystRec(true);								sysopLog('      Changed auto-message.', 0);								tempString := concat(SharedPath, 'Auto Message');								result := FSDelete(tempString, 0);								result := Create(tempString, 0, 'HRMS', 'TEXT');								result := FSOpen(tempString, 0, tempShort);								result := SetEOF(tempShort, length(autoMess));								result := SetFPos(tempShort, fsFromStart, 0);								tempInt := length(autoMess);								result := FSWrite(tempShort, tempInt, @autoMess[1]);								result := FSClose(tempShort);							end;							GoHome;						end;						otherwise					end;				end;				Post: 				begin					DoPosting;				end;				EXTERNAL: 				begin					if activeUserExternal = -1 then					begin						bCR;						OutLine(retinstr(18, 9), true, 0);						bCR;						tempInt := 0;						for i := 1 to numExternals do						begin							tempBool := true;							if myExternals^^[i].RestrictionMenu <> char(0) then								if thisUser.restrics[byte(myExternals^^[i].RestrictionMenu) - 64] then									tempBool := true								else									tempBool := false;							if (myExternals^^[i].userExternal) and (thisUser.secLevel >= myExternals^^[i].minSLforMenu) and tempBool then							begin								tempInt := tempint + 1;								NumToString(tempInt, tempString);								OutLine(concat(tempString, '. ', myExternals^^[i].name), true, 0);							end;						end;						if tempint > 0 then						begin							crossInt := tempInt;							bCR;							bCR;							NumbersPrompt(retinstr(18, 10), 'Q?', tempInt, 1);							activeUserExternal := -2;						end						else						begin							GoHome;							bCR;							OutLine(retinstr(18, 11), true, 0);						end;					end					else if activeUserExternal = -2 then					begin						if curPrompt = '?' then							activeUserExternal := -1						else if curPrompt = 'Q' then							GoHome						else						begin							StringToNum(curPrompt, tempLong);							if (tempLong > 0) and (tempLong <= crossint) then							begin								tempShort := 0;								i := 0;								repeat									i := i + 1;									tempBool := true;									if myExternals^^[i].RestrictionMenu <> char(0) then										if thisUser.restrics[byte(myExternals^^[i].RestrictionMenu) - 64] then											tempBool := true										else											tempBool := false;									if (myExternals^^[i].userExternal) and tempBool and (thisUser.secLevel >= myExternals^^[i].minSLforMenu) then										tempShort := tempShort + 1;								until (tempShort = tempLong);								activeUserExternal := i;							end							else								activeUserExternal := -1;						end;					end					else if activeUserExternal > 0 then					begin						CallUserExternal(ACTIVEEXT, activeUserExternal);					end;				end;				Email: 				begin					case EmailDo of						WhichUser: 						begin							CallFMail := false;							SentAnon := false;							OutLine(retinstr(18, 12), true, 0);							bCR;							LettersPrompt(': ', '', 45, false, false, true, char(0));							EmailDo := EmailOne;						end;						EmailOne: 						begin							DoEMail;						end;						EmailTwo: 						begin							if length(CurPrompt) > 0 then							begin								CurEMailRec.title := CurPrompt;								if useWorkspace = 0 then								begin									maxLines := intSystRec.secLevels[thisUser.secLevel].lnsMessage;									EnterMessage(maxLines);									EmailDo := EmailThree;									BoardAction := Writing;									prompting := false;									endAnony := 0;								end								else								begin									if (useWorkspace = 1) then									begin										LoadFileAsMsg('Local Workspace');										OutLine(retinstr(18, 13), true, 0);									end									else									begin										NumToString(useWorkspace - 1, tempstring);										LoadFileAsMsg(concat('Form', tempstring));										tempstring := takeMsgTop;										if (length(tempstring) > 70) then											tempstring[0] := char(70);										curEMailRec.title := tempstring;										OutLine('Form letter enclosed.', true, 0);									end;									useWorkspace := 0;									bCR;									bCR;									EmailDo := EmailThree;								end;							end							else							begin								OutLine(retinstr(18, 14), false, 3);								bCR;								if not callFMail then								begin									GoHome;								end								else								begin									BoardSection := ReadMail;									bCR;									PrintCurEmail;								end;							end;						end;						EmailThree: 						begin							if curWriting <> nil then							begin								bCR;								if netMail then									endAnony := -1;								if (not thisUser.Restrics[5]) and (endAnony = 0) then								begin									YesNoQuestion(retinstr(18, 7), false);								end								else								begin									CurPrompt := 'N';									if (not thisUser.restrics[5]) and (EndAnony = 1) then										curprompt := 'Y'									else if (not thisUser.restrics[5]) and (EndAnony = -1) then										curprompt := 'N';								end;								EMailDo := EmailFour;							end							else							begin								bCR;								if not callFMail then								begin									GoHome;								end								else								begin									BoardSection := ReadMail;									bCR;									PrintCurEmail;								end;							end;						end;						EMailFour: 						begin							if CurPrompt = 'Y' then								CurEMailRec.AnonyFrom := true							else								CurEMailRec.AnonyFrom := false;							if sentAnon then								curEmailRec.anonyTo := true;							OutLine(retinstr(18, 15), false, 0);							if (MailingUser.Mailbox) and not NetMail then							begin								NumToString(mailingUser.forwardedTo, tempString2);								if FindUser(tempString2, tempuser) then								begin									if not tempUser.deleting then									begin										curEmailRec.toUser := tempuser.userNum;										NumToString(mailingUser.userNum, tempstring2);										AddLine(concat(retinstr(18, 16), mailinguser.username, ' #', tempstring2, char(13)));									end;								end								else									AddLine('');							end							else if not netMail then								AddLine('');							if not netMail then							begin								if not SaveMessasEmail then									OutLine('Error: Email database full.', true, 6);							end							else								SaveNetMail;							if not NewFeed then							begin								if not curEmailRec.multiMail then								begin									NumToString(mailingUser.UserNum, tempString2);									if netmail then										tempstring := concat('      Mail sent to ', myFido.name, ' at node ', myFido.atNode, '.')									else										tempString := concat('      Mail sent to ', mailingUser.UserName, ' #', tempString2);									sysopLog(tempString, 0);								end								else								begin									SysopLog('      Sent Multi-Mail to:', 0);									for i := 1 to numMultiUsers do									begin										NumToString(multiUsers[i], tempstring);										SysopLog(concat('        ', myUsers^^[multiUsers[i] - 1].UName, ' #', tempstring), 0);									end;								end;							end;							if curEmailRec.multiMail then							begin								thisUser.EMsentToday := thisUser.EMsentToday + numMultiUsers;								thisUser.EMailSent := thisUser.EMailSent + numMultiUsers;								intSystRec.eMailToday := intSystRec.eMailToday + numMultiUsers;							end							else							begin								thisUser.EMsentToday := thisUser.EMsentToday + 1;								thisUser.EMailSent := thisUser.EMailSent + 1;								intSystRec.eMailToday := intSystRec.eMailToday + 1;							end;							doSystRec(true);							NumToString(mailingUser.UserNum, tempString2);							if netMail then							begin								tempstring := concat('Mail sent to ', myFido.name, ' at node ', myFido.atNode, '.');							end							else							begin								if not curEmailRec.multiMail then								begin									if (not SentAnon) or (thisUser.coSysop) then										tempString := concat('Mail sent to ', mailingUser.UserName, ' #', tempString2)									else										tempString := 'Mail sent to >UNKNOWN<';								end								else									tempstring := 'Multi-Mail sent';							end;							OutLine(tempString, false, 0);							bCR;							if not callFMail then							begin								GoHome;							end							else							begin								BoardSection := ReadMail;								bCR;								PrintCurEmail;							end;						end;						EmailFive: 						begin							StringToNum(curprompt, tempInt);							if (tempInt > 0) and (tempInt < 10) then							begin								useWorkspace := tempInt + 1;								bCR;								EmailDo := EmailOne;								curPrompt := replyStr;							end							else								GoHome;						end;						otherwise					end;				end;				Defaults: 					ChangeDefaults;				QScan: 					DoQScan;				Sort: 					DoSort;				ChatStage: 				begin					case ChatDo of						ChatOne: 						begin							if not triedChat then							begin								if SysopAvailable and not thisUser.restrics[2] then								begin									bCR;									LettersPrompt(retinstr(18, 17), '', 60, false, false, false, char(0));									ChatDo := ChatTwo;								end								else								begin									sysopLog('      Tried Chatting.', 0);									bCR;									OutLine(retinstr(18, 18), false, 0);									OutLine(retinstr(18, 19), true, 0);									bCR;									CurPrompt := '1';									if FindUser(curPrompt, tempuser) then										YesNoQuestion(concat('E-mail ', tempUser.UserName, ' #1? '), false);									ChatDo := ChatThree;								end;							end							else							begin								triedChat := false;								OutLine(retinstr(18, 20), false, 0);								bCR;								bCR;								GoHome;							end;						end;						ChatTwo: 						begin							if length(curPrompt) > 0 then							begin								tempString := concat('      Chat: ', CurPrompt);								sysopLog(tempString, 0);								bCR;								OutLine(retinstr(18, 21), false, 0);								triedChat := true;								bCR;								bCR;								NumToString(activeNode, tempstring);								tempstring := concat('Chat ', tempString);								if GetNamedResource('snd ', tempstring) <> nil then									StartMySound(tempString, false)								else									for i := 1 to 4 do										SysBeep(1);								OutLine(retinstr(18, 22), true, 0);							end;							bCR;							bCR;							GoHome;						end;						ChatThree: 						begin							if curPrompt = 'Y' then							begin								CurPrompt := '1';								BoardSection := EMail;								EmailDo := EmailOne;							end							else							begin								bCR;								GoHome;							end;						end;						otherwise					end;				end;				OffStage: 				begin					case OffDo of						SureQuest: 						begin							bCR;							bCR;							YesNoQuestion(retinstr(18, 23), false);							OffDo := OffText;						end;						OffText: 						begin							if CurPrompt = 'Y' then							begin								ClearScreen;								tempString := concat('Time on  = ', tickToTime(tickCount - timeBegin));								OutLine(tempString, false, 0);								bCR;								bCR;								if ReadTextFile('Log Off', 1, false) then								begin									BoardAction := ListText;									ListTextFile;								end								else								begin									bCR;									OutLine('Can''t find Logoff file', true, 0);								end;								OffDo := Hanger;							end							else								GoHome;						end;						Hanger: 						begin							Delay(50, tempLong);							HangupAndReset;						end;						otherwise					end;				end;				ReadMail: 				begin					case ReadDo of						readOne: 						begin							Read_Mail;						end;						readTwo: 						begin							FindMyEmail;							tempint2 := GetHandleSize(handle(myEmailList)) div 2;							bCR;							HelpNum := 10;							OutLine(retinstr(18, 24), true, 0);							bCR;							NumbersPrompt(':', 'Q', tempInt2, 1);							ReadDo := ReadThree;						end;						readThree: 						begin							if curprompt = 'Q' then							begin								GoHome;							end							else							begin								FindMyEmail;								tempint2 := GetHandleSize(handle(myEmailList)) div 2;								if curprompt <> '' then								begin									StringToNum(curPrompt, tempInt);									if (tempint2 >= tempInt) and (tempInt > 0) then									begin										atEMail := tempInt - 1;									end									else										atEMail := tempint2 - 1;								end								else									atEMail := 0;								PrintCurEMail;								ReadDo := ReadFour;							end;						end;						readFour: 						begin							FindMyEmail;							tempint := GetHandleSize(handle(myEmailList)) div 2;							if tempint > 0 then							begin								tempString := 'AFGRQDISE?+-';								if (thisUser.coSysop) then									tempString := 'AFGRQZDISVOE?+-';								bCR;								HelpNum := 28;								NumbersPrompt(retinstr(18, 25), tempstring, -1, 0);								ReadDo := readFive;							end							else								GoHome;						end;						readFive: 						begin							bCR;							DoMailCommand(curprompt);						end;						ReadSix: 						begin							FindMyEmail;							tempint := GetHandleSize(handle(myEmailList)) div 2;							StringToNum(curprompt, tempLong);							if (templong <= tempint) and (tempLong > 0) then								atEMail := tempLong - 1;							readDo := ReadFour;							PrintCurEMail;						end;						ReadSeven: 						begin							if FindUser(curPrompt, tempUser) then							begin								if tempUser.UserNum <> thisUser.UserNum then								begin									if not tempUser.deleting then									begin										NumToString(tempuser.UserNum, tempString);										YesNoQuestion(concat(retinstr(18, 26), tempUser.UserName, ' #', tempString, ' ?'), false);										ReadDo := ReadEight;									end									else									begin										OutLine(retinstr(18, 27), true, 0);										ReadDo := ReadFour;									end;								end								else								begin									OutLine(retinstr(18, 28), true, 0);									ReadDo := ReadFour;								end;							end							else							begin								OutLine(retinstr(18, 29), true, 0);								ReadDo := ReadFour;							end;						end;						ReadEight: 						begin							if CurPrompt = 'Y' then							begin								FindMyEmail;								bCR;								ReadDo := ReadFour;								curEmailRec := theEmail^^[myEmailList^^[atEmail]];								theEmail^^[myEmailList^^[atEmail]].toUser := tempuser.userNum;								if curWriting <> nil then									DisposHandle(handle(curWriting));								curWriting := nil;								curWriting := ReadMessage(TRUE, curEmailrec.storedAs, 0, 0);								tempString := takeMsgTop;								if curWriting^^[0] <> char(13) then									AddLine(char(13));								NumToString(thisUser.userNum, tempstring2);								AddLine(concat(retinstr(18, 16), thisuser.username, ' #', tempstring2));								RemoveMessage(TRUE, curemailrec.storedAs, 0, 0);								SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) + 1);								curWriting^^[GetHandleSize(handle(curWriting)) - 1] := char(26);								theEmail^^[myEmailList^^[atEmail]].storedAs := SaveMessage(TRUE, curWriting, 0, 0);								emaildirty := true;								OutLine(retinstr(18, 30), true, 0);								bCR;							end							else								ReadDo := ReadFour;						end;						JumpForum: 						begin							StringToNum(curPrompt, tempInt);							if tempint = 0 then								tempint := 10;							tempint3 := 0;							tempshort := 0;							lastref := 0;							for tempint2 := 1 to intMessStuff^^.numForums do							begin								if thisUser.msgFrmAccess[tempint2] then									tempInt3 := tempInt3 + 1;								if (tempInt3 = tempInt) and (lastRef = 0) then								begin									lastref := 1;									tempShort := tempint2;								end;							end;							if tempShort > 0 then							begin								if (tempshort <= intMessStuff^^.numForums) and (tempshort > 0) then								begin									if (thisUser.msgFrmAccess[tempshort]) then									begin										inSub := 1;										inForum := tempshort;									end									else										OutLine(retinstr(18, 31), true, 0);								end								else									OutLine(retinstr(18, 31), true, 0);							end							else								OutLine(retinstr(18, 31), true, 0);							GoHome;						end;						otherwise					end;				end;				BBSlist: 					doBBSlist;				Upload: 					doUpload;				ListFiles: 					ListFil;				UEdit: 					DoUserEdit;				Download: 					DoDownload;				rmv: 					DoRemove;				USList: 					DoListUsers;				RmvFiles: 					RemoveFiles;				MainMenu: 				begin					case MainStage of						MenuText: 						begin							if endQScan then							begin								OutLine(concat('< ', intMessStuff^^.boards[inForum, inSub].name, ' Q-Scan Done >'), false, 1);								bCR;								lnsPause := 0;								endQScan := false;							end;							if not inNScan or fromQScan then							begin								if not newFeed and not fromQScan then								begin									bCR;									if not thisUser.Expert then									begin										if inTransfer then											welcomeName := 'Transfer Menu'										else											WelcomeName := 'Main Menu';										if ReadTextFile(WelcomeName, 1, false) then										begin											BoardAction := ListText;											ListTextFile;										end										else										begin											OutLine('Menu file not found.', true, 0);										end;									end;									MainStage := MainPrompt;								end								else if newFeed then								begin									newFeed := false;									BoardSection := Logon;									LogonStage := Phone;									EnteredPass := thisUser.Password;									curPrompt := copy(thisUser.phone, 9, 4);									RealSL := thisUser.SecLevel;								end								else if fromQScan then								begin									if fromMsgScan then									begin										BoardSection := ScanNew;										inSub := saveInSub;										inForum := saveInForum;										inMessage := crossInt3;										fromMsgScan := false;									end									else									begin										BoardSection := Qscan;										QDo := QTwo;									end;									fromQScan := false;								end;							end							else								NScanCalc;						end;						MainPrompt: 						begin							bufferIt(concat('T - ', tickToTime(ticksLeft(activeNode))), true, 0);							if (intMessStuff^^.numforums > 1) and thisUser.msgFrmAccess[inForum] and not inTransfer then							begin								bufferIt(concat('[', intMessStuff^^.forums[inForum], ']'), true, 1);							end;							bufferbCR;							ReleaseBuffer;							MamaPrompt(tempString);							MainMenuPrompt(tempString);							MainStage := MenuText;						end;						TextForce: 						begin							bCR;							if inTransfer then								welcomeName := 'Transfer Menu'							else								WelcomeName := 'Main Menu';							ClearScreen;							if ReadTextFile(welcomeName, 1, false) then							begin								BoardAction := ListText;								ListTextFile;							end							else							begin								OutLine('File not found.', true, 0);								BoardAction := none;							end;							MainStage := MainPrompt;						end;						otherwise					end;				end;				otherwise			end;			aborted := false;		end;	end;end.