unit FileTrans2;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, nodeprefs, inpOut2, InpOut, User, SystemPrefs, Message_Editor, terminal;	function PrintFileInfo (theFl: filEntryRec; fromDir: integer; doOther: boolean): boolean;	function DLRatioOK: boolean;	procedure EnterExtended;	procedure DoNodeStuff;	procedure PrintCurMessage (updateQPtrs: boolean);	procedure CloseTransferSections (theWindow: WindowPtr);	procedure DoRename;	procedure PrintExtended (indent: boolean);	procedure MultiChatOut (whatstring: str255; header: boolean);	function secs2Time (howmanysecs: longint): str255;	procedure OpenTransferSections;	procedure PrintSubList (whichFor: integer);	procedure PrintForumList;	procedure printDirList;	function FileOKMask (fileNm: str255; fileMsk: str255): boolean;	procedure DoMove;	function AskDesc (fileName: str255): str255;	procedure UpdateTransferSections (theWindow: WindowPtr);	procedure DoTransferSections (theEvent: EventRecord; theWindow: WindowPtr; itemHit: integer);	procedure PrintUserStuff;	procedure doDLStuff (writeIt: boolean);	procedure UploadVRef (dirPath: str255);	procedure RemoveFiles;	procedure SwitchError (er: str255);implementation	const		I_Cancel = 1;		I_New = 2;		I_Clear = 3;	var		List_I_List1: ListHandle;		Rect_I_List1: Rect;		ExitDialog: Boolean;		tempRect: Rect;		DType: Integer;		Index: Integer;		DItem: Handle;		CItem, CTempItem: controlhandle;		sTemp: Str255;		temp: Integer;		dataBounds: Rect;		cSize: Point;		curDir: integer;	procedure PrintCurMessage (updateQPtrs: boolean);		var			tempString, s1, s2, tempString2, tempString3, tempString4, tempString5, posterName: str255;			ref: integer;			tempLong: longInt;			result: OSerr;			tempDate: DateTimeRec;	begin		with curglobs^ do		begin			if curWriting <> nil then				DisposHandle(handle(curWriting));			curWriting := nil;			readMsgs := true;			lastKeyPressed := tickCount;			curMesgRec := curBase^^[inMessage - 1];			if curMesgRec.fromUserNum <> 0 then			begin				bufferBCR;				curwriting := ReadMessage(curMesgRec.storageType, curmesgrec.storedAs, inForum, inSub);				mesRead := mesRead + 1;				if not continuous and not inZscan then					BufClearScreen;				posterName := curMesgRec.fromUserName;				if curMesgRec.fromUserNum > 0 then				begin					NumToString(curMesgRec.fromUserNum, tempString5);					posterName := concat(posterName, ' #', tempstring5);				end;				NumToString(inMessage, tempString);				NumToString(curNumMess, tempString2);				BufferIt('Subj', false, 4);				BufferIt(concat(': ', curMesgrec.title), false, 0);				templong := 71 - (6 + length(curmesgRec.title));				tempstring3 := '';				if templong > 0 then					for ref := 1 to templong do						tempstring3 := concat(tempstring3, ' ');				BufferIt(tempstring3, false, 0);				BufferIt(concat('(', tempstring, '/', tempstring2, ')'), false, 3);				if thisUser.cosysop and not curMesgRec.deletable then				begin					BufferIt('||||', true, 4);					BufferIt('> Permanent Message', false, 6);					if thisUser.canANSI then						bufferIt('', false, 0);				end;				BufferIt('From', true, 4);				if (curMesgRec.anonyFrom) and not (intSystRec.SecLevels[thisUser.SecLevel].readAnon) then					BufferIt(': >UNKNOWN<', false, 0)				else				begin					if not intMessStuff^^.boards[inforum, insub].echoConf then					begin						if (curmesgRec.fromUserNum <> 0) and (curMesgRec.fromuserNum <= numUserRecs) then						begin							IUDateString(myUsers^^[curmesgRec.fromUserNum - 1].last, shortDate, tempstring5);							if (curMesgRec.anonyFrom) and (intSystRec.SecLevels[thisUser.SecLevel].readAnon) then								tempString := concat(': <<<', posterName, '>>> Last on: ', tempString5)							else if (thisUser.coSysop) then								tempString := concat(': ', posterName, ' [ ', myUsers^^[curMesgRec.fromUserNum - 1].real, ' ]  Last on: ', tempString5)							else								tempString := concat(': ', posterName, ' Last on: ', tempString5);							BufferIt(tempString, false, 0);						end						else							BufferIt(': <<USER NOT FOUND>>', false, 0);					end					else					begin						if FindUser(curMesgRec.fromUserName, tempuser) then							NumToString(tempUser.userNum, tempstring)						else							tempstring := '';						if length(tempstring) > 0 then							BufferIt(concat(': ', curMesgRec.fromUserName, ' #', tempstring), false, 0)						else							BufferIt(concat(': ', curMesgRec.fromUserName), false, 0);					end;				end;				if intmessStuff^^.boards[inForum, inSub].threading then				begin					NumToString(curMesgrec.touserNum, tempString5);					BufferIt('To  ', true, 4);					if not curMesgRec.anonyTo then					begin						if curMesgRec.toUserNum > 0 then							BufferIt(concat(': ', curMesgrec.toUserName, ' #', tempstring5), false, 0)						else if curMesgRec.toUserNum = TABBYTOID then							BufferIt(concat(': ', curMesgrec.toUserName), false, 0)						else							BufferIt(': All', false, 0);					end					else						BufferIt(concat(': >UNKNOWN<'), false, 0);				end;				tempstring3 := takeMsgTop;				if (curMesgRec.anonyFrom) and not (intSystRec.SecLevels[thisUser.SecLevel].readAnon) then					tempString3 := '>>>INACTIVE<<<';				BufferIt('Date', true, 4);				BufferIt(concat(': ', tempString3), false, 0);			end;			if updateQPtrs then				if (curmesgRec.QscnPtr > thisuser.lastMsgs[inforum, insub]) and not threadmode then					thisuser.lastmsgs[inforum, insub] := curmesgRec.QscnPtr;			ReleaseBuffer;			bCR;			bCR;			if textHnd <> nil then				disposHandle(handle(texthnd));			texthnd := nil;			textHnd := texthand(curWriting);			curWriting := nil;			if textHnd <> nil then			begin				curtextPos := 0;				openTextSize := GetHandleSize(handle(texthnd));				BoardAction := ListText;			end			else				OutLine('Message not found.', true, 0);		end;	end;	procedure CloseTransferSections;	begin		if (theWindow = GetDSelection) and (GetDSelection <> nil) then		begin			DisposDialog(GetDSelection);			GetDSelection := nil;		end;	end;	procedure printForumList;		var			i, b: integer;			tempString: str255;	begin		with curglobs^ do		begin			OutLine('Forums available:', true, 0);			bCR;			b := 0;			for i := 1 to intMessStuff^^.numForums do			begin				if (thisUser.MsgFrmAccess[i]) then				begin					b := b + 1;					if b = 10 then						tempString := '0'					else						NumToString(b, tempString);					OutLine(concat(tempString, '   -  ', intMessStuff^^.forums[i]), true, 0);				end;			end;			bCR;		end;	end;	procedure PrintExtended (indent: boolean);		var			curPos, leng, i: integer;			tempString, s2: str255;	begin		s2 := '';		for i := 1 to 24 do			s2 := concat(s2, ' ');		with curglobs^ do		begin			curPos := 0;			leng := GetHandleSize(handle(curWriting));			repeat				tempString := '';				while (curWriting^^[curPos] <> char(13)) and (curPos < leng) do				begin					tempString := concat(tempString, curWriting^^[curPos]);					curPos := curPos + 1;				end;				curPos := curPos + 1;				bufferbCR;				if thisUser.canANSI and indent then					bufferIt(concat(char(27), '[24C', tempstring), false, 5)				else if thisUser.canANSI then					bufferIt(tempstring, false, 5)				else if INDENT then					bufferIt(concat(s2, tempstring), false, 5)				else					bufferIt(tempString, false, 5);			until (curPos >= (leng - 1));		end;	end;	procedure DoNodeStuff;		var			tempLong: Longint;			savedNode, i, b: integer;			mySavedBD: BDact;			te1, te2: str255;	begin		with curglobs^ do		begin			case NodeDo of				NodeOne: 				begin					NodeDo := NodeTwo;					bCR;					bCR;					bCR;					if thisUser.coSysop and (thisUser.secLevel = 255) then						LettersPrompt('Nodes: L:ist, M:essage, C:hat, S:py, D:isconnect, Q:uit : ', 'LMCSDQ', 1, true, false, true, char(0))					else						LettersPrompt('Nodes: L:ist, M:essage, C:hat, Q:uit : ', 'LMCQ', 1, true, false, true, char(0))				end;				NodeTwo: 				begin					if length(curPrompt) > 0 then					begin						case curPrompt[1] of							'Q': 								GoHome;							'C': 							begin								BoardSection := MultiChat;								MultiChatDo := Mult1;								OutLine('Entering chat room...', true, 1);								OutLine('Type ''/X'' to exit, and ''/H'' for help.', true, 1);								bCR;								NumToString(thisUser.userNum, te1);								MultiChatOut(concat(thisUser.userName, ' #', te1, ' is here.'), false);								curPrompt := '';								excess := '';							end;							'M': 							begin								NodeDo := NodeThree;								NumbersPrompt('To which node? ', '', intSystRec.numNodes, 1);							end;							'D': 							begin								NodeDo := NodeSeven;								NumbersPrompt('Disconnect which node? ', '', intSystRec.numNodes, 1);							end;							'S': 							begin								if spying = 0 then								begin									NodeDo := NodeFive;									NumbersPrompt('Spy on which node? ', '', intSystRec.numNodes, 1);								end								else									NodeDo := NodeOne;							end;							'L': 							begin								OutLine('Available Nodes:', true, 0);								b := 1;								for i := 1 to intSystRec.numNodes do								begin									if not (thenodes[i]^.nodeType < 0) or thisUser.coSysop then									begin										if (theNodes[i]^.boardMode = User) and (theNodes[i]^.thisUser.userNum > 0) then											te1 := theNodes[i]^.thisUser.userName										else											te1 := '<INACTIVE>';										NumToString(i, te2);										OutLine(concat(te2, '. ', te1), true, 0);									end;								end;								NodeDo := NodeOne;							end;							otherwise								NodeDo := NodeOne;						end;					end					else						NodeDo := NodeOne;				end;				NodeThree: 				begin					if length(curprompt) > 0 then					begin						StringToNum(curPrompt, tempLong);						crossInt := tempLong;						OutLine('You may now type a short message to send to that node: ', true, 0);						bCR;						LettersPrompt(': ', '', 75, false, false, false, char(0));						ANSIPrompter(75);						NodeDo := NodeFour;					end					else						NodeDo := NodeOne;				end;				NodeSix: 				begin					if aborted then					begin						OutLine('Exiting spy mode...', true, 1);						NodeDo := NodeOne;						theNodes[crossInt]^.spying := 0;						amSpying := false;					end;				end;				nodeSeven: 				begin					if length(curprompt) > 0 then					begin						StringToNum(curPrompt, tempLong);						crossInt := tempLong;						if (crossInt <> activeNode) and (crossInt <= intSystRec.numNodes) and (crossInt > 0) then						begin							if (theNodes[crossInt]^.boardMode = user) then							begin								savedNode := activeNode;								curGlobs := theNodes[crossInt];								activeNode := crossInt;								with curGlobs^ do								begin									if myTrans.active then									begin										extTrans^^.flags[carrierLoss] := true;										ClearInBuf;										repeat											ContinueTrans;										until not myTrans.active;									end;									if (thisUser.userNum) > 0 then										sysopLog('      Logged off from remote.', 6);									HangupAndReset;								end;								activeNode := savedNode;								curGlobs := theNodes[savedNode];								OutLine('Node disconnected.', true, 0);								NodeDo := NodeOne;							end							else if (theNodes[crossInt]^.boardMode = failed) then							begin								OutLine('Re-initializing stalled node.', true, 0);								savedNode := activeNode;								curGlobs := theNodes[crossInt];								activeNode := crossInt;								HangUpAndReset;								activeNode := savedNode;								curGlobs := theNodes[savedNode];							end							else							begin								OutLine('Inactive node.', true, 0);								NodeDo := NodeOne;							end;						end						else						begin							OutLine('Invalid node.', true, 0);							NodeDo := NodeOne;						end;					end					else						NodeDo := NodeOne;				end;				nodeFive: 				begin					if length(curprompt) > 0 then					begin						StringToNum(curPrompt, tempLong);						crossInt := tempLong;						if (crossInt <> activeNode) and (crossInt <= intSystRec.numNodes) and (crossInt > 0) then						begin							if (theNodes[crossInt]^.boardMode = user) and (theNodes[crossInt]^.thisUser.userNum > 0) then							begin								if not (theNodes[crossInt]^.myTrans.active) then								begin									if not (theNodes[crossInt]^.spying > 0) then									begin										OutLine('Entering spy mode, ^X to exit...', true, 1);										bCR;										if thisUser.canANSI then											dom(0);										amSpying := true;										theNodes[crossInt]^.spying := activeNode;										NodeDo := NodeSix;										BoardAction := Repeating;									end									else									begin										OutLine('That node is being spied on already.', true, 0);										NodeDo := NodeOne;									end;								end								else								begin									OutLine('That user is engaged in a file transfer.', true, 0);									NodeDo := NodeOne;								end;							end							else							begin								OutLine('Inactive node.', true, 0);								NodeDo := NodeOne;							end;						end						else						begin							OutLine('Invalid node.', true, 0);							NodeDo := NodeOne;						end;					end					else						NodeDo := NodeOne;				end;				NodeFour: 				begin					if (length(curprompt) > 0) then					begin						if (crossInt <> activeNode) and (crossInt <= intSystRec.numNodes) and (crossInt > 0) then						begin							if (theNodes[crossInt]^.boardMode = user) and (theNodes[crossInt]^.thisUser.userNum > 0) then							begin								if not (theNodes[crossInt]^.myTrans.active) and not (theNodes[crossInt]^.boardAction = chat) then								begin									NumToString(thisUser.userNum, te1);									NumToString(activeNode, te2);									curGlobs := theNodes[crossInt];									savedNode := activeNode;									activeNode := crossInt;									with curglobs^ do									begin										mySavedBD := BoardAction;										BoardAction := none;										if thisUser.canANSI then											dom(0);										BCR;										OutChr(char(7));										OutLine('Message From: ', true, 2);										OutLine(concat(theNodes[savedNode]^.thisUser.userName, ' #', te1, ' @', te2), false, 3);										OutLine(theNodes[savedNode]^.curPrompt, true, 5);										OutLine('', false, 0);										bCR;										BoardAction := mySavedBD;										if prompting then											ReprintPrompt										else if BoardAction = Writing then											ListLine(online);									end;									curGlobs := theNodes[savedNode];									activeNode := savedNode;									OutLine('Message sent.', true, 0);								end								else									outLine('Sorry, that user cannot be sent messages right now.', true, 0);							end							else								OutLine('That is an inactive node.', true, 0);						end						else						begin							if (crossInt > intSystRec.numNodes) or (crossInt < 1) then								OutLine('That is an inactive node.', true, 0)							else								OutLine('You cannot send a message to yourself.', true, 0);						end;					end;					NodeDo := NodeOne;					bCR;				end;				otherwise			end;		end;	end;	procedure MultiChatOut (whatstring: str255; header: boolean);		var			savedNode, i: integer;			t1, t2: str255;			mySavedBD: BDact;	begin		for i := 1 to intSystRec.numNodes do		begin			if (theNodes[i]^.BoardMode = User) and (theNodes[i]^.BoardSection = MultiChat) and (i <> activeNode) then			begin				curGlobs := theNodes[i];				savedNode := activeNode;				activeNode := i;				with curglobs^ do				begin					mySavedBD := BoardAction;					BoardAction := none;					if thisUser.canANSI then					begin						NumToString(gBBSwindows[activeNode]^.cursor.h + 1, t1);						ANSICode(concat(t1, 'D'));						ANSICode('K');					end					else						bCR;					if header then					begin						OutLine(concat(theNodes[savedNode]^.thisUser.UserName, ':'), false, 2);						excess := '';						OutLine(whatString, false, 0);					end					else						OutLine(whatString, false, 2);					BoardAction := mySavedBD;					if prompting then					begin						bCR;						ReprintPrompt;					end;				end;				curGlobs := theNodes[savedNode];				activeNode := savedNode;			end;		end;	end;	procedure PrintSubList (whichFor: integer);		var			i: integer;			tempString: str255;			tb2: boolean;	begin		with curglobs^ do		begin			if (thisUser.MsgFrmAccess[whichFor]) and (intMessStuff^^.numForums >= whichFor) and (intMessStuff^^.numBoards[whichFor] > 0) then			begin				bufferIt(concat('Subs available for ', intMessStuff^^.Forums[whichFor], ':'), true, 0);				bufferbCR;				for i := 1 to intMessStuff^^.numBoards[whichFor] do				begin					tb2 := true;					if intMessStuff^^.boards[whichFor, i].restrict <> char(0) then						if thisUser.restrics[(byte(intMessStuff^^.boards[whichFor, i].restrict) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (intMessStuff^^.Boards[whichFor, i].SLtoRead <= thisUser.SecLevel) and (thisUser.age >= intMessStuff^^.boards[whichFor, i].minage) then					begin						NumToString(i, tempString);						if i > 9 then							bufferIt(concat(tempString, ' - ', intMessStuff^^.Boards[whichFor, i].Name), true, 0)						else							bufferIt(concat(tempString, '  - ', intMessStuff^^.Boards[whichFor, i].Name), true, 0);					end;				end;			end			else				bufferIt('No subs available.', true, 0);			ReleaseBuffer;		end;	end;	function AskDesc (fileName: str255): str255;		var			askDilg: dialogPtr;			ThisEditText: TEHandle;			TheDialogPtr: DialogPeek;			DType, a: Integer;			DItem: Handle;			tempRect: rect;			tempString: str255;	begin		with curglobs^ do		begin			repeat				askDilg := GetNewDialog(744, nil, pointer(-1));				SetPort(askDilg);				TheDialogPtr := DialogPeek(askDilg);				ThisEditText := TheDialogPtr^.textH;				HLock(Handle(ThisEditText));				ThisEditText^^.txSize := 9;				TextSize(9);				ThisEditText^^.txFont := monaco;				TextFont(monaco);				ThisEditText^^.txFont := 4;				ThisEditText^^.fontAscent := 9;				ThisEditText^^.lineHeight := 9 + 2 + 0;				HUnLock(Handle(ThisEditText));				NumToString(70 - intDLStuff^^.dr[tempInDir].fileNameLength, tempstring);				ParamText(concat('Please enter a <', tempstring, ' character description for ', fileName, ' :'), '', '', '');				DrawDialog(askDilg);				repeat					ModalDialog(nil, a);				until (a = 1);				GetDItem(askDilg, 3, DType, DItem, tempRect);				GetIText(DItem, tempString);				DisposDialog(askDilg);				if length(tempString) > (70 - intDLStuff^^.dr[tempInDir].fileNameLength) then				begin					askDilg := GetNewDialog(1055, nil, pointer(-1));					NumToString(70 - intDLStuff^^.dr[tempInDir].fileNameLength, tempstring);					ParamText(concat('File description must be less than ', tempstring, ' characters.'), '', '', '');					DrawDialog(askDilg);					SysBeep(10);					repeat						ModalDialog(nil, a);					until (a = 1);					DisposDialog(askDilg);				end;			until (length(tempString) < (70 - intDLStuff^^.dr[tempInDir].fileNameLength));			askDesc := tempString;		end;	end;	procedure UploadVRef (dirPath: str255);		var			index, tempint: integer;			FName: Str255;			myCPB: CInfoPBRec;			myHPB: HParamBlockRec;			err: OSErr;			CONFIRMER, didIt: boolean;		procedure EnumerateCatalog (dirIDToSearch: longint);			var				ic: integer;		begin {EnumerateCatalog}			with curglobs^ do			begin				index := 1;				repeat					FName := '';					myCPB.ioFDirIndex := index;					myCPB.ioDrDirID := dirIDToSearch;					err := PBGetCatInfo(@myCPB, FALSE);					if err = noErr then						if not (BitTst(@myCPB.ioFlAttrib, 3)) then						begin {we have a file}							if confirmer then								didIt := (ModalQuestion(concat('Upload " ', fName, ' " ?'), false, true) = 1)							else								didIt := true;							if didIt then							begin								if confirmer then									curFil.flDesc := AskDesc(fName)								else									curFil.flDesc := '';								curFil.realFName := fName;								if (length(fName) > 20) then									fName[0] := char(20);								curFil.flName := fName;								GetDateTime(curFil.whenUL);								curFil.UploaderName := thisUser.UserName;								curFil.uploaderNum := thisUser.userNum;								curFil.numDLoads := 0;								curFil.hasExtended := false;								curFil.fileStat := char(0);								curFil.lastDL := 0;								for ic := 1 to 4 do									curFil.reserved[ic] := char(0);								FileEntry(curFil, tempinDir, tempInt, 0);								thisUser.numUploaded := thisUser.numUploaded + 1;								thisUser.UploadedK := thisUser.UploadedK + tempint;								intSystRec.uploadsToday := intSystRec.uploadsToday + 1;								DoSystRec(true);							end;						end; {else}					index := index + 1;				until (err <> noErr);			end;		end;  {EnumerateCatalog}{begin uploadVRef}	begin		confirmer := (ModalQuestion('Confirm choices and ask for descriptions?', false, true) = 1);		myCPB.ioCompletion := nil;		myCPB.ioNamePtr := @dirPath;		myCPB.ioVRefNum := 0;		myCPB.ioFDirIndex := 0;		result := PBGetCatInfo(@myCPB, false);		myHPB.ioCompletion := nil;		myHPB.ioNamePtr := @dirPath;		myHPB.ioVRefNum := 0;		myHPB.ioVolIndex := -1;		result := PBHGetVInfo(@myHPB, false);		myCPB.iovRefNum := myHPB.ioVRefNum;		myCPB.ioNamePtr := @fName;		if result = noErr then			EnumerateCatalog(myCPB.ioDrDirID);		curglobs^.lastKeyPressed := tickCount;	end;{$D-}	function FindCell (mousPos: point): cell;		var			startCell, selCell: cell;			temprect: rect;	begin		StartCell := cell($00000000);		selCell := cell($FFFFFFFF);		repeat			LRect(temprect, startCell, List_I_List1);			if PtInRect(mousPos, tempRect) then				selCell := startCell;		until not LNextCell(false, true, startCell, List_I_list1);		FindCell := selcell;	end;	function FmyListDragger: boolean;		var			myCell, myCell2: cell;			tempRect: rect;			tempBool, tempbool2, tb3: boolean;			curMouse: point;			addLine, i, useddiff, tempint: integer;			movedTo, hDiff, vDiff: longint;			takeThis, toHere: integer;			dragged: rgnHandle;			tempDirInfo: DirInfoRec;	begin		tempbool2 := true;		SetPort(getDSelection);		myCell := LLastClick(List_I_List1);		myCell2 := cell($00000000);		tempbool := LGetSelect(true, myCell2, list_I_list1);		if (longint(myCell) = longint(mycell2)) and (myCell.v >= 0) and (myCell.v < List_I_list1^^.dataBounds.bottom) and tempBool and (myCell2.v < List_I_list1^^.dataBounds.bottom) then		begin			if (longint(myCell) = longint(DragFirst)) then			begin				myCell2.h := 0;				myCell2.v := 0;				LRect(temprect, myCell, List_I_List1);				dragged := NewRgn;				OpenRgn;				FrameRect(tempRect);				CloseRgn(dragged);				movedTo := DragGrayRgn(dragged, List_I_List1^^.clikLoc, List_I_List1^^.rView, GetDSelection^.portRect, vAxisOnly, nil);				DisposeRgn(dragged);				vDiff := hiWord(movedTo);				hDiff := LoWord(movedTo);				usedDiff := temprect.top + abs(vDiff);				if ((vDiff <> $8000) and (hDiff <> $8000)) and (abs(usedDiff - tempRect.top) > 8) then				begin					curMouse.v := list_I_List1^^.clikLoc.v + vDiff;					curmouse.h := list_I_List1^^.clikLoc.h + hDiff;					myCell2 := FindCell(curMouse);					if (longint(mycell2) <> $FFFFFFFF) and (longint(mycell2) <> longint(myCell)) then					begin						takeThis := myCell.v;						toHere := myCell2.v;						tempDirInfo := intDLStuff^^.dr[takeThis];						if intDLStuff^^.numDirs > (takeThis + 1) then						begin							for i := (takeThis + 2) to intDLStuff^^.numDirs do								intDLStuff^^.dr[i - 2] := intDLStuff^^.dr[i - 1];						end;						if intDLStuff^^.numDirs > (toHere + 1) then						begin							for i := intDLStuff^^.numDirs downto (toHere + 2) do								intDLStuff^^.dr[i - 1] := intDLStuff^^.dr[i - 2];						end;						intDLStuff^^.dr[toHere] := tempDirInfo;					end;					LDelRow(0, 0, List_I_List1);					for i := 1 to intDLstuff^^.numDirs do					begin						AddListString(intDLstuff^^.dr[i - 1].dirName, list_I_list1);					end;				end;			end;			DragFirst := myCell2;		end;		FmyListDragger := tempbool2;	end;{$D+}	procedure OpenTransferSections;		var			Index, i: integer;			theRow: integer;			sTemp: Str255;			ThisEditText: TEHandle;			TheDialogPtr: DialogPeek;	begin		if (GetDSelection = nil) then		begin			doDLstuff(false);			GetDSelection := GetNewDialog(4, nil, Pointer(-1));			ShowWindow(GetDSelection);			SelectWindow(GetDSelection);			SetPort(GetDSelection);			TheDialogPtr := DialogPeek(GetDSelection);			ThisEditText := TheDialogPtr^.textH;			HLock(Handle(ThisEditText));			ThisEditText^^.txSize := 9;			TextSize(9);			ThisEditText^^.txFont := 150;			TextFont(150);			ThisEditText^^.txFont := 150;			ThisEditText^^.fontAscent := 9;			ThisEditText^^.lineHeight := 9 + 2 + 0;			HUnLock(Handle(ThisEditText));			GetDItem(GetDSelection, 4, DType, DItem, Rect_I_List1);			tempRect := Rect_I_List1;			tempRect.Right := tempRect.Right - 15;			if (tempRect.Right <= (tempRect.Left + 15)) then				tempRect.Right := tempRect.Left + 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			InsetRect(tempRect, 1, 1);			SetRect(dataBounds, 0, 0, 1, 0);			cSize.h := tempRect.Right - tempRect.Left;			cSize.v := 11;			List_I_List1 := LNew(tempRect, dataBounds, cSize, 0, GetDSelection, false, FALSE, FALSE, TRUE);			List_I_List1^^.selFlags := lOnlyOne + lNoNilHilite;			List_I_List1^^.lClikLoop := @FmyListDragger;			for i := 1 to intDLstuff^^.numDirs do			begin				AddListString(intDLstuff^^.dr[i - 1].dirName, list_I_list1);			end;			LdoDraw(TRUE, List_I_List1);			cSize.v := 0;			LSetSelect(TRUE, cSize, List_I_List1);			curDir := 0;		end		else			SelectWindow(getDSelection);	end;	procedure doDLstuff;		var			tempFileName: str255;			result: OSerr;			i, sharedRef: integer;			tempLong: longInt;			initMessHand: DirDataHand;	begin		UseResFile(RShared);		handle(InitMessHand) := Get1Resource('MesD', 1);		HNoPurge(handle(InitMessHand));		if reserror <> noErr then			sysbeep(10);		if writeIt then			InitMessHand^^ := intDLStuff^^		else			intDLStuff^^ := InitMessHand^^;		if writeIt then		begin			ChangedResource(handle(InitMessHand));			WriteResource(handle(InitMessHand));		end;		HPurge(handle(InitMessHand));		UseResFile(myResourceFile);	end;	procedure UpdateTransferSections;		var			SavedPort: GrafPtr;	begin		if (GetDSelection <> nil) and (theWindow = GetDSelection) then		begin			GetPort(SavedPort);			SetPort(GetDSelection);			tempRect := Rect_I_List1;			tempRect.Right := tempRect.Right - 15;			if (tempRect.Right <= (tempRect.Left + 10)) then				tempRect.Right := tempRect.Left + 10;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			LUpdate(GetDSelection^.visRgn, List_I_List1);			DrawDialog(GetDSelection);			SetPort(SavedPort);		end;	end;	procedure EditTransferSec (new: boolean; whichOne: integer);		var			theDilg: dialogPtr;			t1, oldname: str255;			a, adder: integer;		procedure SetNewStat;		begin			GetDItem(theDilg, 28, DType, DItem, tempRect);			citem := pointer(ditem);			SetCtlValue(citem, 0);			GetDItem(theDilg, 29, DType, DItem, tempRect);			citem := pointer(ditem);			SetCtlValue(citem, 0);			GetDItem(theDilg, 30, DType, DItem, tempRect);			citem := pointer(ditem);			SetCtlValue(citem, 0);			GetDItem(theDilg, 37, DType, DItem, tempRect);			citem := pointer(ditem);			SetCtlValue(citem, 0);			GetDItem(theDilg, 29 - intDLStuff^^.dr[whichOne].mode, DType, DItem, tempRect);			citem := pointer(ditem);			SetCtlValue(citem, 1);		end;		procedure DrawPath;		begin			GetDItem(theDilg, 26, DType, DItem, tempRect);			FrameRect(temprect);			TextSize(9);			TextFont(3);			InsetRect(tempRect, 2, 2);			TextBox(@intDLStuff^^.dr[whichOne].path[1], length(intDLStuff^^.dr[whichOne].path), temprect, teJustLeft);		end;	begin		if new then		begin			with intDLStuff^^.dr[whichOne] do			begin				NumToString(whichOne, oldName);				DirName := concat('Directory', oldName);				Path := 'Macintosh HD:Hermes Files:Files:';				MinDSL := 10;				DSLtoUL := 10;				DSLtoDL := 10;				MaxFiles := 200;				Restriction := char(0);				NonMacFiles := 0;				freeDir := false;				mode := 0;   {  -1 = Never New, 0=Normal , 1= Always New  }				MinAge := 0;				FileNameLength := 12;				for a := 0 to 9 do					reserved[a] := char(0);			end;		end;		oldName := intDLStuff^^.dr[whichone].dirName;		theDilg := GetNewDialog(222, nil, pointer(-1));		setPort(theDilg);		GetDItem(theDilg, 16, DType, DItem, tempRect);		SetIText(DItem, intDLStuff^^.dr[whichOne].DirName);		GetDItem(theDilg, 17, DType, DItem, tempRect);		NumToString(intDLStuff^^.dr[whichOne].minDSL, t1);		SetIText(DItem, t1);		GetDItem(theDilg, 42, DType, DItem, tempRect);		NumToString(intDLStuff^^.dr[whichOne].DSLtoDL, t1);		SetIText(DItem, t1);		GetDItem(theDilg, 21, DType, DItem, tempRect);		NumToString(intDLStuff^^.dr[whichOne].maxFiles, t1);		SetIText(DItem, t1);		GetDItem(theDilg, 19, DType, DItem, tempRect);		NumToString(intDLStuff^^.dr[whichOne].DSLtoUL, t1);		SetIText(DItem, t1);		GetDItem(theDilg, 24, DType, DItem, tempRect);		NumToString(intDLStuff^^.dr[whichOne].minAge, t1);		SetIText(DItem, t1);		GetDItem(theDilg, 32, DType, DItem, tempRect);		if intDLStuff^^.dr[whichOne].restriction <> char(0) then			SetIText(Ditem, intDLStuff^^.dr[whichOne].restriction);		GetDItem(theDilg, 34, DType, DItem, tempRect);		NumToString(intDLStuff^^.dr[whichOne].fileNameLength, t1);		SetIText(DItem, t1);		SetNewStat;		GetDItem(theDilg, 37, DType, DItem, tempRect);		if intDLStuff^^.dr[whichOne].nonMacFiles = 1 then			SetCtlValue(controlHandle(Ditem), 1);		GetDItem(theDilg, 38, DType, DItem, tempRect);		if intDLStuff^^.dr[whichOne].freeDir then			SetCtlValue(controlHandle(Ditem), 1);		ShowWindow(theDilg);		DrawPath;		GetDItem(theDilg, 1, DType, DItem, tempRect);		InsetRect(tempRect, -4, -4);		PenSize(3, 3);		FrameRoundRect(tempRect, 16, 16);		repeat			ModalDialog(@usemodaltime, a);			if optiondown then				adder := 1			else				adder := 10;			case a of				37: 				begin					GetDItem(theDilg, 37, DType, DItem, tempRect);					SetCtlValue(controlHandle(Ditem), (GetCtlValue(controlHandle(Ditem)) + 1) mod 2);					if intDLStuff^^.dr[whichOne].nonMacFiles = 1 then						intDLStuff^^.dr[whichOne].nonMacFiles := 0					else						intDLStuff^^.dr[whichOne].nonMacFiles := 1;				end;				38: 				begin					GetDItem(theDilg, 38, DType, DItem, tempRect);					intDLStuff^^.dr[whichOne].freeDir := not intDLStuff^^.dr[whichOne].freeDir;					SetCtlValue(controlHandle(Ditem), (GetCtlValue(controlHandle(Ditem)) + 1) mod 2);				end;				10, 11: 				begin					adder := 1;					if (a = 11) then						adder := adder * (-1);					if ((intDLStuff^^.dr[whichOne].FileNameLength + adder) <= 20) and ((intDLStuff^^.dr[whichOne].FileNameLength + adder) >= 12) then					begin						intDLStuff^^.dr[whichone].FileNameLength := intDLStuff^^.dr[whichOne].FileNameLength + adder;						GetDItem(theDilg, 34, DType, DItem, tempRect);						NumToString(intDLStuff^^.dr[whichOne].FileNameLength, t1);						SetIText(DItem, t1);					end;				end;				8, 9: 				begin					if (a = 9) then						adder := adder * (-1);					if ((intDLStuff^^.dr[whichOne].minAge + adder) <= 99) and ((intDLStuff^^.dr[whichOne].minAge + adder) >= 0) then					begin						intDLStuff^^.dr[whichone].minAge := intDLStuff^^.dr[whichOne].minAge + adder;						GetDItem(theDilg, 24, DType, DItem, tempRect);						NumToString(intDLStuff^^.dr[whichOne].minAge, t1);						SetIText(DItem, t1);					end;				end;				6, 7: 				begin					if (a = 7) then						adder := adder * (-1);					if ((intDLStuff^^.dr[whichOne].DSLtoUL + adder) <= 255) and ((intDLStuff^^.dr[whichOne].DSLtoUL + adder) >= 1) then					begin						intDLStuff^^.dr[whichone].DSLtoUL := intDLStuff^^.dr[whichOne].DSLtoUL + adder;						GetDItem(theDilg, 19, DType, DItem, tempRect);						NumToString(intDLStuff^^.dr[whichOne].DSLtoUL, t1);						SetIText(DItem, t1);					end;				end;				39, 40: 				begin					if (a = 40) then						adder := adder * (-1);					if ((intDLStuff^^.dr[whichOne].DSLtoDL + adder) <= 255) and ((intDLStuff^^.dr[whichOne].DSLtoDL + adder) >= 1) then					begin						intDLStuff^^.dr[whichone].DSLtoDL := intDLStuff^^.dr[whichOne].DSLtoDL + adder;						GetDItem(theDilg, 42, DType, DItem, tempRect);						NumToString(intDLStuff^^.dr[whichOne].DSLtoDL, t1);						SetIText(DItem, t1);					end;				end;				4, 5: 				begin					if (a = 5) then						adder := adder * (-1);					if ((intDLStuff^^.dr[whichOne].maxFiles + adder) <= 9999) and ((intDLStuff^^.dr[whichOne].maxFiles + adder) >= 1) then					begin						intDLStuff^^.dr[whichone].maxFiles := intDLStuff^^.dr[whichOne].maxFiles + adder;						GetDItem(theDilg, 21, DType, DItem, tempRect);						NumToString(intDLStuff^^.dr[whichOne].maxFiles, t1);						SetIText(DItem, t1);					end;				end;				2, 3: 				begin					if (a = 3) then						adder := adder * (-1);					if ((intDLStuff^^.dr[whichOne].minDSL + adder) <= 255) and ((intDLStuff^^.dr[whichOne].minDSL + adder) >= 1) then					begin						intDLStuff^^.dr[whichone].minDSL := intDLStuff^^.dr[whichOne].minDSL + adder;						GetDItem(theDilg, 17, DType, DItem, tempRect);						NumToString(intDLStuff^^.dr[whichOne].minDSL, t1);						SetIText(DItem, t1);					end;				end;				28, 29, 30: 				begin					intDLStuff^^.dr[whichOne].mode := a - 29;					if (a - 29) = -1 then						intDLStuff^^.dr[whichOne].mode := 1					else if (a - 29) = 1 then						intDLStuff^^.dr[whichOne].mode := -1;					SetNewStat;				end;				26: 				begin					globalStr := 'Select path for this directory:';					stemp := doGetDirectory;					if sTemp <> '' then					begin						intDLstuff^^.dr[whichone].path := sTemp;					end;					DrawPath;				end;				otherwise			end;		until (a = 1);		GetDItem(theDilg, 32, DType, DItem, tempRect);		GetIText(DItem, t1);		if (length(t1) > 0) and ((t1[1] >= 'A') and (t1[1] <= 'Z')) then			intDLStuff^^.dr[whichOne].restriction := t1[1]		else			intDLStuff^^.dr[whichOne].restriction := char(0);		GetDItem(theDilg, 16, DType, DItem, tempRect);		GetIText(DItem, t1);		if length(t1) > 0 then		begin			if length(t1) < 27 then			begin				intDLStuff^^.dr[whichOne].dirName := t1;				if t1 <> oldName then				begin					result := Rename(concat(sharedPath, 'Data:', oldname), 0, concat(sharedPath, 'Data:', t1));					result := Rename(concat(sharedPath, 'Data:', oldname, '.EXT'), 0, concat(sharedPath, 'Data:', t1, '.EXT'));				end;				if new then					intDLStuff^^.numdirs := intDLStuff^^.numDirs + 1;			end			else				ProblemRep('Aborted, directory names must be less than 27 characters.');		end;		DisposDialog(theDilg);	end;	procedure DoTransferSections;		var			Index, i: integer;			myPt, tempPt: Point;			ExitDialog: boolean;			DoubleClick: boolean;			CmdDown: boolean;			chCode: integer;			MyCmdKey: char;			tempDilg: dialogPtr;			tempLong: longInt;			theReply: SFReply;			tempCell: cell;	begin		ExitDialog := FALSE;		if (GetDSelection <> nil) then		begin			if (GetDSelection <> nil) and (GetDSelection = theWindow) then			begin				setPort(getDSelection);				myPt := theEvent.where;				GlobalToLocal(myPt);				GetDItem(GetDSelection, itemHit, DType, DItem, tempRect);				CItem := Pointer(DItem);				if (itemHit = 4) then				begin					DoubleClick := LClick(myPt, theEvent.modifiers, List_I_List1);					if doubleClick then					begin						tempCell.h := 0;						tempCell.v := 0;						if LGetSelect(true, tempCell, List_I_List1) then						begin							EditTransferSec(false, tempCell.v);							LDoDraw(false, List_I_list1);							LDelRow(0, 0, List_I_List1);							for i := 1 to intDLstuff^^.numDirs do							begin								AddListString(intDLstuff^^.dr[i - 1].dirName, list_I_list1);							end;							LdoDraw(TRUE, List_I_List1);							UpdateTransferSections(getDSelection);						end;					end;				end;				if (ItemHit = I_Cancel) then				begin					DoDLStuff(false);					ExitDialog := TRUE;				end;				if (ItemHit = I_New) then				begin					if intDLStuff^^.numDirs < 64 then					begin						EditTransferSec(true, intDLStuff^^.numDirs);						LDoDraw(false, List_I_list1);						LDelRow(0, 0, List_I_List1);						for i := 1 to intDLstuff^^.numDirs do						begin							AddListString(intDLstuff^^.dr[i - 1].dirName, list_I_list1);						end;						LdoDraw(TRUE, List_I_List1);						UpdateTransferSections(getDSelection);					end					else						SysBeep(10);				end;				if (ItemHit = I_Clear) then				begin					tempCell.h := 0;					tempCell.v := 0;					if LGetSelect(true, tempCell, List_I_List1) then					begin						LDelRow(1, tempCell.v, List_I_List1);						if (tempCell.v + 1) < (IntDLStuff^^.numDirs) then						begin							for i := (tempCell.v + 1) to (IntDLStuff^^.numDirs - 1) do							begin								intDLStuff^^.dr[i - 1] := intDLStuff^^.dr[i];							end;						end;						intDLStuff^^.numDirs := intDLStuff^^.numDirs - 1;					end					else						SysBeep(10);				end;			end;		end;		if ExitDialog then		begin			CloseTransferSections(GetDSelection);			GetDSelection := nil;		end;	end;	procedure SwitchError (er: str255);		var			tempDilg: dialogPtr;			a: integer;	begin		with curglobs^ do		begin			if BoardMode = terminal then			begin				tempDilg := GetNewDialog(1055, nil, pointer(-1));				ParamText(er, '', '', '');				DrawDialog(tempDilg);				SysBeep(10);				repeat					ModalDialog(nil, a);				until (a = 1);				DisposDialog(tempDilg);			end			else			begin				OutLine(er, true, 6);			end;		end;	end;	procedure RemoveIt;		var			i: integer;			mycurDirPos: integer;	begin		with curglobs^ do		begin			if curDirPos < curnumFiles then			begin				for i := 0 to ((curNumFiles - curDirPos) - 1) do				begin					curOpenDir^^[curDirPos + (i - 1)] := curOpenDir^^[curDirPos + i];				end;			end;			curNumFiles := curNumFiles - 1;			curDirPos := curDirPos - 1;			if curDirPos > curNumFiles then				curDirPos := curNumFiles;			SaveDirectory;		end;	end;	procedure RemoveFiles;		var			tempString: str255;			result: OSerr;			myUser: UserRec;	begin		with curglobs^ do		begin			case RFdo of				RFone: 				begin					descsearch := false;					bCR;					OutLine('Enter filename to remove.', true, 0);					bCR;					LettersPrompt(': ', '', intDLStuff^^.dr[inDir].fileNameLength, false, false, false, char(0));					ANSIPrompter(intDLStuff^^.dr[inDir].fileNameLength);					RFdo := RFtwo;				end;				RFTwo: 				begin					if length(curPrompt) > 0 then					begin						curDirPos := 0;						if OpenDirectory(inDir) then						begin							RFDo := RFThree;							tempInDir := inDir;							fileMask := curPrompt;						end						else						begin							OutLine('Memory problem opening directory.', true, 0);							GoHome;						end;					end					else						GoHome;				end;				RFThree: 				begin					GetNextFile(tempInDir, fileMask, curDirPos, curFil, 0);					if curFil.flName <> '' then					begin						if (thisUser.coSysop) or (EqualString(curFil.uploaderName, thisUser.userName, false, false)) then						begin							if PrintFileInfo(curFil, tempInDir, false) then								;							RFDo := RFFour;						end;					end					else						GoHome;				end;				RFFour: 				begin					bCR;					bCR;					LettersPrompt('Remove (Y/N/Q) : ', 'YNQ', 1, true, false, true, char(0));					RFDo := RFFive;				end;				RFFive: 				begin					if curPrompt = 'Y' then					begin						RemoveIt;						deleteExtDesc(curFil, inDir);						sysopLog(concat('      -', curFil.flName, ' Removed off of ', intDLstuff^^.dr[inDir].dirName), 0);						if (thisUser.coSysop) then							RFDo := RFSix						else						begin							if curFil.fileStat <> 'F' then								thisUser.uploadedK := thisUser.uploadedK - (curFil.byteLen div 1024);							if (pos(':', curFil.realFName) = 0) then								tempString := concat(intDLStuff^^.dr[inDir].path, curFil.realFName)							else								tempString := curFil.realFName;							result := FSDelete(tempString, 0);							OutLine('File removed.', true, 0);							bCR;							RFDo := RFThree;						end;					end					else if curprompt = 'N' then						RFdo := RFThree					else						GoHome;				end;				RFSix: 				begin					YesNoQuestion('Delete file too? ', false);					RFDo := RFSeven;				end;				RFSeven: 				begin					if curPrompt = 'Y' then					begin						if (pos(':', curFil.realFName) = 0) then							tempString := concat(intDLStuff^^.dr[inDir].path, curFil.realFName)						else							tempString := curFil.realFName;						result := FSDelete(tempString, 0);						YesNoQuestion('Remove UL points? ', false);						RFDo := RFEight;					end					else						RfDo := RFThree;				end;				RFEight: 				begin					if curprompt = 'Y' then					begin						if FindUser(curFil.uploaderName, myUser) then						begin							MyUser.numUploaded := myUser.numUploaded - 1;							MyUser.UploadedK := myUser.uploadedK - (curFil.byteLen div 1024);							if myUser.UserNum = thisUser.userNum then							begin								thisUser.numUploaded := thisUser.numUploaded - 1;								thisUser.UploadedK := thisUser.uploadedK - (curFil.byteLen div 1024);							end;							WriteUser(myUser);						end;					end;					RFDo := RFTHree;				end;				otherwise			end;		end;	end;	procedure EnterExtended;		var			ts, s1: str255;			tuba: longint;			myref: integer;			TEMPSTRING: STR255;	begin		with curglobs^ do		begin			case extenDo of				ex1: 				begin					if curprompt = 'Y' then					begin						bCR;						OutLine(retinstr(17, 43), true, 0);						OutLine(retinstr(17, 44), true, 0);						bCR;						excess := '';						if curWriting <> nil then							DisposHandle(handle(curWriting));						curWriting := nil;						curPrompt := '';						crossInt := 0;						extenDo := ex2;					end					else						GoHome;				end;				ex2: 				begin					if (length(curPrompt) > 0) or (crossint = 0) then					begin						if crossInt > 0 then						begin							if curWriting = nil then								curWriting := TextHand(NewHandle(0));							SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) + length(curPrompt) + 1);							BlockMove(@curPrompt[1], @curWriting^^[GetHandleSize(handle(curWriting)) - length(curPrompt) - 1], length(curPrompt));							CurWriting^^[getHandleSize(handle(curWriting)) - 1] := char(13);						end;						crossInt := crossInt + 1;						NumToString(crossInt, ts);						if crossint = 10 then						begin							ts := '';							OutLine('10', false, 0);						end;						if crossInt = 10 then						begin							LettersPrompt(concat(ts, ': '), '', 56, false, false, false, char(0));							ExtenDo := ex3;						end						else							LettersPrompt(concat(ts, ': '), '', 56, false, true, false, char(0));						if length(excess) > 0 then						begin							OutLine(excess, false, myPrompt.inputColor);							curPrompt := excess;							excess := '';						end;					end					else						extendo := ex3;				end;				ex3: 				begin					if curWriting <> nil then					begin						if length(curprompt) > 0 then						begin							SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) + length(curPrompt) + 1);							BlockMove(@curPrompt[1], @curWriting^^[GetHandleSize(handle(curWriting)) - length(curPrompt) - 1], length(curPrompt));							CurWriting^^[getHandleSize(handle(curWriting))] := char(13);						end;						LettersPrompt(retinstr(17, 45), 'YNQ', 1, true, false, true, char(0));						ExtenDo := Ex4;					end					else					begin						if renDo = reneight then						begin							BoardSection := renFiles;							curPrompt := 'N';						end						else							GOHOME;					end;				end;				Ex4: 				begin					if curPrompt = 'Y' then					begin						AddExtended(curFil, tempinDir);						curFil.hasExtended := true;						if renDo = reneight then						begin							BoardSection := renFiles;							curPrompt := 'N';						end						else							GOHOME;					end					else if curPrompt = 'N' then					begin						curprompt := 'Y';						ExtenDo := Ex1;					end					else					begin						if renDo = reneight then						begin							BoardSection := renFiles;							curPrompt := 'N';						end						else							GOHOME;					end;				end;				otherwise			end;		end;	end;	procedure PrintUserStuff;		var			tempString, tempString2: str255;			tempDate: DateTimeRec;			tempInt: integer;			myR: real;			f: DecForm;			s: DecStr;	begin		with curglobs^ do		begin			NumToString(thisUser.UserNum, tempString2);			bufferIt(concat(retinstr(17, 46), thisUser.UserName, ' #', tempString2), false, 0);			bufferIt(concat(retinstr(17, 47), thisUser.Phone), true, 0);			FindMyEmail;			tempInt := GetHandleSize(handle(myEmailList)) div 2;			if tempInt > 0 then			begin				NumToString(tempInt, tempString2);				bufferIt(concat(retinstr(17, 48), tempString2), true, 0);			end;			NumToString(thisUser.SecLevel, tempString2);			bufferIt(concat(retinstr(17, 49), tempString2), true, 0);			NumToString(thisUser.TransferLevel, tempString2);			bufferIt(concat(retinstr(17, 50), tempString2), true, 0);			IUDateString(thisUser.lastOn, abbrevDate, tempstring2);			bufferIt(concat(retinstr(17, 51), tempString2), true, 0);			IUDateString(thisUser.firstOn, abbrevDate, tempstring2);			bufferIt(concat(retinstr(17, 67), tempString2), true, 0);			NumToString(thisUser.totalLogons, tempString2);			bufferIt(concat(retinstr(17, 52), tempString2), true, 0);			NumToString(thisUser.OnToday, tempString2);			bufferIt(concat(retinstr(17, 53), tempString2), true, 0);			NumToString(thisUser.MessagesPosted, tempString2);			bufferIt(concat(retinstr(17, 54), tempString2), true, 0);			NumToString(thisUser.EMailSent, tempString2);			bufferIt(concat(retinstr(17, 55), tempString2), true, 0);			if thisUser.restrics[4] then			begin				myR := thisUser.messagesPosted / thisUser.totalLogons;				F.style := FixedDecimal;				F.digits := 2;				Num2Str(f, myR, s);				tempString := s;				bufferIt(concat(retinstr(17, 56), tempstring), true, 0);			end;			NumToString(thisUser.totaltimeOn, tempString);			bufferIt(concat(retinstr(17, 57), tempString, ' minutes.'), true, 0);			bufferbCR;			ReleaseBuffer;		end;	end;	function DLRatioOK: boolean;		var			myR, myR2: real;	begin		with curglobs^ do		begin			if not (thisUser.downloadedK = 0) then			begin				myR := thisUser.uploadedK / thisUser.downloadedK;				myr2 := 1 / intSystRec.secLevels[thisUser.secLevel].DLRatioOneTo;				if myR < myR2 then					DLRatioOK := false				else					DLRatioOK := true;			end			else			begin				if thisUser.uploadedK > 0 then					DLratioOK := true				else					DLratioOK := false;			end;			if not thisUser.restrics[3] then				DLRatioOK := true;		end;	end;	procedure printDirList;		var			tempstring: str255;			i: integer;			tb2: boolean;	begin		with curglobs^ do		begin			bufferIt(retinstr(17, 58), true, 0);			bufferbCR;			for i := 1 to intDLstuff^^.numDirs do			begin				tb2 := true;				if intDLStuff^^.dr[i - 1].restriction <> char(0) then					if thisUser.restrics[(byte(intDLStuff^^.dr[i - 1].restriction) - byte(64))] then						tb2 := true					else						tb2 := false;				if tb2 and (thisUser.transferLevel >= intDLstuff^^.dr[i - 1].minDSL) and (thisUser.age >= intDLStuff^^.dr[i - 1].minAge) then				begin					NumToString(i - 1, tempString);					if length(tempString) = 1 then						tempString := concat(tempString, '  - ', intDLstuff^^.dr[i - 1].dirName)					else						tempString := concat(tempString, ' - ', intDLstuff^^.dr[i - 1].dirName);					bufferIt(tempString, true, 0);				end;			end;			bufferbCR;			ReleaseBuffer;		end;	end;	procedure DoRename;		var			tempString, t2: str255;			tempInt, savedDirPos: integer;	begin		with curglobs^ do		begin			case RenDo of				renOne: 				begin					descSearch := false;					bCR;					LettersPrompt('File to rename: ', '', intDLStuff^^.dr[inDir].fileNameLength, false, false, false, char(0));					ANSIPrompter(intDLStuff^^.dr[inDir].fileNameLength);					RenDo := RenTwo;				end;				renTwo: 				begin					if length(curPrompt) > 0 then					begin						curDirPos := 0;						if OpenDirectory(inDir) then						begin							RenDo := RenThree;							tempInDir := inDir;							fileMask := curPrompt;						end						else						begin							OutLine(retinstr(17, 59), true, 0);							GoHome;						end;					end					else						GoHome;				end;				RenThree: 				begin					GetNextFile(tempInDir, fileMask, curDirPos, curFil, 0);					if curFil.flName <> '' then					begin						if PrintFileInfo(curFil, tempInDir, false) then							;						RenDo := RenFour;					end					else						GoHome;				end;				RenFour: 				begin					bCR;					bCR;					LettersPrompt('Change info for this file (Y/N/Q)? ', 'YNQ', 1, true, false, true, char(0));					RenDo := RenFive;				end;				RenFive: 				begin					if curPrompt = 'Y' then					begin						LettersPrompt('New filename? ', '', intDLStuff^^.dr[inDir].fileNameLength, false, false, false, char(0));						ANSIPrompter(intDLStuff^^.dr[inDir].fileNameLength);						RenDo := RenSix;					end					else if (curPrompt = 'Q') then						goHome					else						RenDo := RenThree;				end;				RenSix: 				begin					if length(curPrompt) > 0 then					begin						t2 := intDLStuff^^.dr[tempInDir].path;						if not FExist(concat(t2, curPrompt)) then						begin							savedDirPos := curDirPos;							ReadExtended(curFil, tempIndir);							DeleteExtDesc(curFil, tempInDir);							if (pos(':', curFil.realFName) = 0) then							begin								tempstring := concat(t2, curPrompt);								t2 := concat(t2, curFil.realFName);							end							else								t2 := curFil.realFName;							curFil.realFName := curprompt;							curFil.flName := curPrompt;							result := Rename(t2, 0, tempstring);							AddExtended(curFil, tempInDir);							curDirPos := savedDirPos;						end						else							OutLine('Filename already in use; not changed.', true, 0);					end;					OutLine('New description: ', true, 0);					bCR;					LettersPrompt(': ', '', 70 - intDLStuff^^.dr[inDir].fileNameLength, false, false, false, char(0));					ANSIPrompter(70 - intDLStuff^^.dr[inDir].fileNameLength);					RenDo := RenSeven;				end;				RenSeven: 				begin					if length(curPrompt) > 0 then					begin						curFil.flDesc := curprompt;					end;					bCR;					YesNoQuestion('Enter a new extended description? ', false);					RenDo := RenEight;				end;				RenEight: 				begin					if curPrompt = 'N' then						RenDo := RenThree					else					begin						DeleteExtDesc(curFil, inDir);						curFil.hasExtended := false;						BoardSection := Ext;						ExtenDo := Ex1;					end;					FileEntry(curFil, InDir, tempInt, curDirPos);				end;				otherwise			end;		end;	end;	procedure doMove;		var			tem: longint;			tempString, t2, t3: str255;			tempInt, TI2: integer;			result: oserr;	begin		with curglobs^ do		begin			case MoveDo of				MoveOne: 				begin					descSearch := false;					bCR;					LettersPrompt('Filename to move: ', '', intDLStuff^^.dr[inDir].fileNameLength, false, false, false, char(0));					ANSIPrompter(intDLStuff^^.dr[inDir].fileNameLength);					MoveDo := MoveTwo;				end;				MoveTwo: 				begin					if length(curPrompt) > 0 then					begin						curDirPos := 0;						if OpenDirectory(inDir) then						begin							MoveDo := MoveThree;							tempInDir := inDir;							fileMask := curPrompt;						end						else						begin							OutLine(retinstr(17, 59), true, 0);							GoHome;						end;					end					else						GoHome;				end;				MoveThree: 				begin					GetNextFile(tempInDir, fileMask, curDirPos, curFil, 0);					if curFil.flName <> '' then					begin						if PrintFileInfo(curFil, tempInDir, false) then							;						MoveDo := MoveFour;					end					else						GoHome;				end;				MoveFour: 				begin					bCR;					bCR;					LettersPrompt('Move this (Y/N/Q)? ', 'YNQ', 1, true, false, true, char(0));					MoveDo := MoveFive;				end;				MoveFive: 				begin					if curPrompt = 'Y' then					begin						NumbersPrompt('To which directory? ', '?', intDLStuff^^.numDirs + 1, 0);						MoveDo := MoveSix;					end					else if (curPrompt = 'Q') then						goHome					else						MoveDo := MoveThree;				end;				MoveSix: 				begin					if curprompt = '?' then					begin						PrintDirList;						CurPrompt := 'Y';						MoveDo := MoveFive;					end					else					begin						StringToNum(curprompt, tem);						if (intDLstuff^^.dr[tem].DSLtoUL <= thisuser.transferlevel) and (intDLstuff^^.numDirs > tem) then						begin							t2 := intDLStuff^^.dr[tempInDir].path;							tempString := intDLStuff^^.dr[tem].path;							if (FreeK(tempString) > (curFil.byteLen div 1024)) then							begin								ti2 := curdirpos;								tempint := pos(':', curFil.realFName);								if (tempint = 0) then									t2 := concat(t2, curFil.realFName)								else								begin									t2 := curFil.realFName; {does not delete path, bug}								end;								result := copy1File(t2, concat(tempString, curFil.realFname));								if (result = noErr) then									result := FSDelete(t2, 0);								RemoveIt;								readExtended(curFil, tempInDir);								deleteExtDesc(curFil, tempInDir);								AddExtended(curFil, tem);								FileEntry(curFil, tem, tempInt, 0);								if OpenDirectory(tempIndir) then									;								curDirPos := ti2 - 1;								OutLine('File moved.', true, 0);								bCR;								MoveDo := MoveThree;							end							else							begin								OutLine(retinstr(17, 64), true, 6);								GoHome;							end;						end						else						begin							OutLine('You cannot move to that directory.', true, 4);							GoHome;						end;					end;				end;				otherwise			end;		end;	end;	function secs2Time (howmanysecs: longint): str255;		var			l1, l2, l3, l4: longInt;			tempString, t3: str255;	begin		l1 := howManysecs;		l2 := l1 div 60;         {minutes       }		l1 := l1 - (l2 * 60);   {seconds       }		l3 := l2 div 60;         {hours           }		l4 := l2 - (l3 * 60);   {new minutes}		NumToString(l3, tempString);		if length(tempString) = 1 then			tempString := concat('0', tempString);		NumToString(l4, t3);		if length(t3) = 1 then			t3 := concat('0', t3);		tempString := concat(tempString, ':', t3, ':');		NumToString(l1, t3);		if length(t3) = 1 then			t3 := concat('0', t3);		secs2Time := concat(tempString, t3);	end;	function PrintFileInfo (theFl: filEntryRec; fromDir: integer; doOther: boolean): boolean;		var			tempString, t2, t3, t4, t5: str255;			l1, fileKLen: longInt;			myDate: DateTimeRec;			i: integer;	begin		with curglobs^ do		begin			PrintFileInfo := true;			if fromDir <> inDir then				bufferIt(concat('Directory  : ', intDLstuff^^.dr[fromDir].dirName, ''), true, 0);			if (currentBaud <> 0) and (nodeType = 1) then				l1 := theFl.bytelen div (modemDrivers^^[modemID].rs[rsIndex].effRate div 10)			else				l1 := 0;			tempString := Secs2Time(l1);			fileKlen := theFl.byteLen div 1024;			if theFl.byteLen = -1 then				t2 := 'ASK'			else			begin				NumToString(fileKlen, t2);				t2 := concat(t2, 'k');			end;			IUDateString(theFl.whenUL, shortDate, t4);			if (theFl.lastDL <> 0) and not thisUser.restrics[10] then				IUDateString(theFl.lastDL, shortDate, t5)			else				t5 := 'N/A';			if curFil.fileStat = 'F' then				bufferIt('*** Upload Fragment ***', true, 0);			bufferIt(concat('Filename   : ', theFl.flName), true, 0);			bufferIt(concat('Description: ', theFl.flDesc), true, 0);			bufferIt(concat('File size  : ', t2), true, 0);			bufferIt(concat('Apprx. Time: ', tempString), true, 0);			bufferIt(concat('Uploaded on: ', t4), true, 0);			NumToString(theFl.uploaderNum, t2);			if not thisUser.restrics[10] then				t2 := concat(thefl.uploaderName, ' #', t2)			else				t2 := 'N/A';			bufferIt(concat('Uploaded by: ', t2), true, 0);			if not thisUser.restrics[10] then				NumToString(theFl.numDloads, t2)			else				t2 := 'N/A';			bufferIt(concat('Times D/L''d: ', t2), true, 0);			bufferIt(concat('Last D/L   : ', t5), true, 0);			if theFl.hasExtended then			begin				ReadExtended(theFl, fromDir);				if curWriting <> nil then				begin					bufferbCR;					bufferIt('Extended Description:', true, 1);					bufferbCR;					PrintExtended(false);				end;			end;			ReleaseBuffer;			tempString := intDLstuff^^.dr[fromDir].path;			if doOther then			begin				if (pos(':', theFl.realFName) = 0) then					t2 := concat(tempString, theFl.realFname)				else					t2 := curFil.realFName;				if not FExist(t2) then				begin					bCR;					OutLine('->FILE NOT THERE<-', true, 0);					bCR;					PrintFileInfo := false;				end				else if ((l1) > (ticksLeft(activeNode) div 60)) then				begin					bCR;					OutLine('Not enough time left to D/L.', true, 0);					bCR;					PrintFileInfo := false;				end;			end;		end;	end;end.