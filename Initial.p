unit Initial;interface	uses		Serial, Sound, Types, AppleTalk, ADSP, CommResources, CRMSerialDevices, CTBUtilities, GestaltEqu;	const		HERMES_VERSION = '2.2';		ACTIVEEXT = 1;{values for message field to user external}		IDLE = 2;		CLOSENODE = 3;		CLOSEEXTERNAL = 4;		BUILDTMENU = 99;		BUILDMENU = 100;		ABLEMENU = 101;		DOMENU = 102;		DISPOSEPREC = 103;		DISPOSETMENU = 104;		CANSEND = 7;		CANRECEIVE = 6;		CANBSEND = 5;		CANBRECEIVE = 4;		SENDFLOW = 3;		RECEIVEFLOW = 2;		CONTINUERECEIVE = 1;		SETTERMPREF = 0;		SETBBSPREF = 15;		USINGADSP = 8;		TRANSMODE = 7;		STOPTRANS = 6;		CARRIERLOSS = 5;		USEMACBINARY = 4;		NEWMBNAME = 3;		NEWERROR = 2;		NEWFILE = 1;		RECOVERING = 0;		UPLOADCALL = 1;		DOWNLOADCALL = 0;		TABBYTOID = -100;		ADSPNAME = 'AppleTalk';		ADSPSENDBUFSIZE = 4096;		ADSPRECBUFSIZE = 2048;		SENDNOWBUFSIZE = 3072;		SOHchar = 1;		EOTchar = 4;		STXchar = 2;		CANchar = 24;		ESCchar = 27;		NAKchar = 21;		ACKchar = 6;		kOSEvent = app4Evt;                    {event used by MultiFinder				     }		kSuspendResumeMessage = 1;		{high byte of suspend/resume event message   }		kResumeMask = 1;		               {bit of message field for resume vs. suspend }		kNoEvents = 0;		                    {no events mask								 }		mApple = 1001;					     {Apple menu									 }		iAbout = 1;		mFile = 1002;				        {File menu									 }		iQuit = 3;		mTerminal = 1004;		mLog = 70;		mEdit = 1003;				        {Edit menu									 }		iUndo = 1;		iCut = 3;		iCopy = 4;		iPaste = 5;		iClear = 6;		mUser = 1005;		mSysop = 1006;		mConfigure = 1007;		mView = 1008;		mDisconnects = 57;		fFeed = 12;		lFeed = 10;		kSFSaveDisk = $214;		{ Negative of current volume refnum [WORD]	}		kCurDirStore = $398;		{ DirID of current directory [LONG]	   			}		kMaxDocWidth = 480;		kDITop = $0050;		kDILeft = $0070;		HiliteMode = $938;      { used for color highlighting}		philitebit = 0;		SPConfig = $1FB;        { config bits: 4-7 A, 0-3 B (see use type below)}		SPPortA = $1FC;         { SCC port A configuration [word]}		SPPortB = $1FE;         { SCC port B configuration [word]}		SCCRd = $1D8;           { SCC base read address [pointer]}		SCCWr = $1DC;           { SCC base write address [pointer]}		aCtl = 2;		bCtl = 0;		aData = 6;		bData = 4;	type		IntPtrType = ^integer;		LongPtrType = ^longint;		Str255PtrType = ^Str255;		PopupHand = ^PopupPtr;		PopupPtr = ^PopupPrivateData;		popupPrivateData = record				mHandle: Menuhandle;				mID: integer;				mPrivate: array[0..0] of SignedByte;			end;		myPopContHand = ^myPopContPtr;		myPopContPtr = ^myPopControl;		myPopControl = packed record				nextControl: controlHandle;				contrlOwner: windowPtr;				ContrlRect: rect;				contrlVis: byte;				contrlHilite: byte;				contrlValue: integer;				contrlMin: integer;				contrlMax: integer;				contrlDefProc: handle;				contrlData: popupHand;				contrlAction: ProcPtr;				contrlRfCon: longint;				contrlTitle: str255;			end;		FidoAddress = record				name: string[81];				atNode: string[15];			end;		TabbyHeader = record				Flags: packed array[1..4] of char;{with trailing return}				Category: packed array[1..4] of char;{with trailing return}				DateMade: packed array[1..9] of char;  {with trailing return}				TimeMade: packed array[1..9] of char;  {with trailing return}			end;		BBSListEntry = record				number: packed array[0..11] of char;				theRest: packed array[0..67] of char;			end;		BBSListDynamic = packed array[0..90000] of BBSListEntry;		BBSListPtr = ^BBSListDynamic;		pLaunchStruct = ^LaunchStruct;		LaunchStruct = record				pfName: StringPtr;				param: INTEGER;				LC: packed array[0..1] of CHAR;	{	extended parameters:								}				extBlockLen: LONGINT; 					{	number of bytes in extension = 6					}				fFlags: INTEGER;							{	Finder file info flags								}				launchFlags: LONGINT; 					{	bit 31,30=1 for sublaunch, others reserved	}			end; 											{	LaunchStruct											}		PathsFilesRec = record				fName: StringHandle;				mbName: stringHandle;				myvRef: integer;				myDirID: longint;				myFileID: longint;			end;		XFERStuffHand = ^XFERStufPtr;		XFERStufPtr = ^XFERStuff;		XFERstuff = packed record				modemInput: integer;{adsp driver ref for ADSP}				modemOutput: integer;{CCB ref for ADSP}				procID: integer;				protocolData: handle;				errorReason: stringHandle;				timeOut: integer;				fileCount: integer;				filesDone: integer;				curBytesDone: longint;				curBytesTotal: longint;				curStartTime: longint;				flags: packed array[0..15] of boolean;				fPaths: packed array[1..1] of pathsFilesRec;			end;		myTRCCB = record				myA5: LongInt;				u: TRCCB			end;		CarDetType = (CTS5, DCDchip, DCDdriver);		NodeHand = ^NodePtr;		NodePtr = ^NodeRec;		NodeRec = record				BaudMax: integer;  {max baud supported                      }				BaudMin: integer;   {minimum baud for valid connection}				MyInPort: str255;				myOutPort: str255;				ModDrivName: str255;  {STR# resource name for modem driver strings}				LocalHook: boolean;   {true means go off hook in local, false means leave line open}				MatchSpeed: boolean;				UpTime: longint;				DownTime: longint;				DTRHangup: boolean;				timeoutIn: integer;				HardShake: boolean;				BufferLines: integer;				CarDet: CarDetType;				AllowCrashmail: boolean;			end;		ExtDescRec = record				fName: string[20];				DescLeng: integer;			end;		SubBoardRec = record				Name: string[41];				SLtoRead: integer;				SLtoPost: integer;				MaxMessages: integer;				AnonID: byte;   {0=never, 1=force, -1=allow}				MinAge: integer;				SubType: integer;				StoreType: boolean;{true is one file, false multiple}				restrict: char;				Threading: boolean;				EchoConf: boolean;				Excess: packed array[1..7] of char;			end;		MDescHand = ^MDescPtr;		MDescPtr = ^MDescRec;		MDescRec = record				numForums: integer;				Forums: array[1..10] of string[41];				numBoards: array[1..10] of integer;				Boards: array[1..10, 1..30] of SubBoardRec;			end;		MesgRec = record				Title: string[80];				fromUserNum: integer;				fromUserName: string[40];				toUserNum: integer;				toUserName: string[40];				AnonyFrom: boolean; {for now, 0=no anony and 1=anony}				AnonyTo: boolean;				Deletable: boolean;				QScnPtr: longint;				daten: longint;				storedAs: longint;				StorageType: boolean;   {true is one file, false is lots of files}				reserved: packed array[0..9] of char;			end;		SubDynamicRec = array[0..90000] of MesgRec;		SubDyPtr = ^SubDynamicRec;		SubDyHand = ^SubDyPtr;		emailrec = record				title: string[80];				FromUser: integer;				ToUser: integer;				AnonyFrom: boolean;				AnonyTo: boolean;				DateSent: longint;				StoredAs: longint;				MType: byte;  {1=normal, 0=he read message}				multiMail: boolean;				reserved: packed array[0..9] of char;			end;		MesgHand = ^MesgPtr;		MesgPtr = ^EMDynamicRec;		EMDynamicRec = array[0..100000] of EMailRec;		SecLevRec = record				UseDayorCall: boolean;   {minutes per day is true, min/call is false}				ReadAnon: boolean;				TimeAllowed: integer;				MesgDay: integer;				DLRatioOneTo: integer;				PostRatioOneTo: integer;				CallsPrDay: integer;				LnsMessage: integer;			end;		SystHand = ^SystPtr;		SystPtr = ^SystRec;		SystRec = record				OverridePass: string[9];				NewUserPass: string[9];				NumCalls: longint;				NumUsers: integer;				OpStartHour: longint;				OpEndHour: longint;				Closed: boolean;				NewFrmAccess: packed array[1..10] of boolean;				numNodes: integer;				NewSL: integer;				NewDSL: integer;				LastMaint: DateTimeRec;				AnonyUser: integer;				AnonyAuto: boolean;				SerialNumber: string[40];				SecLevels: array[1..255] of SecLevRec;				MsgsPath: str255;				MustRead: boolean;				callsToday: integer;				mPostedToday: integer;				eMailToday: integer;				uploadsToday: integer;				minsToday: integer;				MessComp: real;				XferComp: real;				qScanPointer: longint;				TwoWayChat: boolean;				UseXWind: boolean;				ninePoint: boolean;				AllowHandles: boolean;				FreePhone: boolean;				ClosedTransfers: boolean;				protocolTime: integer;				defaFore: integer;  {mapped to old style quickdraw 8-colors}				defaBack: integer;  {same as above}				twoColorChat: boolean;				tabbyNet: boolean;				subLaunchTabby: boolean;				newStrics: packed array[1..26] of boolean;				logDays: byte;				realSerial: string[80];				startDate: longint;				screenSaver: packed array[0..1] of byte;				Reserved: integer;			end;		TUserHand = ^TUserPtr;		TUserPtr = ^TypicalUser;		TypicalUser = record				ClassName: string[40];				SL: integer;				DSL: integer;				Restrics: packed array[1..26] of boolean;				ForumAccess: packed array[1..30] of boolean;				password: string[13];			end;		filEntryRec = record				flName: string[20];            {list file name}				realFName: str255;       		{real file path if colon in name, otherwise just actual file name in directory}				flDesc: string[59];             {file description}				whenUL: longInt;                   {exact time uploaded in Mac date format from Jan 1, 1904}				uploaderName: string[41];  {user name of uploader}				uploaderNum: integer;          {user number of uploader}				numDLoads: integer;             {how many times this has been dl'd}				byteLen: longInt;                  {length of file in bytes}				hasExtended: boolean;          {boolean}				fileStat: char;				lastDL: longint;				reserved: packed array[1..4] of char;   {set to nulls for now}			end;		aDirHand = ^aDirPtr;		aDirPtr = ^aDirFile;		aDirFile = array[0..90000] of filentryrec;		batFileRec = record				theFile: filEntryRec;				fromDir: integer;                                    {transfer directory for file}			end;		FLSHand = ^FLSPtr;		FLSPtr = ^FLSRec;		FLSRec = record				numFiles: integer;                                  {max batch is 50 arbitrarily}				sendingBatch: boolean;							 {true if this is a batch DL, otherwise not}				batchTime: longint;                                {used internally, approximation of transfer time(seconds)}				batchKBytes: longint;                             {used internally}				filesGoing: array[1..50] of BatFileRec;			end;		InternalTransfer = record				active: boolean;				Sending: boolean;				starttime: longint;			end;		TextHand = ^TextPtr;		TextPtr = ^TextRec;		TextRec = packed array[0..92000] of char;		DirInfoRec = record				DirName: string[41];				Path: str255;				MinDSL: byte;				DSLtoUL: byte;				DSLtoDL: byte;				MaxFiles: integer;				Restriction: char;				NonMacFiles: integer;   {0=allow macBinary, 1= never MacBinary}				mode: byte;   {  -1 = Never New, 0=Normal , 1= Always New  }				MinAge: byte;				FileNameLength: byte;				freeDir: boolean;				reserved: packed array[0..9] of char;			end;		DirDataHand = ^dirDataPtr;		dirDataPtr = ^dirDataFile;		DirDataFile = record				numDirs: byte;				Dr: array[0..63] of DirInfoRec;			end;		ULR = record				Uname: string[31];				Dltd: boolean;				last: longint;				first: longint;				SL: integer;				DSL: integer;				real: string[21];			end;		UListHand = ^UListPtr;		UListPtr = ^UListRec;		UListRec = array[0..32000] of ULR;		UserHand = ^UserPtr;		UserPtr = ^UserRec;		UserRec = record				UserNum: integer;				UserName: string[31];				RealName: string[21];				Phone: string[12];				Password: string[9];				lastOn: longInt;				firstOn: longInt;				SysopNote: string[41];				sex: boolean; {male is 1, female is 0}				age: byte;				Deleting: boolean;				unused36732: byte;				DefaultProtocol: byte;				SecLevel: Integer;				TransferLevel: integer;				MsgFrmAccess: packed array[1..10] of boolean;				Restrics: packed array[1..26] of boolean;				Mailbox: boolean;  {false is normal, true is forwarded}				ForwardedTo: integer;				onToday: integer;				MinOnToday: integer;				MessagesPosted: integer;				MPostedToday: integer;				EMailSent: integer;				EMsentToday: integer;				NumUploaded: integer;				NumDownloaded: integer;				UploadedK: longint;				DownloadedK: longint;				LastBaud: integer;				LastVoted: longint;				ScrnWdth: integer;				ScrnHght: integer;				CanANSI: boolean;				ANSIColor: boolean;				Foregrounds: packed array[0..8] of byte;				Backgrounds: packed array[0..8] of byte;				Bolds: packed array[0..8] of boolean;				Underlines: packed array[0..8] of boolean;				PauseScreen: boolean;				TotalLogons: integer;				totalTimeOn: longint;				illegalLogons: integer;				WhatNScan: packed array[1..10, 1..30] of boolean;				LastMsgs: array[1..10, 1..30] of longint;				Expert: boolean;				BirthDay: char;				BirthMonth: char;				BirthYear: char;				lastFileScan: longInt;				NTransAfterMess: boolean;				votes: packed array[1..19] of byte;				ExtendedLines: byte;				screenClears: boolean;				coSysop: boolean;				alertOn: boolean;				notifyLogon: boolean;				lastPWChange: longint;				computerType: string[23];				reserved: packed array[0..18] of char;			end;		BDact = (ListText, Prompt, None, Chat, Writing, Repeating);		aLine = packed array[0..79] of char;		MessgHand = ^MessgPtr;		MessgPtr = ^HermesMesg;		HermesMesg = array[1..300] of string[161];		ScrnKeysPtr = ^ScrnKeys;		ScrnKeys = array[0..1000] of aLine;		PtrToLong = ^longint;		PtrToWord = ^integer;		indxHand = ^indxPtr;		indxPtr = ^indxRec;		indxRec = array[0..2047] of integer;		flagType = packed array[0..15] of boolean;		resultCode = record				num: integer;				portRate: longint;				effRate: longint;				desc: string[19];			end;		modemDriverHand = ^modemDriverPtr;		modemDriverPtr = ^modemDriver;		modemDriver = record				name: string[19];				bbsInit: string[79];				termInit: string[79];				hwOn: string[21];				hwOff: string[21];				lockOn: string[21];				lockOff: string[21];				ansModem: string[9];				numResults: integer;				rs: array[0..49] of resultCode;			end;		MoDrListHand = ^MoDrListPtr;		MoDrListPtr = ^MoDrList;		MoDrList = array[0..0] of modemDriver;		ProcSubPtr = ^protocolo;		protocolo = packed record				pFlags: FlagType;				refCon: longint;				protoName: Str255;				autoCom: Str255;				protHand: handle;				ProtMode: integer;				resID: integer;			end;		ProtocolsHand = ^ProtocolsPtr;		ProtocolsPtr = ^ProtocolsRec;		ProtocolsRec = record				numProtocols: integer;				Prots: array[1..10] of protocolo;			end;		ProcList = record				procID: integer;				itemID: integer;				HMenuID: integer;				HItemID: integer;				subName: stringHandle;				pFlags: integer;				funcMask: integer;				refCon: longint;			end;		ProcMenuHandle = ^ProcMenuPtr;		ProcMenuPtr = ^ProcMenu;		ProcMenu = record				mode: integer;				pMenu: MenuHandle;				Updater: ProcPtr;				transIndex: integer;				transMessage: integer;				transRefCon: longint;				Proto: XFERStuffHand;				pCount: integer;				firstID: integer;				foldID: integer;				autoCount: integer;				autoComs: handle;				theProcList: array[0..5] of ProcList;			end;		eInfoHand = ^eInfoPtr;		eInfoPtr = ^eInfoRec;		eInfoRec = record				allTime: boolean;				minSLforMenu: integer;				Restriction: char;			end;		HermesPrompt = record				promptLine: string[80];   {actual prompt text line}				allowedChars: string[100]; {all other characters ignored, set to zero for full acceptance of everything}				replaceChar: char;             {replace all input with this character for output, i.e. Password entry, set null for nothing}				Capitalize: boolean;            {capitalize all incoming characters}				enforceNumeric: boolean; {are numbers accepted?  overrides allowedChars string}				autoAccept: boolean;    {automatically accept on numeric/character input deemed complete}				wrapAround: boolean;   {at end of prompt, wrap text to next line using excess string in defs}				wrapsonCR: boolean;				breakChar: char;          {this key will override autoAccept and go to the next input}				HermesColor: integer;  {on Hermes ANSI from 0-7...sets color on output, -1 is no ANSI}				InputColor: integer;    {same as above except for user input}				numericLow: integer;   {if enforceNumeric, low range}				numericHigh: integer;   {if enforceNumeric, high range}				maxChars: integer;   {maximum accepted number of characters}				KeyString1: string[10];   {on key input, character 1 of this being received will output rest of string}				KeyString2: string[10];   {see above}				KeyString3: string[10];			end;		intListHand = ^intListPtr;		intListPtr = ^intListArr;		intListArr = array[0..0] of integer;		HermUserGlobHand = ^HermUserGlobPtr;		HermUserGlobPtr = ^HermUserGlobs;		HermUserGlobs = record				rawBuffer: packed array[0..4096] of char; { used by the DRIVER -  DON'T touch it }				incoming: packed array[0..4096] of char;   {don't touch this either}				myPrompt: HermesPrompt;				toBeSent, protCodeHand: Handle;				sendingNow: ptr;				sysopLogOn, Prompting, stopRemote, retob, inTransfer, inHalfDuplex, readMsgs, continuous, inZScan, inNScan, fromQScan, endQScan, newFeed, timeFlagged, Single, DoCheckMessage, InPause, allDirSearch, aborted, in8BitTerm, ANSIterm: boolean;				callFMail, chatKeySysop, sentAnon, batchTrans, wrapPrompt, promptHide, sysopStop, triedChat, threadmode, reply, validLogon: boolean;				gettingANSI, HWHH, dirUpload, goOffinLocal, shutDownSoon, wasMadeTempSysop, negateBCR, tabbyPaused: boolean;				inScroll, countingDown, netMail, blinkOn, useDTR, capturing, amSpying, unused2372, doCrashmail: boolean;				matchInterface, unused376, replyToAnon, descSearch, goBackToLogon, ListedOneFile, returnafterprompt, afterHangup, listingHelp: boolean;				curWriting: TextHand;				sysopKeyBuffer: charsHandle;				curExtDesc: extDescRec;				optBuffer: CharsHandle;				fileTransit: FLSHand;				myBlocker: paramBlockRec;				replyStr, unused733, unused734, unused735, ansInProgress, curPrompt, mDriverName, enteredPass: str255;				curBaudNote, unused832, enteredPass2, typeBuffer, autoMess, doingPrompt, fileMask, excess: str255;				inportName, outportname, replyToStr, lastTransError, SavedInPort, lastBotLine: str255;				q, openTextSize, lastKeyPressed, startedChat, lastTry, lastFTUpdate: longint;				currentBaud, lastLastPressed, lastCurBytes, crossLong, curTextPos, subtractOn: longInt;				lastBlink, TimeBegin, ExtraTime, Uptime, Downtime, lastLeft, timeout, startCPS: longint;				nodeType, headMessage, lnsPause, inputRef, outputRef, frontCharElim, openTextRef, MaxPromptChars, atEMail, EndAnony, totalEMails, onBatchNumber: integer;				TextHnd: TextHand;				bUploadCompense: longint;				nodeDSPPBPtr: DSPPBPtr;				nodeCCBPtr: TPCCB;				nodeMPPPtr: MPPPBPtr;				nodeSendCCBPtr, nodeRecCCBPtr, nodeAttnCCBPtr, unused3773: Ptr;				modemID, maxBaud, minBaud, inMessage, mesRead, maxLines, onLine, savedLine, configForum, inForum, inSub, numRptPrompt, realSL, inDir, tempDir, flsListed, fListedCurDir, curDirPos, tempInDir, crossInt, crossInt2, crossInt3, dirOpenNum, curNumFiles, xFerAutoStart, hangingUp, nodeCCBRefNum, useWorkspace, saveInForum, saveInSub, helpNum: integer;				captureRef, curNumMess, activeProtocol, lastBatch: integer;				thisUser, tempUser, MailingUser: UserRec;				padding980: packed array[0..103] of char;				CarrierDetect: CarDetType;				unused48: style;				curmessage: MessgHand;				lastFScan: longInt;				myEmailList: intListHand;				padding981: packed array[0..103] of char;				extTrans: XFERstuffHand;				myTrans: internalTransfer;				curBase: subDyHand;				TransDilg: dialogPtr;				padding373: packed array[0..181] of char;				curOpenDir: aDirHand;				blinkRgn: rgnhandle;				curIndex: indxHand;				myFido: FidoAddress;				multiUsers: array[1..20] of integer;				numMultiUsers, spying: integer;				bufLns: integer;				rsIndex, replyToNum: integer;				myProcMenu: ProcMenuHandle;				activeUserExternal: integer;   {if >0 then external will be called}				BoardMode: (Waiting, Terminal, User, Answering, Failed);				BoardSection: (Logon, NewUser, MainMenu, rmv, MoveFiles, killMail, AutoVal, Batch, MultiChat, tranDef, MultiMail, Noder, messUp, renFiles, readAll, RmvFiles, GFiles, UEdit, USList, BBSlist, chUser, limdate, Download, Sort, Upload, OffStage, ListFiles, post, ChatStage, Defaults, Email, QScan, ReadMail, Amsg, Transfers, Ext, EXTERNAL, ScanNew);				boardAction, savedBDaction, savedBD2: BDact;				ValDo: (Val1, Val2);				AutoDo: (AutoOne, AutoTwo, AutoThree, AutoFour, AutoFive, AutoSix, AutoSeven);				ReadDo: (ReadOne, ReadTwo, ReadThree, ReadFour, ReadFive, ReadSix, ReadSeven, ReadEight, JumpForum);				EmailDo: (WhichUser, EmailOne, EmailTwo, EmailThree, EmailFour, EmailFive);				MultiDo: (MultiOne, MultiTwo, MultiThree, MultiFour);				MultiChatDo: (Mult1, Mult2);				BatDo: (BatOne, BatTwo, BatThree, BatFour, BatFive, BatSix, BatSeven);				KillDo: (KillOne, KillTwo, KillThree, KillFour, KillFive);				TransDo: (TrOne, TrTwo, TrThree, TrFour);				bbsLdo: (Bone, BTwo, BThree, BFour, BFive, bSix, bSeven);				upMess: (MessUpOne, MessUpTwo, MessUpThree);				AllDo: (AllOne, AllTwo, AllThree);				GFileDo: (G1, G2, G3, G4, G5, G6);				ExtenDo: (ex1, ex2, ex3, EX4);				DownDo: (DownOne, DownTwo, DownThree, DownFour, DownFive);				RenDo: (RenOne, RenTwo, RenThree, RenFour, RenFive, RenSix, RenSeven, RenEight);				SortDo: (SortOne, SortTwo, SortThree);				RFDo: (RFOne, RFTwo, RFThree, RFFour, RFFive, RFSix, RFSeven, RFEight);				ChatDo: (ChatOne, ChatTwo, ChatThree);				NodeDo: (NodeOne, NodeTwo, NodeThree, NodeFour, NodeFive, NodeSix, NodeSeven);				PostDo: (PostOne, PostTwo, PostThree, PostFour, PostFive);				UploadDo: (UpOne, UpTwo, UpThree, UpFour, UpFive, UpSix, UpSeven, UpEight);				ListDo: (ListOne, ListTwo, ListThree, ListFour, ListFive, ListSix, ListSeven);				QDo: (Qone, QTwo, QThree, QFour, QFive, QSix, QMove, QMove2);				UEdo: (EnterUE, UOne, UTwo, UThree, UFour, UFive, USix, USeven, UEight, UNine, UTen, UEleven, UTwelve, U13, U14, U15, U16, U17, U18, U19, U20);				rmvDo: (RmvOne, RmvTwo);				DefaultDo: (DefaultOne, DefaultTwo, DefaultThree, DefaultFour, DefaultFive, DefaultSix, DefaultSeven, DefaultEight, DefaultNine, DefaultTen, DefaultEleven, DefaultTwelve, DefaultThrt, def14, def15, def16, def17, D18, D19, D20, D21, D22, D24, D23, D25);				MainStage: (MenuText, MainPrompt, TextForce);				NewUserStage: (NoNewText, NewUserPass, CheckNewPass, PromptHandle, CheckTrash, RealName, NewPhone, Sex, BirtMonth, BirtDay, BirtYear, ComputerType, ScrnWd, ScrnHg, TestANSI, checkColor, IsAllCorrect, PassQuest, NewPassword, GiveInfo, ConfirmPass, NewTransition, TwoTrans);				LogonStage: (Welcome, Name, CheckName, Password, Phone, SysPass, ChkSysPass, CheckStuff, Hello, Stats, StatAuto, Transition, Trans1, Trans2, Trans3);				OffDo: (SureQuest, OffText, Hanger);				MoveDo: (moveOne, MoveTwo, MoveThree, MoveFour, MoveFive, MoveSix);				ExternalDo: (external1, external2, theExternal);				ScanNewDo: (Scan1, Scan2, Scan3, Scan4, Scan5);				curEMailRec: EMailRec;				curMesgRec: MesgRec;				fromMsgScan, dialing, waitDialResponse, alerted: boolean;				dialDelay: longint;				mySystNode: SystPtr;				curFil: FilEntryRec;				nodeDSPWritePtr: DSPPBPtr;			end;		FullUNamesRec = record				n: string[31];				lo: longint;				del: boolean;			end;		FullUNames = array[1..2000] of FullUNamesRec;		FullUPtr = ^FullUNames;		FullNameHand = ^FullUPtr;		HermesExDef = record				name: string[41];				SysopExternal: boolean;				UserExternal: boolean;				IconHandle: handle;				allTheTime: boolean;				minSLforMenu: integer;				RestrictionMenu: char;				privatesNum: longint;				codeHandle: handle;				UResoFile: integer;			end;		ExternalList = array[1..20] of HermesExDef;		ExternListPtr = ^ExternalList;		ExternListHand = ^ExternListPtr;		GFileSec = record				SecName: string[50];				minSL: integer;				minAge: integer;				reserved: packed array[1..15] of char;			end;		GFileSecHand = ^GFileSecPtr;		GFileSecPtr = ^GFileSecRec;		GFileSecRec = record				numSecs: integer;				Sections: array[1..30] of GfileSec;			end;		HermDataPtr = ^HermDataRec;		HermDataRec = record				HSystPtr: SystPtr;				HMDescPtr: MDescPtr;				HDirDataPtr: dirDataPtr;				HGFilePtr: GFileSecPtr;				SharedPath: StringPtr;				reserved1: longint;				reserved2: longint;			end;		UserXIPtr = ^UserXInfoRec;		UserXInfoRec = record				privates: Handle;				extID: integer;				totalNodes: integer;				message: integer;				curNode: PtrToWord;				curUGlobs: PtrToLong;				ResShared: integer;				DataShared: integer;				HSystPtr: SystPtr;				HMDescPtr: MDescPtr;				HDirDataPtr: dirDataPtr;				HGFilePtr: GFileSecPtr;				filesPath: StringPtr;				HermUsers: UListHand;				systemMail: MesgHand;				extantEmails: PtrToWord;				emailUnclean: PtrToWord;				numExternal: integer;				externals: ExternListHand;				reserved: packed array[0..249] of char;				n: array[1..10] of HermUserGlobPtr;				procs: array[0..0] of ProcPtr;			end;		OpenExternal = record				number: integer;				numAddedItems: integer;				resourceFile: integer;				codehandle: handle;				exRefCon: longint;				numext: integer;			end;		charStyle = packed record				fcol: 0..7;				bcol: 0..7;				bold: boolean;				underLine: boolean;			end;		charStylePtr = ^charStyle;		myANSIwindow = record				ansiPort: windowPtr;				ansiVScroll: ControlHandle;				ansiRect, cursorRect, savedWPos: rect;				Cursor, anchor, elastic: point;				topLine: integer;				screen: packed array[0..23, 0..79] of char;				screenInfo: packed array[0..23, 0..79] of CharStyle;				curStyle, bufStyle: CharStyle;				bigBuffer: scrnKeysPtr;				sTopLine, sNumlines: integer;				ansiState, scrnTop, scrnBottom, scrnLines: integer;				ansiEnable, cursorOn, scrollFreeze, selectActive: boolean;				numAnsiParams, curParam, saveV, saveH: integer;				ansiParams: array[0..79] of byte;			end;		MyANSIWindPtr = ^myANSIwindow;		myTWindRec = record				w: windowPtr;				s: ControlHandle;				t: TEHandle;				docClik: ProcPtr;				wasResource: boolean;				editable: boolean;				origpath: str255;				dirty: boolean;			end;		WStateHand = ^WStatePtr;		WStatePtr = ^WStateData;		windowSaves = record				WnodesStd: array[1..10] of rect;				WNodesUser: array[1..10] of rect;				Wstatus: rect;				wIsOpen: array[0..10] of boolean;			end;		windSavesPtr = ^windowSaves;		windSavesHand = ^windSavesPtr;		DialerHand = ^DialerPtr;		DialerPtr = ^DialerRec;		DialerRec = record				numbers: array[0..9] of string[40];				dialIt: packed array[0..9] of boolean;				dialed: packed array[0..9] of boolean;			end;		startInfoHand = ^startInfoPtr;		startInfoPtr = ^startInfoRec;		startInfoRec = record				sharedPath: str255;				myNewCksm, myH4cksm, myusercksm: longint;			end;	var		myTE: TEHandle;		held: array[1..10] of boolean;		sysopOpenDir: aDirHand;		myOpenEx: OpenExternal;		myExternals: ExternListHand;		theDials: DialerHand;		textWinds: array[0..9] of myTWindRec;		theExtRec: UserXIPtr;		numTextWinds, myResourceFile, numExternals, sysopNumFiles, sysopDirNum, RShared, DShared: integer;		cursorRgn: rgnhandle;		ssWind, statWindow: WindowPtr;		theProts: ProtocolsHand;		replySF: SFReply;		SFSaveDisk: PtrToWord;					{ pointer to SFSaveDisk value }		CurDirStore: PtrToLong;					{ pointer to CurDirStore value }		gBBSwindows: array[1..10] of myANSIwindPtr;		defaultStyle: charStyle;		fullnames: fullnamehand;		bullBool, statChanged, adspSupported, newBBS: boolean;		editingUser: UserRec;		SysConfig, GetUSelection, GetESelection, GetDSelection, NodeDilg, AboutDilg: DialogPtr;		gMac: SysEnvRec;		theEmail: MesgHand;		theWindPos: windSavesHand;		numUserRecs, mySaveDisk, namesDisplay, availEmails, hermesFontSize, hermesFontDescent, hermesFontWidth, hermesFontHeight: integer;		gInBackground, unused43278, curDirvalid, XFerNeedsUpdate, maskFiles: boolean;		NodeView, tabbyQuit: boolean;		result: OSErr;		HelpFile: CharsHandle;		eMailDirty: boolean;		{make sure surrounded by longs or ints for placement in externals}		NodeHnd: NodeHand;		i: integer;		forumsub: boolean;		editForum, beingRenamed, numFeedbacks, homeVol, textSearchCount, quit: integer;		IntSystRec: SystRec;		sysopAvailC, nameorDesc, screenSaver: boolean;		SharedPath, lastCurUser, globalStr, tabbyPath, textSearch: str255;		intMessStuff: MDescHand;		intDLstuff: DirDataHand;		intGFileHand: GFileSecHand;		InitSystHand: SystHand;		writeDirecttoLog, answerCalls, hasGPI, gSndCalledBack: boolean;		myUsers: UListHand;		curGlobs: HermUserGlobPtr;		activeNode: integer;		TheNodes: array[1..10] of HermUserGlobPtr;		ANSIColors: array[0..7] of integer;		visibleNode, lastSelected, charNum, bitNum, screwedID, setNewNodes: integer;		gTempRect: rect;		KBNunc: keyMap;		myCurdir, lastIdle, dailyTabbyTime, theHU2cksm, theH4cksm, theUsercksm, lastSSDraw: longint;		autoValMenu: menuHandle;		curTypUser: typicalUser;		dragFirst: cell;		myChannel: SndChannelPtr;		mySound: Handle;		XFerList, ExtList: listHandle;		SFXFerTE: TEHandle;		mppDrvrRefNum, dspDrvrRefNum, gCCBRef, numModemDrivers: integer;		gDSP: DSPParamBlock;		gMPP: MPPParamBlock;		gCCB: TRCCB;		gNTE: NamesTableEntry;		gMBarHeight: integer;		modemDrivers: MoDrListHand;	procedure InitHermes;	procedure AlertUser;	function PathNameFromDirID (DirID: longint; vRefnum: integer): str255;	function PathNameFromWD (vRefNum: longint): str255;implementation	procedure AlertUser;		var			itemHit: INTEGER;	begin		SetCursor(arrow);		itemHit := Alert(555, nil);		ExitToShell;	end; {AlertUser}	procedure SetUpTheNodes;		var			i: integer;			tempString: str255;	begin		for i := 1 to 10 do			theNodes[i] := nil;		if intSystRec.numNodes < 1 then			intSystRec.numNodes := 1;		if intSystRec.numNodes > 10 then			intSystRec.numNodes := 10;		for i := 1 to intSystRec.numNodes do		begin			theNodes[i] := HermUserGlobPtr(NewPtr(SizeOf(HermUserGlobs)));			with theNodes[i]^ do			begin				boardMode := waiting;				spying := 0;				Prompting := false;				ansInProgress := '';				sysopLogon := false;				quit := 0;				realSL := -1;				curWriting := nil;				curIndex := nil;				TextHnd := nil;				protCodeHand := nil;				nodeCCBPtr := nil;				lastBlink := tickCount;				BlinkRgn := NewRgn;				FileTransit := FLSHand(newHandle(SizeOf(FLSRec)));				MoveHHi(handle(FileTransit));				HNoPurge(handle(fileTransit));				FileTransit^^.numFiles := 0;				FileTransit^^.batchTime := 0;				FileTransit^^.batchKBytes := 0;				curmessage := nil;				sysopKeyBuffer := CharsHandle(NewHandle(0));				HNoPurge(handle(sysopKeyBuffer));				returnAfterPrompt := true;				SysopStop := false;				thisUser.UserNum := -1;				CurrentBaud := 0;				typeBuffer := '';				optBuffer := nil;				curOpenDir := nil;				extTrans := nil;				activeUserExternal := -1;				dialing := false;				waitDialResponse := false;				myTrans.active := false;				capturing := false;				tabbyPaused := false;				savedInPort := '';				transDilg := nil;				curBase := nil;				myEmailList := nil;				nodeHnd := NodeHand(GetResource('Node', i - 1));				if nodeHnd <> nil then				begin					HNoPurge(handle(NodeHnd));					MDriverName := NodeHnd^^.ModDrivName;					maxBaud := NodeHnd^^.BaudMax;					minBaud := NodeHnd^^.BaudMin;					uptime := nodeHnd^^.uptime;					bufLns := NodeHnd^^.bufferlines;					HWHH := nodeHnd^^.hardShake;					downtime := nodeHnd^^.downtime;					useDTR := nodeHnd^^.DTRHangup;					inportname := nodeHnd^^.myInport;					outPortName := nodeHnd^^.myOutPort;					if (inportname <> 'None') and (length(inPortName) > 0) then					begin						if (inportname = ADSPNAME) then							nodeType := 2						else							nodeType := 1;					end					else						nodeType := -1;					goOffinLocal := NodeHnd^^.localHook;					matchInterface := nodeHnd^^.matchSpeed;					timeout := nodeHnd^^.timeoutIn;					carrierDetect := nodeHnd^^.carDet;					doCrashMail := NodeHnd^^.allowCrashmail;					HPurge(handle(NodeHnd));					ReleaseResource(handle(NodeHnd));				end;			end;		end;		activeNode := 1;		curGlobs := theNodes[1];		visibleNode := 1;	end;	function PathNameFromDirID (DirID: longint; vRefnum: integer): str255;		var			Block: CInfoPBRec;			directoryName, FullPathName: str255;			err: OSerr;	begin		FullPathName := '';		with block do		begin			ioNamePtr := @directoryName;			ioDrParID := DirId;		end;		repeat			with block do			begin				ioVRefNum := vRefNum;				ioFDirIndex := -1;				ioDrDirID := block.ioDrParID;			end;			err := PBGetCatInfo(@Block, FALSE);			directoryName := concat(directoryName, ':');			fullPathName := concat(directoryName, fullPathName);		until (block.ioDrDirID = 2);		PathNameFromDirID := fullPathName;	end;	function PathNameFromWD (vRefNum: longint): str255;		var			myBlock: WDPBRec;			err: OSerr;	begin		with myBlock do		begin			ioNamePtr := nil;			ioVRefNum := vRefNum;			ioWDIndex := 0;			ioWDProcID := 0;		end;		err := PBGetWDInfo(@myBlock, FALSE);		with myBlock do			PathNameFromWD := PathNameFromDirID(ioWDDirID, ioWDVRefnum)	end;	function makeADir (path: str255): OSerr;		var			myHParms: HParamBlockRec;	begin		myHParms.ioCompletion := nil;		myHParms.ioNameptr := @path;		myHParms.ioVRefNum := 0;		myHParms.ioDirID := 0;		result := PBDirCreate(@myHParms, false);		makeADir := result;	end;	procedure MakeHTxt (name: str255; fR: integer);		var			myh: handle;			t1: str255;	begin		t1 := concat('This is the "', name, '" file.');		myh := NewHandle(length(t1));		BlockMove(pointer(@t1[1]), pointer(myH^), length(t1));		AddResource(myh, 'HTxt', UniqueID('HTxt'), name);	end;	function mySFGetHook (MySFitem: integer; theDialog: DialogPtr): integer;		var			t1, t2, t3: str255;			i, sRef, b, c: integer;			freshSyst: SystHand;			freshBase: MDescHand;			freshDirs: DirDataHand;			freshGs: GFileSecHand;			myTH: handle;			tl: longint;			freshNode: NodeHand;			tempRT: ResType;	begin		if mySFItem = -1 then			ParamText('Please select your ''Hermes Shared'' file, or click New to create a new BBS.', '', '', '')		else if mySFItem = 12 then		begin			t1 := concat(PathnameFromDirID(curDirStore^, -(SFSaveDisk^)), 'Hermes Files');			if makeADir(t1) = noErr then			begin				sharedPath := concat(t1, ':');				t2 := concat(t1, ':Messages');				result := makeADir(t2);				for i := 1 to 10 do				begin					NumToString(i, t3);					result := makeADir(concat(t2, ':for', t3));				end;				result := makeADir(concat(t2, ':Email'));				result := makeADir(concat(t1, ':Logs'));				result := makeADir(concat(t1, ':Data'));				result := makeADir(concat(t1, ':GFiles'));				result := makeADir(concat(t1, ':Files'));				t2 := concat(t1, ':Trash Users');				result := Create(t2, 0, 'HRMS', 'TEXT');				result := FSOpen(t2, 0, i);				t2 := concat('FUCK', char(13), 'SHIT', char(13));				tl := length(t2);				result := FSWrite(i, tl, @t2[1]);				result := FSClose(i);				t2 := concat(t1, ':Hermes Shared');				result := Create(t2, 0, 'HRMS', 'DATA');				CreateResFile(t2);				sRef := OpenRFPerm(t2, 0, fsRdWrPerm);				if (sRef <> -1) then				begin					freshSyst := SystHand(NewHandleClear(SizeOf(SystRec)));					with freshSyst^^ do					begin						OverridePass := 'SYSOP';						NewUserPass := 'NUP';						numNodes := 1;						newSL := 1;						newDSL := 1;						ninePoint := true;						protocolTime := 10;						defaFore := 0;						defaBack := 7;						twoColorChat := true;						twoWayChat := true;						logDays := 7;					end;					UseResFile(sRef);					AddResource(handle(freshSyst), 'BBsy', 0, '');					freshBase := MDescHand(NewHandleClear(SizeOf(MDescRec)));					AddResource(handle(freshBase), 'MesD', 0, 'Message Bases');					freshDirs := DirDataHand(NewHandleClear(SizeOf(DirDataFile)));					AddResource(handle(freshDirs), 'MesD', 1, 'Directories');					freshGs := GFileSecHand(NewHandleClear(SizeOf(GFileSecRec)));					AddResource(handle(freshGs), 'MesD', 2, 'GFiles');					freshNode := NodeHand(NewHandleClear(SizeOf(NodeRec)));					with freshNode^^ do					begin						baudMax := 12;						baudMin := 9;						myInPort := 'None';						myOutPort := 'None';						modDrivName := 'Hayes Compatible';						localHook := true;						matchSpeed := true;						timeoutIn := 3;						BufferLines := 250;						carDet := CTS5;					end;					for i := 0 to 9 do					begin						AddResource(handle(freshNode), 'Node', i, '');						WriteResource(handle(freshNode));						DetachResource(handle(freshNode));					end;					UseResFile(myResourceFile);					b := Count1Resources('NHTx');					for i := 1 to b do					begin						myTH := Get1IndResource('NHTx', i);						GetResInfo(myTH, c, tempRT, t3);						DetachResource(myTH);						UseResFile(sRef);						AddResource(myTH, 'HTxt', c, t3);						UseResFile(myResourceFile);					end;					UseResFile(sRef);					MakeHTxt('No New User', sRef);					MakeHTxt('Feedback', sRef);					MakeHTxt('Log On', sRef);					MakeHTxt('ANSI Upload Message', sRef);					MakeHTxt('ANSI Log On', sRef);					MakeHTxt('ANSI Log Off', sRef);					MakeHTxt('Upload Message', sRef);					MakeHTxt('Log Off', sRef);					MakeHTxt('ANSI BBS Info', sRef);					MakeHTxt('BBS Info', sRef);					MakeHTxt('ANSI Feedback', sRef);					MakeHTxt('New User', sRef);					UseResFile(myResourceFile);					CloseResFile(sRef);					newBBS := true;					mySFItem := 3;				end				else					SysBeep(10);			end			else				SysBeep(10);		end;		mySFGetHook := mySFItem;	end;	function CTBInstalled: boolean;		const			commToolboxTrap = $8B;			UnimplementedTrapNumber = $9F;	begin		CTBInstalled := true;		if NGetTrapAddress(unimplementedTrapNumber, OSTrap) = NGetTrapAddress(commtoolboxTrap, OSTrap) then			CTBInstalled := false;	end;	procedure SetupMenus;		var			menuBar: handle;			nyet: menuHandle;			i: integer;			tempLong: longint;			ts1: str255;	begin		menuBar := GetNewMBar(128);		SetMenuBar(menuBar);		DisposHandle(menuBar);		AddResMenu(GetMHandle(mApple), 'DRVR');		Nyet := GetMenu(10);		AppendMenu(nyet, '<IOther.../O');		InsertMenu(nyet, -1);		nyet := GetMenu(57);		InsertMenu(nyet, -1);		nyet := GetMenu(55);		InsertMenu(nyet, -1);		autoValmenu := NewMenu(58, 'Auto Validates');		InsertMenu(autoValMenu, -1);		nyet := GetMenu(50);		InsertMenu(nyet, -1);		nyet := GetMenu(53);		InsertMenu(nyet, -1);		nyet := GetMenu(54);		InsertMenu(nyet, -1);		nyet := GetMenu(70);		InsertMenu(nyet, -1);		DisableItem(GetMHandle(mTerminal), 0);		DisableItem(GetMHandle(mUser), 0);		DisableItem(getMHandle(mUser), 9);		AddResMenu(getMHandle(10), 'HTxt');		nyet := GetMHandle(mLog);		for i := 1 to intSystRec.logDays do		begin			GetDateTime(tempLong);			IUDateString(tempLong - (86400 * i), shortDate, ts1);			AppendMenu(nyet, ' ');			SetItem(nyet, countMItems(nyet), ts1);		end;		DrawMenuBar;	end;	procedure InitHermes;		var			i, sharedRef: integer;			tyto: str255;			repo: SFReply;			dere: SFTypeList;			abg: point;			tempLong: longInt;			initSystHand: SystHand;			KBNunc: keyMap;			myStart: startInfoHand;	begin		gInBackground := FALSE;		InitCursor;		FlushEvents(everyEvent, 0);		result := SysEnvirons(2, gMac);		result := GetVol(@globalStr, homeVol);		myResourceFile := curResFile;		sfSaveDisk := PtrToWord(kSFSaveDisk);		curDirStore := PtrToLong(kCurDirStore);		newBBS := false;		if (gMac.machineType < 1) or (gMac.systemVersion < $0604) or not CTBInstalled then			AlertUser;		myStart := startInfoHand(Get1Resource('Node', -2));		theHU2cksm := myStart^^.mynewcksm;		theH4cksm := myStart^^.myH4cksm;		theUsercksm := myStart^^.myUserCksm;		sharedPath := myStart^^.sharedPath;		sharedRef := -1;		GetKeys(KBnunc);		charnum := 55 div 8;		bitnum := 7 - (55 mod 8);		if not (BitTst(@KBNunc, 8 * charnum + bitnum)) then			sharedRef := OpenRFPerm(concat(sharedPath, 'Hermes Shared'), 0, fsRdWrPerm);		if sharedRef = -1 then		begin			SysBeep(10);			abg.h := 50;			abg.v := 80;			dere[0] := 'HRMS';			tyto := '';			SFPGetFile(abg, tyto, nil, -1, dere, @mySFGetHook, repo, 206, nil);			if repo.good or newBBS then			begin				tyto := '';				if not newBBS then					sharedPath := PathNamefromWD(repo.vRefNum);				myStart := startInfoHand(Get1Resource('Node', -2));				myStart^^.sharedPath := sharedPath;				ChangedResource(handle(myStart));				WriteResource(handle(myStart));				sharedRef := OpenRFPerm(concat(sharedPath, 'Hermes Shared'), 0, fsRdWrPerm);			end;		end;		if (sharedRef = -1) then			ExitToShell;		initSystHand := systHand(GetResource('BBsy', 0));		if reserror <> noErr then			ExitToShell;		intSystRec := InitSystHand^^;		ReleaseResource(handle(initSystHand));		RShared := sharedRef;		SetupTheNodes;		result := FSOpen(concat(sharedPath, 'Hermes Shared'), 0, DShared);		fullnames := nil;		tabbyQuit := false;		dragFirst := cell($FFFFFFFE);		myUsers := nil;		writedirectTolog := false;		sysopAvailC := false;		answerCalls := true;		lastCurUser := '';		theProts := nil;		if intSystRec.defaFore < 8 then		begin			defaultStyle.fcol := intSystRec.defaFore;			defaultStyle.bcol := intSystrec.defaBack;		end		else		begin			defaultstyle.fcol := 7;			defaultstyle.bcol := 0;		end;		defaultstyle.bold := false;		defaultstyle.underline := false;		ANSIColors[0] := blackColor;		ANSIcolors[1] := redColor;		ANSIcolors[2] := greenColor;		ANSIcolors[3] := yellowColor;		ANSIcolors[4] := blueColor;		ANSIcolors[5] := magentacolor;		ANSIcolors[6] := cyanColor;		ANSIcolors[7] := whiteColor;		for i := 1 to 10 do			gBBSwindows[i] := nil;		theWindPos := windSavesHand(GetResource('Node', -10));		if theWindPos = nil then		begin			theWindPos := windSavesHand(newHandle(SizeOf(windowSaves)));			for i := 1 to 10 do			begin				SetRect(theWindPos^^.wNodesStd[i], 0, 0, 0, 0);				SetRect(theWindPos^^.wNodesUser[i], 0, 0, 0, 0);			end;			SetRect(theWindPos^^.wStatus, 0, 0, 0, 0);			for i := 0 to 10 do				theWindPos^^.wIsOpen[i] := true;			AddResource(handle(theWindPos), 'Node', -10, '');		end;		HNoPurge(handle(theWindPos));		MoveHHi(handle(theWindPos));		UseResFile(myResourceFile);		SetupMenus;		myExternals := nil;		nodeDilg := nil;		SysConfig := nil;		getESelection := nil;		getUSelection := nil;		GetDSelection := nil;		for i := 1 to 10 do			held[i] := false;		AboutDilg := nil;		numTextWinds := 0;		sysopOpenDir := nil;		sysopNumFiles := 0;		theEmail := nil;		emailDirty := true;		statWindow := nil;		screwedID := 0;		theDials := nil;		sysopDirNum := -1;		nodeView := true;		textSearch := '';		setNewNodes := 0;		screenSaver := false;		lastSSDraw := 0;		result := OSErr(initCRM);		result := OSErr(initCTBUtilities);		mySaveDisk := SFSaveDisk^ + 1; {so we're sure that they're different}		randseed := tickCount;		if (gMac.atDrvrVersNum >= 53) then			adspSupported := true		else			adspSupported := false;		mppDrvrRefNum := -1;		if gMac.systemVersion < $0607 then		begin			if (gMac.machineType <> 1) and (gMac.machineType <> 2) and (gMac.machineType <> 15) and (gMac.machineType <> 17) then				hasGPi := true			else				hasGPi := false;		end		else		begin			result := Gestalt(gestaltSerialAttr, tempLong);			hasGPi := (BAnd(tempLong, bsl(1, gestaltHasGPIaToDCDa)) <> 0)		end;	end;end.