unit HUtils3;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, SystemPrefs, User, inpOut2, InpOut, HUtilsTwo, HermesUtils, FileTrans, FileTrans2, Message_Editor, nodeprefs, terminal, notification, PPCToolbox, Processes, EPPC, AppleEvents;	procedure ChangeDefaults;	procedure DoListUsers;	procedure DoAllRead;	procedure DoMainMenu;	procedure MultiNodeChat;	procedure DoBatchCommands;	procedure ScanNewMess;	function HandleAEOpenDoc (theAppleEvent, reply: AppleEvent; handlerRefcon: LongInt): OSErr;	function HandleAEQuitApp (theAppleEvent, reply: AppleEvent; handlerRefcon: LongInt): OSErr;	function HandleAEHLogoff (theAppleEvent, reply: AppleEvent; handlerRefcon: LongInt): OSErr;implementation	function HandleAEQuitApp (theAppleEvent, reply: AppleEvent; handlerRefcon: LongInt): OSErr;	begin		quit := 2;		HandleAEQuitApp := 0;	end;	function HandleAEHLogoff (theAppleEvent, reply: AppleEvent; handlerRefcon: LongInt): OSErr;		var			i: integer;	begin		for i := 1 to intSystRec.numNodes do		begin			curGlobs := theNodes[i];			activeNode := i;			with curGlobs^ do			begin				if myTrans.active then				begin					extTrans^^.flags[carrierLoss] := true;					ClearInBuf;					repeat						ContinueTrans;					until not myTrans.active;				end;				if (thisUser.userNum) > 0 then					sysopLog('      Logged off by AppleEvent.', 6);				HangupAndReset;			end;		end;		HandleAEHLogoff := 0;	end;	function HandleAEOpenDoc (theAppleEvent, reply: AppleEvent; handlerRefcon: LongInt): OSErr;		var			myFSS: FSSpec;			docList: AEDescList;			myErr: OSErr;			index, itemsInList: LongInt;			actualSize: Size;			keywd: AEKeyword;			returnedType: DescType;			t1: str255;			myFInfo: FInfo;	begin		myErr := AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, docList);{    myErr := MyGotRequiredParams(theAppleEvent);}		if myErr <> noErr then		begin			HandleAEOpenDoc := myErr;			Exit(HandleAEOpenDoc);		end;		myErr := AECountItems(docList, itemsInList);		for index := 1 to itemsInList do		begin			myErr := AEGetNthPtr(docList, index, typeFSS, keywd, returnedType, @myFSS, Sizeof(myFSS), actualSize);			t1 := PathNameFromDirID(myFSS.parID, myFSS.vRefNum);			result := GetFInfo(concat(t1, myFSS.name), 0, myFInfo);			if (myFInfo.fdType = 'MODR') then			begin				OpenModemFile(concat(t1, myFSS.name));			end			else if (myFInfo.fdType = 'TEXT') then				OpenTextWindow(t1, myFSS.name, false, true);		end;		myErr := AEDisposeDesc(docList);		HandleAEOpenDoc := noErr;	end;	procedure ScanNewMess;		var			scanF, scanS, cou1, i, tempint: integer;			tb2, goodSub: boolean;			ts, tempstring: Str255;			tempLong: longint;			tempsub: subdyhand;	begin		with curGlobs^ do		begin			case ScanNewDo of				Scan1: 				begin					if curprompt = 'Y' then					begin						crossInt := 1;						while not (thisUser.msgFrmaccess[crossint]) and (crossint <= intMessStuff^^.numForums) do							crossint := crossint + 1;						crossInt2 := 0;						ScanNewDo := Scan2;					end					else						GoHome;				end;				Scan2: 				begin					if crossint <= intmessStuff^^.numForums then					begin						repeat							crossInt2 := crossInt2 + 1;							goodSub := false;							tb2 := true;							if intMessStuff^^.boards[crossint, crossint2].restrict <> char(0) then								if thisUser.restrics[(byte(intMessStuff^^.boards[crossint, crossint2].restrict) - byte(64))] then									tb2 := true								else									tb2 := false;							if tb2 and (thisUser.whatNScan[crossint, crossint2]) and (intMessStuff^^.numBoards[crossint] >= crossint2) and (intMessStuff^^.boards[crossint, crossint2].SLtoRead <= thisUser.secLevel) and (thisUser.age >= intMessStuff^^.boards[crossint, crossint2].minage) then								goodSub := true;						until (crossint2 >= intMessStuff^^.numBoards[crossint]) or goodSub;						if goodSub then						begin							OutLine(concat(retinstr(18, 32), intmessStuff^^.boards[crossInt, crossInt2].name, '...'), true, 1);							OpenBase(crossInt, crossInt2, false);							inMessage := 1;							crossInt3 := 1;							ScanNewDo := Scan3;						end						else						begin							crossInt2 := 0;							crossInt := crossInt + 1;							while not (thisUser.msgFrmaccess[crossint]) and (crossint <= intMessStuff^^.numForums) do								crossint := crossint + 1;						end;					end					else						GoHome;				end;				Scan3: 				begin					if curNumMess > 0 then					begin						i := crossInt3;						while (i <= curNumMess) and ((curBase^^[i - 1].qScnPtr <= thisUser.lastMsgs[crossInt, crossint2]) or (curBase^^[i - 1].toUserNum <> thisUser.userNum)) do							i := i + 1;						if (i <= curNumMess) and (curBase^^[i - 1].qScnPtr > thisUser.lastMsgs[inforum, insub]) and (curBase^^[i - 1].toUserNum = thisUser.userNum) then							inmessage := i						else							inMessage := curnummess + 1;					end;					if (curNumMess = 0) or (inMessage > curNumMess) then					begin						ScanNewDo := Scan2;					end					else					begin						crossint3 := i + 1;						scanf := inForum;						scanS := inSub;						inForum := crossint;						inSub := crossInt2;						PrintCurMessage(false);						inForum := scanF;						inSub := scanS;						ScanNewDo := Scan4;					end;				end;				Scan4: 				begin					OutLine('[', true, 3);					OutLine(intMessStuff^^.boards[crossInt, crossInt2].Name, false, 4);					OutLine('] ', false, 3);					if thisUser.secLevel >= intMessStuff^^.boards[crossInt, crossInt2].SLtoPost then						LettersPrompt(' <CR> = Next, R:eply, Q:uit  : ', 'RQ', 1, true, false, true, char(0))					else						LettersPrompt(' <CR> = Next, Q:uit  : ', 'Q', 1, true, false, true, char(0));					ScanNewDo := Scan5;				end;				Scan5: 				begin					if curprompt = 'Q' then						GoHome					else if (curPrompt = 'R') then					begin						fromQScan := true;						fromMsgScan := true;						saveInForum := inForum;						saveInSub := inSub;						crossInt3 := inMessage;						inForum := crossInt;						inSub := crossInt2;						PostDo := postOne;						BoardSection := post;						reply := true;						replyToStr := curBase^^[inMessage - 1].fromuserName;						replyToNum := curBase^^[inMessage - 1].fromUserNum;						if curBase^^[inMessage - 1].anonyFrom then							replyToAnon := true						else							replyToAnon := false;						if intMessStuff^^.boards[crossInt, crossInt2].threading then						begin							if (curBase^^[inMessage - 1].title[1] <> char(0)) then								replyStr := concat(char(0), 'RE: ', curBase^^[inMessage - 1].title)							else								replyStr := curBase^^[inMessage - 1].title;						end						else							replyStr := concat('RE: ', curBase^^[inMessage - 1].title);					end;					ScanNewDo := Scan3;				end;				otherwise			end;		end;	end;	procedure MultiNodeChat;		var			te1, te2: str255;			i: integer;	begin		with curglobs^ do		begin			case MultiChatDo of				Mult1: 				begin					i := length(thisUser.userName) + 2;					LettersPrompt('> ', '', 79 - i, false, true, false, char(0));					curprompt := excess;					OutLine(excess, false, 0);					excess := '';					MultiChatDo := Mult2;				end;				Mult2: 				begin					if length(curPrompt) > 0 then					begin						if curPrompt[1] = '/' then						begin							if equalString('/X', curPrompt, false, false) then							begin								numToString(thisUser.userNum, te1);								MultiChatOut(concat(thisUser.userName, ' #', te1, ' has left.'), false);								OutLine(retinstr(18, 33), true, 1);								goHome;							end							else if equalString('/U', curPrompt, false, false) then							begin								OutLine(retinstr(18, 34), true, 2);								for i := 1 to intSystRec.numNodes do								begin									if not (theNodes[i]^.nodeType < 0) then									begin										if (theNodes[i]^.boardMode = User) and (theNodes[i]^.thisUser.userNum > 0) then										begin											te1 := theNodes[i]^.thisUser.userName;											NumToString(i, te2);											OutLine(concat(te2, '. ', te1), true, 0);											if (theNodes[i]^.BoardSection = MultiChat) then												OutLine(retinstr(18, 35), false, 1);										end;									end;								end;								bCR;								MultiChatDo := Mult1;							end							else if equalString('/H', curprompt, false, false) then							begin								OutLine(retinstr(18, 36), true, 2);								OutLine(retinstr(18, 37), true, 1);								OutLine(retinstr(18, 38), true, 1);								OutLine(retinstr(18, 39), true, 1);								bCR;								MultiChatDo := Mult1;							end							else								MultiChatDo := Mult1;						end						else						begin							MultiChatOut(curPrompt, true);							MultiChatDo := Mult1;						end;					end					else						MultiChatDo := Mult1;				end;				otherwise			end;		end;	end;	procedure DoBatchCommands;		label			100;		var			tstr, t2: str255;			tempLong: longint;			i: integer;	begin		with curglobs^ do		begin			case BatDo of				BatOne: 				begin					if FileTransit^^.numFiles > 0 then					begin						bCR;						BCR;						if (fileTransit^^.sendingbatch) then							LettersPrompt(retinstr(18, 40), 'LDRCQ', 1, true, false, true, char(0))						else							LettersPrompt(retinstr(18, 80), 'LURCQ', 1, true, false, true, char(0));						BatDo := BatTwo;					end					else					begin						OutLine(retinstr(18, 41), true, 0);						GoHome;					end;				end;				BatTwo: 				begin					if length(curPrompt) > 0 then					begin						case curprompt[1] of							'D', 'U': 							begin								if not sysopLogon then								begin									if (fileTransit^^.sendingBatch) then									begin										if DLratioOK then										begin											if (fileTransit^^.batchTime * 60) <= ticksLeft(activeNode) then											begin100:												bCR;												YesNoQuestion(retinstr(18, 42), false);												BatDo := BatFive;											end											else											begin												OutLine(retinstr(18, 43), true, 0);												BatDo := BatOne;											end;										end										else										begin											BatDo := BatOne;											OutLine(retinstr(18, 44), true, 0);										end;									end									else										goto 100;								end								else								begin									OutLine(retinstr(18, 45), true, 0);									BatDo := BatOne;								end;							end;							'R': 							begin								NumToString(FileTransit^^.numFiles, tstr);								bCR;								NumbersPrompt(concat('Remove which(1-', tstr, ') ?'), '', fileTransit^^.numFiles, 1);								BatDo := BatFour;							end;							'C': 							begin								bCR;								YesNoQuestion(retinstr(18, 81), false);								BatDo := BatThree;							end;							'L': 							begin								NumToString(fileTransit^^.numFiles, tstr);								t2 := secs2time(fileTransit^^.batchTime);								if (fileTransit^^.sendingBatch) then									OutLine(concat('Batch: Files - ', tstr, '  Time - ', t2), true, 0)								else									OutLine(concat('Batch: Files - ', tstr), true, 0);								bCR;								for i := 1 to fileTransit^^.numFiles do								begin									NumToString(i, tstr);									t2 := FileTransit^^.FilesGoing[i].theFile.flName;									while length(t2) < 21 do										t2 := concat(t2, ' ');									t2 := concat(tstr, '. ', t2);									if not (fileTransit^^.sendingBatch) then										OutLine(concat(t2, ': ', intDLStuff^^.dr[fileTransit^^.filesGoing[i].fromDir].dirname), true, 0)									else if (currentBaud <> 0) and (nodeType = 1) then										OutLine(concat(t2, secs2Time(fileTransit^^.filesGoing[i].theFile.byteLen div (modemDrivers^^[modemID].rs[rsIndex].effRate div 10))), true, 0)									else										OutLine(concat(t2, '00:00:00'), true, 0);									BatDo := BatOne;								end;							end;							'Q': 								GoHome;							otherwise								BatDo := BatOne;						end;					end					else						BatDo := BatOne;				end;				BatFive: 				begin					if curPrompt = 'Y' then						AfterHangup := true					else						AfterHangup := false;					bCR;					NumToString(fileTransit^^.numFiles, tstr);					if (fileTransit^^.sendingBatch) then					begin						t2 := secs2time(fileTransit^^.batchTime);						OutLine(concat('Transmitting:  Files - ', tstr, '  Time - ', t2), true, 0);						bCR;						myTrans.sending := true;					end					else					begin						OutLine(concat('Receiving:  Files - ', tstr), true, 0);						myTrans.sending := false;						bCR;					end;					myTrans.active := true;					activeProtocol := lastBatch;					StartTrans;				end;				BatSix: 				begin					statChanged := true;					if AFTERhangup then					begin						bCR;						bCR;						ClearScreen;						OutLine(retinstr(18, 46), true, 2);						BatDo := BatSeven;						crossInt := 0;						lastKeyPressed := tickCount;						lastLastPressed := lastKeyPressed;						bCR;					end					else						goHome;				end;				BatSeven: 				begin					if lastKeyPressed = lastlastPressed then					begin						if tickCount > (lastkeypressed + (crossInt * 60)) then						begin							crossInt := crossInt + 1;							NumToString(crossint, t2);							for i := 1 to 5 do								backspace(1);							OutLine(concat(t2, '...'), false, 0);							if crossInt = 10 then								HangUpandReset;						end;					end					else						GoHome;				end;				BatFour: 				begin					StringToNum(curprompt, tempLong);					if (tempLong > 0) and (tempLong <= FileTransit^^.numFiles) then					begin						if (fileTransit^^.sendingBatch) then						begin							fileTransit^^.batchKBytes := fileTransit^^.batchKBytes - (fileTransit^^.filesGoing[tempLong].theFile.byteLen div 1024);							if (currentBaud <> 0) and (nodeType = 1) then								FileTransit^^.batchTime := fileTransit^^.batchTime - (fileTransit^^.filesGoing[tempLong].theFile.byteLen div (modemDrivers^^[modemID].rs[rsIndex].effRate div 10))							else								FileTransit^^.batchTime := 0;						end;						FileTransit^^.numFiles := FileTransit^^.numFiles - 1;						if (tempLong <= FileTransit^^.numFiles) and (fileTransit^^.numFiles > 0) then						begin							for i := (tempLong + 1) to (fileTransit^^.numFiles + 1) do								FileTransit^^.filesGoing[i - 1] := fileTransit^^.filesGoing[i];						end;						OutLine('Removed.', true, 0);						BatDo := BatOne;					end					else					begin						OutLine('Not in queue.', true, 0);						BatDo := BatOne;					end;				end;				BatThree: 				begin					if curPrompt = 'Y' then					begin						FileTransit^^.numFiles := 0;						FileTransit^^.batchTime := 0;						FileTransit^^.batchKBytes := 0;						OutLine('Queue cleared.', true, 0);						bCR;					end;					BatDo := BatOne;				end;				otherwise			end;		end;	end;	function NextMess: boolean;		var			gotOne: boolean;	begin		with curglobs^ do		begin			gotOne := false;			while not gotOne and ((atEMail + 1) <= availEmails) do			begin				atEMail := atEMail + 1;				if (theEmail^^[atEMail].MType = 1) and (theEmail^^[atEMail].toUser > 0) then					gotOne := true;			end;		end;		if gotOne then			nextmess := true		else			nextmess := false;	end;	function LastMess: boolean;		var			gotOne: boolean;	begin		with curglobs^ do		begin			gotOne := false;			while not gotOne and ((atEMail - 1) >= 0) do			begin				atEMail := atEMail - 1;				if (theEmail^^[atEMail].MType = 1) and (theEmail^^[atEMail].toUser > 0) then					gotOne := true;			end;		end;		if gotOne then			lastMess := true		else			lastmess := false;	end;	procedure AllMaPrint;		var			ts1, ts2: str255;			printMail: emailRec;	begin		with curglobs^ do		begin			if textHnd <> nil then			begin				disposHandle(handle(textHnd));				textHnd := nil;			end;			printMail := theEmail^^[atEmail];			OutLine(concat('Title: ', printMail.title), true, 0);			NumToString(printMail.fromUser, ts1);			OutLine(concat('From : ', myUsers^^[printMail.fromUser - 1].UName, ' #', ts1), true, 0);			NumToString(printMail.touser, ts1);			OutLine(concat('To   : ', myUsers^^[printMail.toUser - 1].UName, ' #', ts1), true, 0);			IUDateString(printmail.datesent, shortDate, ts1);			OutLine(concat('Date : ', ts1), true, 0);			bCR;			textHnd := textHand(ReadMessage(true, printMail.storedAs, 0, 0));			if textHnd <> nil then			begin				curtextPos := 0;				OpenTextSize := GethandleSize(handle(textHnd));				BoardAction := ListText;				ListTextFile;			end			else				OutLine('Message not found.', true, 0);		end;	end;	procedure DoAllRead;		var			ts: str255;			printEma: emailrec;	begin		with curglobs^ do		begin			case AllDo of				AllOne: 				begin					if EqualString(curprompt, intSystRec.overridePass, false, false) or sysoplogon then					begin						bCR;						atEMail := -1;						if nextmess then						begin							AllMaPrint;							AllDo := AllTwo;						end						else						begin							Outline('No mail.', true, 0);							GoHome;						end;					end					else					begin						OutLine('Incorrect.', true, 0);						GoHome;					end;				end;				AllTwo: 				begin					bCR;					LettersPrompt('R, D, Q, P, <space>  : ', 'RDQP ', 1, true, false, true, char(0));					AllDo := AllThree;				end;				AllThree: 				begin					case curprompt[1] of						'R': 						begin							AllDo := AllTwo;							AllMaPrint;						end;						'Q': 						begin							GoHome;						end;						'P': 						begin							if not lastmess then								if nextMess then									;							AllDo := AllTwo;							AllMaPrint;						end;						'D': 						begin							DeleteMail(atEmail);							atEMail := atEMail - 1;							if nextMess then							begin								AllDo := AllTwo;								AllMaPrint;							end							else								GoHome;						end;						otherwise						begin							if nextMess then							begin								AllDo := AllTwo;								AllMaPrint;							end							else								GoHome;						end;					end;				end;				otherwise			end;		end;	end;	procedure DoListUsers;		var			tss: str255;			tb, tb2: boolean;	begin		with curglobs^ do		begin			tb2 := false;			if crossInt = 0 then			begin				crossInt := 1;				BoardAction := repeating;				if curPrompt = 'Y' then					crossInt2 := 1				else					crossInt2 := 0;			end			else			begin				if not sysopStop and not aborted then				begin					repeat						crossInt3 := crossInt3 + 1;						tb := true;						if (crossInt2 = 1) then						begin							if (myUsers^^[crossInt3 - 1].sl < intMessStuff^^.boards[inForum, inSub].SLtoRead) then								tb := false;						end;						if (not myUsers^^[crossInt3 - 1].dltd) and tb then						begin							NumToString(crossInt3, tss);							OutLine(concat(myUsers^^[crossInt3 - 1].UName, ' #', tss), true, 0);							tb2 := true;						end;					until tb2 or (crossInt3 = numUserRecs);				end;				if (crossInt3 = numUserRecs) or aborted then				begin					BoardAction := none;					GoHome;				end;			end;		end;	end;	procedure ListColors;		var			t11, t12: str255;	begin		ANSIcode('0;30;47m');		Outline('0. Color #0', true, -1);		ANSICode('0;31;40m');		OutLine('1. Color #1', true, -1);		ANSIcode('0;32;40m');		OutLine('2. Color #2', true, -1);		ANSIcode('0;33;40m');		OutLine('3. Color #3', true, -1);		ANSIcode('0;34;40m');		OutLine('4. Color #4', true, -1);		ANSIcode('0;35;40m');		OutLine('5. Color #5', true, -1);		ANSIcode('0;36;40m');		OutLine('6. Color #6', true, -1);		ANSIcode('0;37;40m');		OutLine('7. Color #7', true, -1);		ANSICode('0m');	end;	procedure ChangeDefaults;		var			tempString, tempString2: str255;			i: integer;			tempint: longInt;			tempuser2: userRec;			tb2: boolean;	begin		with curglobs^ do		begin			case DefaultDo of				DefaultOne: 				begin					PrintUserDefaults;					bCR;					bCR;					DefaultDo := DefaultTwo;				end;				DefaultTwo: 				begin					if thisUser.canANSI then						NumbersPrompt('Defaults: (1-10,?,Q) : ', '?Q', 10, 1)					else						NumbersPrompt('Defaults: (1-9,?,Q) : ', '?Q', 9, 1);					DefaultDo := DefaultThree;				end;				DefaultThree: 				begin					if length(CurPrompt) > 0 then					begin						case curPrompt[1] of							'Q': 								GoHome;							'?': 							begin								DefaultDo := DefaultOne;							end;							'5': 							begin								thisUser.screenClears := not thisUser.screenClears;								bCR;								DefaultDo := DefaultTwo;							end;							'8': 							begin								if (thisUser.notifyLogon) then									thisUser.notifyLogon := false								else									thisUser.notifyLogon := true;								bCR;								DefaultDo := DefaultTwo;							end;							'9': 							begin								bufferbCR;								bufferIt(retinstr(18, 70), true, -1);								bufferbCR;								i := 1;								GetIndString(tempString, 15, i);								repeat									NumToString(i, tempString2);									tempstring2 := concat(tempstring2, '. ', tempString);									i := i + 1;									if tempString <> '' then									begin										bufferIt(tempString2, true, -1);										GetIndString(tempString, 15, i);									end;								until (tempString = '');								bufferbCR;								bufferbCR;								bufferIt(retinstr(18, 71), false, -1);								bufferIt(retinstr(18, 72), true, -1);								bufferbCR;								ReleaseBuffer;								NumbersPrompt(': ', '', i - 1, 1);								DefaultDo := D25;							end;							'1': 							begin								if (length(curPrompt) = 1) then								begin									bCR;									NumbersPrompt('How wide is your screen (chars, <CR>=80) ?', '', 200, 1);									DefaultDo := Def14;								end								else								begin									NumToString(thisuser.foregrounds[0], tempstring);									NumToString(thisUser.backGrounds[0], tempString2);									OutLine(concat('0. Default           Color #', tempString, ' on Color #', tempString2), true, 0);									if thisUser.bolds[0] then										OutLine(', Bold', false, 0);									if thisUser.underlines[0] then										OutLine(', Underlined', false, 0);									dom(0);									NumToString(thisuser.foregrounds[1], tempstring);									NumToString(thisUser.backGrounds[1], tempString2);									OutLine(concat('1. Yes/No            Color #', tempString, ' on Color #', tempString2), true, 1);									if thisUser.bolds[1] then										OutLine(', Bold', false, 1);									if thisUser.underlines[1] then										OutLine(', Underlined', false, 1);									dom(0);									NumToString(thisuser.foregrounds[2], tempstring);									NumToString(thisUser.backGrounds[2], tempString2);									OutLine(concat('2. Prompt            Color #', tempString, ' on Color #', tempString2), true, 2);									if thisUser.bolds[2] then										OutLine(', Bold', false, 2);									if thisUser.underlines[2] then										OutLine(', Underlined', false, 2);									dom(0);									NumToString(thisuser.foregrounds[3], tempstring);									NumToString(thisUser.backGrounds[3], tempString2);									OutLine(concat('3. Note              Color #', tempString, ' on Color #', tempString2), true, 3);									if thisUser.bolds[3] then										OutLine(', Bold', false, 3);									if thisUser.underlines[3] then										OutLine(', Underlined', false, 3);									dom(0);									NumToString(thisuser.foregrounds[4], tempstring);									NumToString(thisUser.backGrounds[4], tempString2);									OutLine(concat('4. Input Line        Color #', tempString, ' on Color #', tempString2), true, 4);									if thisUser.bolds[4] then										OutLine(', Bold', false, 4);									if thisUser.underlines[4] then										OutLine(', Underlined', false, 4);									dom(0);									NumToString(thisuser.foregrounds[5], tempstring);									NumToString(thisUser.backGrounds[5], tempString2);									OutLine(concat('5. Yes/No Question   Color #', tempString, ' on Color #', tempString2), true, 5);									if thisUser.bolds[5] then										OutLine(', Bold', false, 5);									if thisUser.underlines[5] then										OutLine(', Underlined', false, 5);									dom(0);									NumToString(thisuser.foregrounds[6], tempstring);									NumToString(thisUser.backGrounds[6], tempString2);									OutLine(concat('6. Notice!           Color #', tempString, ' on Color #', tempString2), true, 6);									if thisUser.bolds[6] then										OutLine(', Bold', false, 6);									if thisUser.underlines[6] then										OutLine(', Underlined', false, 6);									dom(0);									NumToString(thisuser.foregrounds[7], tempstring);									NumToString(thisUser.backGrounds[7], tempString2);									OutLine(concat('7. Border            Color #', tempString, ' on Color #', tempString2), true, 7);									if thisUser.bolds[7] then										OutLine(', Bold', false, 7);									if thisUser.underlines[7] then										OutLine(', Underlined', false, 7);									dom(0);									bCR;									bCR;									HelpNum := 30;									NumbersPrompt('Change which (0-7, Q=Quit) ? ', 'Q', 7, 0);									DefaultDo := D18;								end;							end;							'2': 							begin								bCR;								OutANSItest;								bCR;								OutLine('Is the above line colored, italicized,', false, 5);								bCR;								YesNoQuestion('bold, inversed, or blinking? ', false);								DefaultDo := Def16;							end;							'3': 							begin								YesNoQuestion('Pause each screenfull? ', false);								DefaultDo := DefaultFour;							end;							'4': 							begin								HelpNum := 29;								YesNoQuestion('Do you want to forward your mail? ', false);								DefaultDo := DefaultFive;							end;							'6': 							begin								for i := 1 to intMessStuff^^.numForums do								begin									if thisUser.MsgFrmAccess[i] then									begin										if i = 10 then											tempString := '0'										else											NumToString(i, tempString);										OutLine(concat(tempString, '  - ', intMessStuff^^.forums[i]), true, 0);									end;								end;								bCR;								bCR;								HelpNum := 7;								NumbersPrompt('Configure Q-scan for which forum ? ', '', 9, 0);								DefaultDo := DefaultEleven;							end;							'7': 							begin								YesNoQuestion('Change password? ', false);								DefaultDo := DefaultSeven;							end;							otherwise								DefaultDo := DefaultTwo;						end;					end					else						DefaultDo := DefaultTwo;				end;				DefaultFour: 				begin					if CurPrompt = 'Y' then						thisUser.PauseScreen := true					else						thisUser.PauseScreen := false;					bCR;					DefaultDo := DefaultTwo;				end;				D18: 				begin					if length(curPrompt) > 0 then					begin						if curPrompt <> 'Q' then						begin							StringToNum(curPrompt, tempint);							if (tempint > -1) and (tempint < 8) then							begin								crossInt := tempInt;								ListColors;								bCR;								bCR;								NumbersPrompt('Foreground?', '', 7, 0);								DefaultDo := D19;							end							else								DefaultDo := DefaultTwo;						end						else							DefaultDo := DefaultTwo;					end					else						DefaultDo := DefaultTwo;				end;				D25: 				begin					stringToNum(curPrompt, tempint);					GetIndString(tempString, 15, tempInt);					if (length(tempString) > 0) then					begin						thisUser.computerType := tempString;						bCR;					end;					DefaultDo := DefaultTwo;				end;				D19: 				begin					StringToNum(curPrompt, tempInt);					thisUser.foregrounds[8] := tempint;					NumbersPrompt('Background?', '', 7, 0);					DefaultDo := D20;				end;				D20: 				begin					StringToNum(curPrompt, tempInt);					thisUser.backGrounds[8] := tempint;					YesNoQuestion('Bold?', false);					DefaultDo := D21;				end;				D21: 				begin					if curPrompt = 'Y' then						thisUser.bolds[8] := true					else						thisUser.bolds[8] := false;					YesNoQuestion('Underlined?', false);					DefaultDo := D22;				end;				D22: 				begin					if curPrompt = 'Y' then						thisUser.underlines[8] := true					else						thisUser.underlines[8] := false;					bCR;					NumToString(thisUser.foregrounds[8], tempString);					NumToString(thisUser.backgrounds[8], tempString2);					OutLine(concat('Color #', tempString, ' on Color #', tempString2), true, 8);					if thisUser.bolds[8] then						OutLine(', Bold', false, 8);					if thisUser.underlines[8] then						OutLine(', Underlined', false, 8);					OutLine(' ', false, 0);					bCR;					bCR;					YesNoQuestion('Is this OK? ', false);					DefaultDo := D23;				end;				D23: 				begin					if curPrompt = 'Y' then					begin						thisUser.foregrounds[crossInt] := thisUser.foregrounds[8];						thisUser.backgrounds[crossInt] := thisUser.backgrounds[8];						if thisUser.bolds[8] then							thisUser.bolds[crossInt] := true						else							thisuser.bolds[crossint] := false;						if thisUser.underlines[8] then							thisUser.underlines[crossInt] := true						else							thisuser.underlines[crossint] := false;						OutLine('Color saved.', true, 0);					end					else						OutLine('Not saved.', true, 0);					bCR;					DefaultDo := DefaultThree;					Curprompt := '8';				end;				DefaultFive: 				begin					if CurPrompt = 'N' then					begin						thisUser.MailBox := false;						thisUser.ForwardedTo := -1;						DefaultDo := DefaultTwo;					end					else					begin						bCR;						LettersPrompt('Forward to which user? ', '', 31, false, false, true, char(0));						DefaultDo := DefaultSix;					end;				end;				Def14: 				begin					if length(curPrompt) = 0 then						thisUser.scrnWdth := 80					else					begin						StringToNum(curprompt, tempInt);						thisUser.scrnWdth := tempInt;					end;					bCR;					NumbersPrompt('How tall is your screen (lines, <CR>=24) ?', '', 80, 1);					DefaultDo := Def15;				end;				Def15: 				begin					if length(curPrompt) = 0 then						thisUser.scrnHght := 24					else					begin						StringToNum(curprompt, tempInt);						thisUser.scrnHght := tempInt;					end;					bCR;					bCR;					DefaultDo := DefaultTwo;				end;				Def16: 				begin					if (curPrompt = 'N') and thisUser.canANSI then						ANSIcode('0m');					if curPrompt = 'Y' then						thisUser.canANSI := true					else						thisUser.canANSI := false;					bCR;					if thisUser.canANSI then					begin						YesNoQuestion('Do you want color? ', false);					end					else						curprompt := 'N';					DefaultDo := Def17;				end;				Def17: 				begin					if curPrompt = 'Y' then						thisUser.ANSIColor := true					else						thisUser.ANSIColor := false;					bCR;					bCR;					DefaultDo := DefaultTwo;				end;				DefaultSix: 				begin					if FindUser(CurPrompt, tempUser2) then					begin						thisUser.MailBox := true;						thisUser.ForwardedTo := tempUser2.UserNum;						OutLine('Saved.', true, 0);						bCR;						bCR;						DefaultDo := DefaultTwo;					end					else					begin						thisUser.MailBox := false;						thisUser.ForwardedTo := -1;						OutLine('Forwarding reset.', true, 0);						bCR;						bCR;						DefaultDo := DefaultTwo;					end;				end;				DefaultSeven: 				begin					if CurPrompt = 'Y' then					begin						OutLine('You must now enter your current password.', true, 0);						bCR;						LettersPrompt(': ', '', 9, false, false, true, char(0));						DefaultDo := DefaultEight;					end					else					begin						bCR;						DefaultDo := DefaultTwo;					end;				end;				DefaultEight: 				begin					if CurPrompt = thisUser.password then					begin						bCR;						OutLine('Enter your new password, 3 to 9 characters long.', true, 0);						bCR;						LettersPrompt(': ', '', 9, false, false, true, 'X');						DefaultDo := DefaultNine;					end					else					begin						OutLine('Incorrect.', true, 0);						bCR;						bCR;						DefaultDo := DefaultTwo;					end;				end;				DefaultNine: 				begin					if length(curPrompt) < 3 then					begin						Outline('Your password must be at least 3 characters.', true, 0);						bCR;						curPrompt := thisUser.password;						DefaultDo := DefaultEight;					end					else					begin						EnteredPass := CurPrompt;						OutLine('Repeat password for verification.', true, 0);						bCR;						LettersPrompt(': ', '', 9, false, false, true, 'X');						DefaultDo := DefaultTen;					end;				end;				DefaultTen: 				begin					if EnteredPass = CurPrompt then					begin						thisUser.password := CurPrompt;						GetDateTime(thisUser.lastPWChange);						OutLine('Password changed.', true, 0);						sysopLog('      Changed Password.', 0);						bCR;						bCR;						DefaultDo := DefaultTwo;					end					else					begin						OutLine('VERIFY FAILED.', true, 0);						OutLine('Password not changed.', true, 0);						bCR;						bCR;						DefaultDo := DefaultTwo;					end;				end;				DefaultEleven: 				begin					StringToNum(curPrompt, tempint);					configForum := tempint;					if configForum = 0 then						configForum := 10;					if (thisUser.msgFrmAccess[configForum]) and (intMessStuff^^.numForums >= configForum) then					begin						OutLine('Boards to q-scan marked with ''*''', true, 0);						bCR;						for i := 1 to intMessStuff^^.numBoards[ConfigForum] do						begin							tb2 := true;							if intMessStuff^^.boards[configForum, i].restrict <> char(0) then								if thisUser.restrics[(byte(intMessStuff^^.boards[configForum, i].restrict) - byte(64))] then									tb2 := true								else									tb2 := false;							if tb2 and (thisUser.age >= intMessStuff^^.boards[configForum, i].minage) and (intMessStuff^^.boards[configForum, i].SLtoRead <= thisUser.SecLevel) then							begin								if thisUser.WhatNScan[configForum, i] then									tempString := '* '								else									tempString := '  ';								NumToString(i, tempString2);								tempString := concat(tempString, tempString2, '. ', intMessStuff^^.boards[configForum, i].name);								OutLine(tempString, true, 0);							end;						end;						bCR;						DefaultDo := DefaultTwelve;					end					else					begin						OutLine('Forum not available.', true, 0);						bCR;						bCR;						DefaultDo := DefaultTwo;					end;				end;				DefaultTwelve: 				begin					bCR;					OutLine('Enter sub-board identifier, or Q to Quit', true, 0);					bCR;					NumbersPrompt('Config: ', 'Q?', intMessStuff^^.numBoards[configForum], 1);					DefaultDo := DefaultThrt;				end;				DefaultThrt: 				begin					if (CurPrompt <> 'Q') and (curPrompt <> '?') then					begin						StringToNum(curPrompt, tempint);						if (intMessStuff^^.numBoards[configForum] >= tempInt) then						begin							if thisUser.whatNScan[configForum, tempInt] then								thisUser.whatNScan[configForum, tempInt] := false							else								thisUser.whatNScan[configForum, tempInt] := true;						end;						DefaultDo := DefaultTwelve;					end					else if CurPrompt = 'Q' then					begin						DefaultDo := DefaultTwo;						bCR;					end					else if curPrompt = '?' then					begin						NumToString(configForum, curprompt);						DefaultDo := DefaultEleven;					end;				end;				otherwise			end;		end;	end;	procedure DoMainMenu;		var			yaba, tempString2, tempString: str255;			count, tempInt: LongInt;			dumRect: rect;			abg: point;			dere: sfTypeList;			repo: SFReply;			tempChar, keyPr: char;			doneit, gotit, tempBool, tb2: boolean;			i, b: integer;			tempReal, tempReal2, tempReal3: real;			therealPort: grafPtr;			myR: real;			f: DecForm;			s: DecStr;	begin		with curglobs^ do		begin			keyPr := curPrompt[1];			if length(curPrompt) > 0 then			begin				if (keyPr >= char(48)) and (keyPr <= char(57)) and not inTransfer then				begin					StringToNum(curPrompt, tempInt);					tb2 := true;					if intMessStuff^^.boards[inforum, tempInt].restrict <> char(0) then						if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, tempInt].restrict) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.age >= intMessStuff^^.boards[inforum, tempint].minAge) and (intMessStuff^^.boards[inForum, tempint].SLtoRead <= thisUser.SecLevel) and (intMessStuff^^.numBoards[inForum] >= tempint) then						inSub := tempint					else						OutLine('Sub not available.', true, 0);					MainStage := Menutext;					exit(doMainMenu);				end				else if (keyPr >= char(48)) and (keyPr <= char(57)) and inTransfer then				begin					StringToNum(curPrompt, tempInt);					tb2 := true;					if intDLStuff^^.dr[tempInt].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[tempInt].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.age >= intDLStuff^^.dr[tempInt].minAge) and (intDLStuff^^.dr[tempint].minDSL <= thisUser.transferLevel) and (intDLStuff^^.numDirs > tempint) then						inDir := tempint					else						OutLine('Directory not available.', true, 0);					GoHome;					exit(doMainMenu);				end;				if length(curPrompt) = 2 then				begin					if curPrompt[2] = 'E' then					begin						HelpNum := 5;						BoardSection := MultiMail;						MultiDo := MultiOne;					end;				end				else if length(CurPrompt) > 2 then				begin					UprString(Curprompt, false);					if (curPrompt = '//SORT') then					begin						if (thisUser.coSysop) and inTransfer then						begin							YesNoQuestion('Sort all dirs? ', false);							BoardSection := Sort;							SortDo := SortOne;						end						else						begin							MainStage := MenuText;						end;					end					else if ((curPrompt = '//UEDIT') or (curPrompt = '//USEREDIT')) and (thisUser.coSysop) then					begin						SysopLog('      @Ran Uedit', 0);						BoardSection := UEdit;						UEDo := EnterUE;						MaxLines := 0;						crossint := thisUser.userNum;					end					else if (curprompt = '//MAILR') then					begin						if thisUser.secLevel = 255 then						begin							if not sysoplogon then								LettersPrompt('SY: ', '', 9, false, false, true, 'X');							BoardSection := ReadAll;							AllDo := AllOne;						end						else							GoHome;					end					else if (curPrompt = '//?') then					begin						if thisUser.coSysop then						begin							if LoadSpecialText(helpFile, 38) then							begin								if thisUser.canANSI then									doM(0);								BoardAction := ListText;								bCR;							end;						end;						GoHome;					end					else if (curPrompt = '//CHUSER') and (thisUser.secLevel = 255) then					begin						LettersPrompt('User to change to? ', '', 30, false, false, true, char(0));						BoardSection := ChUser;					end					else if (curPrompt = '//ACCESS') then					begin						OutLine('Class name to validate for:', true, 2);						bCR;						LettersPrompt(': ', '', 40, false, false, true, char(0));						BoardSection := AutoVal;						ValDo := Val1;					end					else if (curPrompt = '//EQUIT') then					begin						if (thisUser.coSysop) and (thisUser.secLevel = 255) then						begin							OutLine('Emergency quit engaged.', true, 6);							quit := 2;							BoardAction := none;						end						else							GoHome;					end					else if (CurPrompt = '//VER') then					begin						OutLine(CONCAT('Hermes BBS  - v', HERMES_VERSION), true, 2);						OutLine('', false, 0);						bCR;						OutLine('Written by Frank Price', true, 3);						bCR;						bCR;						BoardAction := none;					end					else if curPrompt = '//RESETC' then					begin						ResetUserColors(thisUser);					end					else if (curPrompt = '//UPLOADALL') then					begin						if inTransfer and sysopLogon then						begin							if ModalQuestion('Upload entire directory?', false, false) = 1 then							begin								tempString := intDLStuff^^.dr[InDir].path;								tempInDir := inDir;								UploadVref(tempString);							end;						end;						goHome;						boardAction := none;					end					else if (curPrompt = '//QSCAN') then					begin						for i := 1 to 10 do						begin							for tempInt := 1 to 30 do							begin								thisUser.LastMsgs[i, tempInt] := 0;							end;						end;						OutLine('Q-Scan pointers cleared.', true, 1);					end					else if (curPrompt = '//CATCHUP') then					begin						OutLine('Please wait, catching up...', true, 0);						for i := 1 to 10 do						begin							for tempInt := 1 to 30 do							begin								OpenBase(i, tempInt, false);								if curNumMess > 0 then									thisuser.lastmsgs[i, tempInt] := curBase^^[curNumMess - 1].qscnPtr;								CloseBase;							end;						end;						OutLine('done.', false, 0);					end					else if (curPrompt = '//STATS') then					begin						if thisUser.CoSysop then						begin							printSysopStats;							bCR;						end;					end					else if (curPrompt = '//CLS') then					begin						ClearScreen;						GoHome;					end					else if (curprompt = '//MOVE') then					begin						if inTransfer and (thisUser.CoSysop) then						begin							MoveDo := MoveOne;							BoardSection := MoveFiles;						end						else							GoHome;					end					else if (curprompt = '//REN') then					begin						if inTransfer and (thisUser.CoSysop) then						begin							HelpNum := 32;							RenDo := RenOne;							BoardSection := RenFiles;						end						else							GoHome;					end					else if (curPrompt = '//UPLOAD') then					begin						if not inTransfer then						begin							OutLine('You may now upload a message, max 15000 bytes.', true, 0);							bCR;							UpMess := MessUpOne;							BoardSection := MessUp;						end						else							GoHome;					end					else if (curPrompt = '//LOAD') then					begin						if not inTransfer and sysopLogon then						begin							SetPT(abg, 40, 40);							dere[0] := 'TEXT';							SFGetFile(abg, 'Load which file?', nil, 1, dere, nil, repo);							if repo.good then							begin								result := FSDelete('Local Workspace', 0);								useWorkspace := 1;								tempString := PathNameFromWD(repo.vRefNum);								tempString := concat(tempString, repo.fName);								if copy1File(tempString, 'Local Workspace') = noErr then									;								OutLine('Message loaded.  The next post or email will contain that text.', true, 0);								bCR;							end;							goHome;						end						else							goHome;					end					else if (CurPrompt = '//LOG') then					begin						if thisUser.CoSysop then						begin							if ReadTextFile('Today Log', 0, true) then							begin								BoardAction := ListText;								prompting := false;								ListTextFile;							end							else							begin								OutLine('Today Log file not found.', true, 0);							end;						end;					end					else if (CurPrompt = '//ZLOG') then					begin						if thisUser.CoSysop then						begin							if ReadTextFile('Usage Record', 0, true) then							begin								BoardAction := ListText;								prompting := false;								ListTextFile;							end							else							begin								OutLine('Usage Record file not found.', true, 0);							end;						end;					end					else if (CurPrompt = '//YLOG') then					begin						if thisUser.CoSysop then						begin							Date2Secs(intSystRec.lastMaint, tempint);							IUDateString(tempint - 86400, shortDate, tempstring);							if ReadTextFile(concat(sharedPath, 'Logs:', tempstring), 0, false) then							begin								BoardAction := ListText;								prompting := false;								ListTextFile;							end							else							begin								OutLine('Yesterday Log file not found.', true, 0);							end;						end;					end;				end				else if length(curPrompt) = 1 then					if not inTransfer then					begin						case keyPr of							'O': 							begin								BoardSection := OffStage;								OffDo := SureQuest;								HelpNum := 12;							end;							'*': 								PrintSubList(inForum);							'K': 							begin								BoardSection := Killmail;								KillDo := KillOne;								HelpNum := 23;							end;							'G': 							begin								BoardSection := GFiles;								GFileDo := G1;								HelpNum := 23;							end;							'S': 							begin								tb2 := true;								if intMessStuff^^.boards[inforum, inSub].restrict <> char(0) then									if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, inSub].restrict) - byte(64))] then										tb2 := true									else										tb2 := false;								if tb2 and (thisUser.msgFrmAccess[inForum]) and (thisUser.age >= intMessStuff^^.boards[inforum, inSub].minage) and (intMessStuff^^.boards[inForum, inSub].SLtoRead <= thisUser.SecLevel) then								begin									BoardSection := QScan;									QDo := QFive;									threadMode := false;									HelpNum := 11;								end								else								begin									OutLine('You can''t read the messages here.', true, 0);									GoHome;								end;							end;							'R': 							begin								HelpNum := 15;								if (thisUser.msgFrmAccess[inForum]) and (intMessStuff^^.numBoards[inForum] >= inSub) then								begin									BoardSection := Rmv;									RmvDo := RmvOne;								end								else								begin									OutLine('Sub not available.', true, 0);									GoHome;								end;							end;							'+', '>': 							begin								if (intMessStuff^^.numBoards[inForum] > inSub) and (thisUser.msgFrmAccess[inForum]) then								begin									i := inSub;									gotit := false;									repeat										i := i + 1;										tb2 := true;										if intMessStuff^^.boards[inforum, i].restrict <> char(0) then											if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, i].restrict) - byte(64))] then												tb2 := true											else												tb2 := false;										if tb2 and (thisUser.age >= intMessStuff^^.boards[inforum, i].minage) and (intMessStuff^^.boards[inForum, i].SLtoRead <= thisUser.SecLevel) then										begin											inSub := i;											gotIt := true;										end;									until (i = intMessStuff^^.numBoards[inForum]) or GotIt;									if not GotIt then										OutLine('Sub not available', true, 0);								end								else									OutLine('Sub not available', true, 0);								GoHome;							end;							'-', '<': 							begin								if (inSub > 1) and (thisUser.msgFrmAccess[inForum]) then								begin									i := inSub;									gotit := false;									repeat										i := i - 1;										tb2 := true;										if intMessStuff^^.boards[inforum, i].restrict <> char(0) then											if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, i].restrict) - byte(64))] then												tb2 := true											else												tb2 := false;										if tb2 and (thisUser.age >= intMessStuff^^.boards[inforum, i].minage) and (intMessStuff^^.boards[inForum, i].SLtoRead <= thisUser.SecLevel) then										begin											inSub := i;											gotIt := true;										end;									until (i = 1) or GotIt;									if not GotIt then										OutLine('Sub not available', true, 0);								end								else									OutLine('Sub not available', true, 0);								GoHome;							end;							'I': 							begin								bCR;								bCR;								if ReadTextFile('BBS Info', 1, false) then								begin									ClearScreen;									boardAction := ListText;									ListTextFile;								end								else								begin									OutLine('''BBS Info'' file not found.', true, 0);								end;							end;							'N', 'Z': 							begin								if KeyPr = 'Z' then									inZScan := true								else									inZScan := false;								if thisUser.msgFrmAccess[inForum] then								begin									OutLine('<< Q-Scan All >>', true, 3);									bCR;									BoardSection := QScan;									QDo := Qone;									saveInForum := inForum;									saveInsub := inSub;									threadMode := false;									inNScan := true;									inSub := 0;									inForum := 0;									repeat										inforum := inforum + 1;									until (thisUser.msgFrmAccess[inForum]) or (inForum = 10);									readMsgs := true;								end								else								begin									OutLine('You can''t read the messages here.', true, 0);									GoHome;								end;							end;							'Q': 							begin								tb2 := true;								if intMessStuff^^.boards[inforum, inSub].restrict <> char(0) then									if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, inSub].restrict) - byte(64))] then										tb2 := true									else										tb2 := false;								if tb2 and (thisUser.msgFrmAccess[inForum]) and (thisUser.age >= intMessStuff^^.boards[inforum, inSub].minage) and (intMessStuff^^.boards[inForum, inSub].SLtoRead <= thisUser.SecLevel) then								begin									threadMode := false;									saveInforum := inForum;									saveInSub := inSub;									BoardSection := QScan;									QDo := Qone;								end								else								begin									OutLine('You can''t read the messages here.', true, 0);									GoHome;								end;							end;							'@': 							begin								BoardSection := ScanNew;								ScanNewDo := Scan1;								curPrompt := 'Y';							end;							'W': 							begin								BoardSection := Noder;								NodeDo := NodeOne;							end;							'.': 							begin								BoardSection := EXTERNAL;								activeuserExternal := -1;							end;							'J': 							begin								PrintForumList;								bCR;								NumbersPrompt('Jump to ? ', '', 9, 0);								BoardSection := ReadMail;								ReadDo := JumpForum;							end;							'U': 							begin								if not thisUser.restrics[8] then								begin									bCR;									BoardSection := USList;									crossInt3 := 0;									crossInt := 0;									YesNoQuestion('List only users with access to this sub? ', false);								end;							end;							'X': 							begin								thisUser.Expert := not thisUser.Expert;							end;							'T': 							begin								closeBase;								if not (thisUser.transferLevel < intSystrec.newDSL) and not (intSystRec.closedTransfers) then								begin									if isPostRatioOK or (not thisUser.restrics[4]) then									begin										if (thisUser.onToday = 1) and ((not readMsgs) and intSystRec.mustRead) and not (thisUser.coSysop) then										begin											Outline(retinstr(18, 47), true, 6);											OutLine(retinstr(18, 48), true, 6);											Outline(retinstr(18, 49), true, 6);											GoHome;										end										else										begin											inTransfer := true;											bCR;										end;									end									else									begin										myR := 1 / intSystRec.secLevels[thisUser.seclevel].postRatioOneTo;										F.style := FixedDecimal;										F.digits := 2;										Num2Str(f, myR, s);										tempString := s;										OutLine(concat(retinstr(18, 50), tempstring, '.'), true, 0);										GoHome;									end;								end								else								begin									OutLine(retinstr(18, 51), true, 0);									GoHome;								end;							end;							'Y': 							begin								ClearScreen;								PrintUserStuff;							end;							'A': 							begin								BoardSection := Amsg;								AutoDo := AutoOne;								HelpNum := 19;							end;							'L': 							begin								bCR;								if ReadTextFile('Brief Log', 0, true) then								begin									boardAction := ListText;									ListTextFile;								end								else								begin									OutLine('Brief Log file not found.', true, 0);									GoHome;								end;							end;							'B': 							begin								BoardSection := BBSlist;								BBSldo := Bone;								HelpNum := 25;							end;							'F': 							begin								BoardSection := EMail;								EmailDo := EmailOne;								CurPrompt := '1';								sentAnon := false;								callFMail := false;							end;							'C': 							begin								BoardSection := ChatStage;								ChatDo := ChatOne;								HelpNum := 3;							end;							'D': 							begin								BoardSection := Defaults;								DefaultDo := DefaultOne;								HelpNum := 4;							end;							'E': 							begin								BoardSection := Email;								EmailDo := WhichUser;								HelpNum := 14;							end;							'P': 							begin								HelpNum := 6;								BoardSection := Post;								PostDo := PostOne;								reply := false;								replytoStr := 'All';							end;							'M': 							begin								BoardSection := ReadMail;								ReadDo := ReadOne;							end;							'?': 							begin								MainStage := TextForce;							end;							otherwise						end;					end					else					begin						case keyPr of							'?': 								MainStage := TextForce;							'+', '>': 							begin								if intDLstuff^^.numDirs > (inDir + 1) then								begin									tb2 := true;									if intDLStuff^^.dr[inDir + 1].restriction <> char(0) then										if thisUser.restrics[(byte(intDLStuff^^.dr[inDir + 1].restriction) - byte(64))] then											tb2 := true										else											tb2 := false;									if tb2 and (intDLstuff^^.dr[inDir + 1].minDSL <= thisUser.SecLevel) and (thisUser.age >= intDLStuff^^.dr[inDir + 1].minAge) then									begin										inDir := inDir + 1;									end									else										Outline(retinstr(18, 52), true, 0);								end								else									OutLine(retinstr(18, 52), true, 0);								GoHome;								bCR;							end;							'-', '<': 							begin								if inDir > 0 then								begin									tb2 := true;									if intDLStuff^^.dr[inDir + 1].restriction <> char(0) then										if thisUser.restrics[(byte(intDLStuff^^.dr[inDir + 1].restriction) - byte(64))] then											tb2 := true										else											tb2 := false;									if tb2 and (intDLstuff^^.dr[inDir - 1].minDSL <= thisUser.SecLevel) and (thisUser.age >= intDLStuff^^.dr[inDir - 1].minAge) then									begin										inDir := inDir - 1;									end									else										Outline(retinstr(18, 52), true, 0);								end								else									OutLine(retinstr(18, 52), true, 0);								MainStage := MenuText;								bCR;							end;							'P': 							begin								IUDateString(lastFScan, shortDate, tempstring);								Outline(concat(retinstr(17, 12), tempString), true, 0);								OutLine(retinstr(18, 53), true, 0);								OutLine(retinstr(18, 54), true, 0);								bCR;								HelpNum := 13;								LettersPrompt(': ', '', 8, false, false, true, char(0));								BoardSection := limDate;							end;							'L': 							begin								BoardSection := ListFiles;								sysopStop := false;								ListDo := ListOne;							end;							'F': 							begin								BoardSection := ListFiles;								sysopStop := false;								ListDo := ListSeven;								OutLine('Find description -', true, 0);								bCR;								OutLine('Enter string to search for in file description:', true, 0);								bCR;								LettersPrompt(': ', '', 58, false, false, false, char(0));								HelpNum := 21;							end;							'S': 							begin								BoardSection := ListFiles;								sysopStop := false;								ListDo := ListSix;								BCR;								OutLine('Search all directories.', true, 3);								bCR;								bCR;								LettersPrompt('File mask: ', '', 20, false, false, false, char(0));							end;							'N': 							begin								ListDo := ListFive;								BoardSection := ListFiles;								bCR;								YesNoQuestion('Search all directories? ', false);							end;							'Y': 							begin								bCR;								ClearScreen;								NumToString(thisUser.uploadedK, tempString);								numToString(thisUser.numUploaded, tempString2);								OutLine(concat('Uploads    : ', tempString, 'k in ', tempString2, ' files'), true, 0);								NumToString(thisUser.downloadedK, tempString);								numToString(thisUser.numDownloaded, tempString2);								OutLine(concat('Downloads  : ', tempString, 'k in ', tempString2, ' files'), true, 0);								DLRatioStr(tempString2, activeNode);								OutLine(concat('Ratio      : ', tempString2), true, 0);								if (thisUser.restrics[3]) then								begin									GoodRatioStr(tempString2);									OutLine(concat('Ratio to DL: ', tempString2), true, 0);								end;								NumToString(thisUser.transferLevel, tempString2);								OutLine(concat('Your DSL   : ', tempString2), true, 0);								bCR;								MainStage := MenuText;							end;							'D': 							begin								BoardSection := Download;								DownDo := DownOne;								tempInDir := inDir;								HelpNum := 20;							end;							'U': 							begin								tempInDir := inDir;								BoardSection := Upload;								UploadDo := UpOne;							end;							'Z': 							begin								tempInDir := 0;								BoardSection := Upload;								UploadDo := UpOne;								OutLine('Sending file to sysop :-', true, 0);							end;							'T': 							begin								BoardSection := TranDef;								TransDo := TrOne;							end;							'C': 							begin								BoardSection := ChatStage;								ChatDo := ChatOne;							end;							'R': 							begin								BoardSection := RmvFiles;								RFDo := RFone;								HelpNum := 31;							end;							'M': 							begin								Helpnum := 26;								if (thisUser.coSysop) then								begin									BoardSection := MoveFiles;									MoveDo := MoveOne;								end								else									GoHome;							end;							'O': 							begin								BoardSection := OffStage;								OffDo := SureQuest;							end;							'X': 							begin								BoardSection := Batch;								BatDo := BatOne;								HelpNum := 22;							end;							'B': 							begin								BoardSection := Batch;								BatDo := BatOne;								HelpNum := 22;							end;							'*': 							begin								PrintDirList;								MainStage := MenuText;							end;							'Q': 							begin								inTransfer := false;								MainStage := MenuText;								CloseDirectory;							end;							otherwise						end;					end;			end;		end;	end;end.