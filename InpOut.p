unit InpOut;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, User, terminal, Message_Editor, SystemPrefs, nodeprefs, inpOut2;	procedure AnswerCall;	procedure HangupAndReset;	procedure LineChar (myChar: char);	procedure EnterMessage (maxLins: integer);	procedure OutLineSysop (goingOut: str255; NLatBegin: boolean);	function ReadTextFile (fileName: str255; storedAs: integer; insertPath: boolean): boolean;	procedure ListTextFile;	procedure ReprintPrompt;	procedure PromptUser (whichNode: integer);	procedure ClearScreen;	procedure LettersPrompt (prompt, accepted: str255; sizeLimit: integer; auto, wrap, capital: boolean; replace: char);	procedure YesNoQuestion (prompt: Str255; yesIsDefault: boolean);	procedure MainMenuPrompt (prompt: str255);	procedure NumbersPrompt (prompt, accepted: STR255; high, low: integer);	procedure PAUSEPrompt (prompt: str255);	procedure ListLine (whichLine: integer);	procedure GoWaitMode;	procedure DoLogon;	procedure Read_Mail;	procedure PrintCurEMail;	procedure BackSpace (howMany: integer);	procedure printSysopStats;	procedure DoChatshow (init, sysopSide: boolean; typed: char);	procedure ANSIprompter (numch: integer);	procedure OutChr (theChar: char);	procedure ConnectMade (serKe: char);	procedure DoHangup;	procedure CallUserExternal (message, whichOne: integer);	procedure MultinodeOutput (whatString: str255);implementation	procedure UserExternal (theHermStuff: UserXIPtr; PP: procptr);	inline		$205f,  	{   movea.l (a7)+,a0  }		$4e90;	{	jsr(a0)			   }	procedure CallUserExternal (message, whichOne: integer);	begin		theExtRec^.privates := handle(myExternals^^[whichOne].privatesNum);		theExtRec^.extID := whichOne;		theExtRec^.message := message;		theExtRec^.HSystPtr := @intSystRec;		theExtRec^.HMDescPtr := pointer(intMessStuff^);		theExtRec^.HDirDataPtr := pointer(intDLStuff^);		theExtRec^.HGFilePtr := pointer(intGFileHand^);		theExtRec^.HermUsers := myUsers;		theExtRec^.systemMail := theEmail;		UseResFile(myExternals^^[whichOne].UResoFile);		UserExternal(theExtRec, pointer(myExternals^^[whichOne].codeHandle^));		UseResFile(myResourceFile);		myExternals^^[whichOne].privatesNum := ord4(theExtRec^.privates);	end;	procedure toggleDTR (s: Boolean);		var			x: byte;			IOError: OSErr;	begin		x := 17;		if not s then			x := 18;		IOError := Control(curglobs^.outputRef, x, nil);	end;	procedure MultinodeOutput (whatString: str255);		var			savedNode, i: integer;			t1, t2: str255;			mySavedBD: BDact;	begin		for i := 1 to intSystRec.numNodes do		begin			if (theNodes[i]^.BoardMode = User) and not theNodes[i]^.myTrans.active and (theNodes[i]^.boardAction <> chat) and (theNodes[i]^.boardAction <> writing) and (i <> activeNode) then			begin				if (theNodes[i]^.thisUser.notifyLogon) then				begin					curGlobs := theNodes[i];					savedNode := activeNode;					activeNode := i;					with curglobs^ do					begin						mySavedBD := BoardAction;						BoardAction := none;						if thisUser.canANSI then						begin							NumToString(gBBSwindows[activeNode]^.cursor.h + 1, t1);							ANSICode(concat(t1, 'D'));							ANSICode('K');						end						else							bCR;						OutLine(whatString, false, 1);						BoardAction := mySavedBD;						bCR;						if BoardAction = Writing then							ListLine(online)						else if boardAction = Prompt then							ReprintPrompt;					end;					curGlobs := theNodes[savedNode];					activeNode := savedNode;				end;			end;		end;	end;	procedure DoHangup;		var			ts: str255;			i: integer;	begin		with curGlobs^ do		begin			case hangingUp of				0: 				begin					if (activeUserExternal > 0) and (BoardSection = External) then						CallUserExternal(closeNode, activeUserExternal);					if not sysopLogon then					begin						if (nodeType = 1) then						begin							ClearInBuf;							if useDTR then								toggleDTR(false);							crossLong := tickCount;							hangingUp := 1;						end						else						begin							CloseADSPConnection;							hangingUp := 4;						end;						MultinodeOutput(concat('< ', thisUser.userName, retinstr(17, 42), ' >'));					end					else						hangingUp := 4;					if visibleNode = activeNode then					begin						DisableItem(GetMHandle(mUser), 0);						DrawMenuBar;					end;				end;				1: 				begin					if useDTR and ((crossLong + 30) < tickCount) then					begin						toggleDTR(true);						TellModem('AT');						hangingUp := 4;					end					else if ((crossLong + 100) < tickCount) then					begin						ts := '   ';						for i := 1 to 3 do							ts[i] := char(1);						i := 3;						result := AsyncMWrite(outputRef, i, ptr(ord4(@ts) + 1));						hangingUp := 2;						crossLong := tickCount;					end;				end;				2: 				begin					if (crossLong + 100) < tickCount then					begin						TellModem('ATH0');						hangingUp := 4;					end;				end;				4: 				begin					if sysopLogon and goOffInLocal and (nodeType = 1) then						TellModem('ATH0');					hangingUp := 5;					EndUser;				end;				5: 				begin					result := FlushVol(nil, homeVol);					BoardMode := Failed;				end;				otherwise			end;		end;	end;	procedure HangupAndReset;		var			i: integer;			okay: boolean;			t1: longint;	begin		with curglobs^ do		begin			if (BoardMode = User) then			begin				if hangingUp < 0 then					hangingUp := 0;				DoHangup;			end			else			begin				hangingUp := -1;				InitAllVars;				if (nodeType = 2) then				begin					BoardMode := Waiting;					OutLineSysop(concat(char(12), 'Waiting for ADSP connection.'), false);					statChanged := true;				end				else				begin					OutLineSysop(concat(char(12), 'Waiting for modem, hold Command-. to abort...'), false);					i := 0;					okay := false;					if PrepModem then						okay := true;					if okay then						goWaitMode					else					begin						BoardMode := Failed;						bcr;						OutLineSysop('There seems to be a problem with the modem...', false);						OutLineSysop('It will be rechecked every 30 seconds, or press return.', true);						for i := 1 to 6 do							SysBeep(1);						statChanged := true;					end;				end;				if not answerCalls then				begin					if not held[activeNode] then					begin						if (nodeType = 1) then						begin							Delay(30, t1);							TellModem('ATM0H1');							held[activeNode] := true;						end;					end;				end;				lastTry := tickCount;			end;		end;	end;	procedure BackSpace (howMany: integer);		var			result: OSerr;			count: longint;			dumRect: rect;			ts: str255;			i: integer;	begin		with curglobs^ do		begin			ts := '';			for i := 1 to (3 * howMany) do				ts := concat(' ', ts);			ts := '';			count := 3 * howMany;			for i := 1 to howmany do				ts := concat(ts, char(8));			for i := 1 to howmany do				ts := concat(ts, char(32));			for i := 1 to howmany do				ts := concat(ts, char(8));			if not sysopLogon then				result := AsyncMWrite(outputRef, count, @ts[1]);			ProcessData(activeNode, @ts[1], count);		end;	end;	procedure MessToText (dispose: boolean);		var			l1, l2: longint;			tempFoot: str255;			i: integer;	begin		with curglobs^ do		begin			tempFoot := ' 0 ';			tempFoot[1] := char(3);			tempFoot[3] := char(13);			if curWriting <> nil then				DisposHandle(handle(curWriting));			curWriting := nil;			if onLine > 1 then			begin				curWriting := TextHand(NewHandle(30000));				HLock(handle(curWriting));				l1 := 0;				for i := 1 to (onLine - 1) do				begin					l2 := length(curMessage^^[i]);					BlockMove(@curMessage^^[i][1], @curWriting^^[l1], l2);					BlockMove(@tempfoot[1], @curWriting^^[l1 + l2], 3);					l1 := l1 + l2 + 3;				end;				L1 := L1 + 1;				curWriting^^[l1 - 1] := char(26);				HNoPurge(handle(curWriting));				HUnlock(handle(curWriting));				SetHandleSize(handle(curWriting), l1);				MoveHHi(handle(curWriting));			end;			if dispose then			begin				if curMessage <> nil then					DisposHandle(handle(curmessage));				curMessage := nil;			end;		end;	end;	procedure ListLine (whichLine: integer);		var			s, holdOut: str255;			i: integer;			templong: longint;	begin		with curglobs^ do		begin			s := curMessage^^[whichline];			s := concat(s, char(3), '0', CHAR(13));			i := 1;			holdOut := '';			if length(s) > 0 then			begin				while (s[i] <> char(13)) and (i <= length(s)) do				begin					if s[i] = char(3) then					begin						if length(holdOut) > 0 then						begin							OutLine(holdOut, false, -1);							holdOut := '';						end;						i := i + 1;						if (s[i] > char(47)) and (s[i] < char(56)) then						begin							StringToNum(s[i], templong);							if thisUser.canANSI then								doM(tempLong);						end;					end					else if (s[i] = char(8)) then					begin						if length(holdOut) > 0 then						begin							OutLine(holdOut, false, -1);							holdOut := '';						end;						backspace(1);					end					else if (s[i] > char(31)) then						holdOut := concat(holdOut, s[i]);					i := i + 1;				end;				if length(holdOut) > 0 then				begin					OutLine(holdOut, false, -1);					holdOut := '';				end;			end;		end;	end;	procedure CheckLine;		var			s, s2, s3, s4: str255;			done, lineNumbers, setNewLine: boolean;			i, b: integer;			l1: longint;	begin		with curglobs^ do		begin			done := false;			setNewLine := false;			if thisUser.canANSI then				doM(0);			s := copy(curmessage^^[onLine], 1, 2);			s2 := copy(curMessage^^[onLine], 1, 3);			s3 := copy(curMessage^^[onLine], 1, 4);			if (EqualString('/D', s, false, false)) then			begin				if (savedLine = -1) and (onLine > 1) then				begin					s4 := curMessage^^[online];					delete(s4, 1, 2);					StringToNum(s4, l1);					if (l1 > 0) and (l1 < onLine) then					begin						OutLine(concat('Replace line ', s4, ':'), true, 0);						SavedLine := onLine;						onLine := l1;						setNewLine := true;					end;				end;				Online := onLine - 1;			end			else if (EqualString('/SU', s2, false, false)) then			begin				if onLine > 1 then				begin					delete(curMessage^^[onLine], 1, 4);					i := pos('/', curmessage^^[online]);					if i > 0 then					begin						s4 := copy(curmessage^^[onLine], 1, i - 1);						delete(curmessage^^[online], 1, i);						b := pos(s4, curMessage^^[onLine - 1]);						delete(curmessage^^[onLine - 1], b, i - 1);						s4 := curMessage^^[online];						insert(s4, curMessage^^[online - 1], b);						OutLine('Last line:', true, 0);						bCR;						ListLine(online - 1);						onLine := online - 1;					end;				end;			end			else if (EqualString(s3, '/HEL', false, false)) then			begin				OutLine('Editor Commands:', true, 2);				bCR;				Outline('/ES - Immediate Save', true, 0);				OutLine('/ESY - Immediate Save Anonymous (If allowed)', true, 0);				OutLine('/ESN - Immediate Save NOT-Anonymous', true, 0);				Outline('/ABT - Immediate Abort', true, 0);				OutLine('/CLR - Clear Message and Start Over', true, 0);				OutLine('/RL - Replace Last Line', true, 0);				OutLine('/LI - List Message so far', true, 0);				OutLine('/LN - List Message with Line Numbers', true, 0);				OutLine('/C: - Center Rest of Line', true, 0);				OutLine('/D# - Edit Line Number (i.e. /D4 edits line 4)', true, 0);				OutLine('/SU/old/new - Substitute Text in Last Line', true, 0);				OutLine('Ctrl-P+Digit - Change Colors', true, 0);				bCR;				onLine := onLine - 1;			end			else if EqualString(s2, '/ES', false, false) or EqualString(s, '/S', false, false) or (EqualString(s, '*S', false, false)) then			begin				done := true;				endAnony := 0;				if length(curMessage^^[online]) > 2 then				begin					if EqualString(copy(curMessage^^[online], 4, 1), 'N', false, false) then						endAnony := -1					else if EqualString(copy(curMessage^^[online], 4, 1), 'Y', false, false) then						endAnony := 1;				end;				MessToText(true);			end			else if EqualString(s3, '/ABT', false, false) then			begin				curWriting := nil;				DisposHandle(handle(curMessage));				curmessage := nil;				done := true;			end			else if (EqualString('/CLR', s3, false, false)) then			begin				for i := 1 to maxLines do					curMessage^^[i] := '';				OutLine('Message cleared... Start over...', true, 0);				onLine := 0;				savedLine := -1;			end			else if (EqualString('/C:', s2, false, false)) then			begin				delete(curMessage^^[onLine], 1, 3);				i := 79 - length(curMessage^^[onLine]);				i := i div 2;				for b := 1 to i do					curMessage^^[online] := concat(' ', curMessage^^[onLine]);			end			else if (EqualString('/RL', s2, false, false)) then			begin				if onLine > 1 then				begin					OutLine('Replace:', true, 0);					onLine := online - 2;				end				else				begin					OutLine('Nothing to replace.', true, 0);					online := online - 1;				end;			end			else if (EqualString('/L', s, false, false)) then			begin				if onLine > 1 then				begin					if (EqualString('/LN', s2, false, false)) then						lineNumbers := true					else						linenumbers := false;					for i := 1 to (onLine - 1) do					begin						NumToString(i, s4);						if lineNumbers then							OutLine(concat('Line: ', s4), true, 0);						bCR;						ListLine(i);					end;					OutLine('Continue...', true, 0);					bCR;					lnsPause := 0;				end;				onLine := onLine - 1;			end;			if not done then			begin				bCR;				if (onLine + 5) = maxLines then				begin					OutLine('5 lines left.', false, 0);					bCR;				end;				if (online + 1) > maxLines then				begin					OutLine('-= No more lines =-', false, 0);					OutLine('/ES to save.', true, 0);					bCR;					online := online - 1;				end;				if length(excess) > 0 then					OutLine(excess, false, 0);				if not setnewLine and (savedLine > -1) then				begin					Online := savedLine;					savedLine := -1;				end				else					onLine := onLine + 1;				curMessage^^[onLine] := '';				curMessage^^[onLine] := concat(curMessage^^[onLine], excess);			end			else if done then				boardAction := none;		end;	end;	procedure LineChar (myChar: char);		var			tempstring, s: str255;			temppos: integer;			templong: longint;	begin		with curglobs^ do		begin			LnsPause := 0;			if myChar = char(127) then				myChar := char(8);			if (mychar <> char(13)) and ((gBBSwindows[activeNode]^.cursor.h < (thisUser.scrnWdth - 1)) or (myChar = char(8))) then			begin				if (curMessage^^[online][length(curMessage^^[online])] = char(3)) then				begin					if (length(curMessage^^[online]) < 161) and (mychar >= char(48)) and (mychar <= char(55)) then					begin						curMessage^^[onLine] := concat(curMessage^^[onLine], myChar);						StringToNum(mychar, templong);						if thisUser.canANSI then							doM(templong);					end					else						delete(curMessage^^[onLine], length(curMessage^^[online]), 1);				end				else if (Length(curMessage^^[onLine]) < 160) or (mychar = char(8)) then				begin					if mychar >= char(32) then					begin						curMessage^^[onLine] := concat(curMessage^^[onLine], myChar);						OutLine(mychar, false, -1);					end					else if (myChar = char(8)) then					begin						s := curMessage^^[onLine];						if length(s) > 0 then						begin							if s[length(s) - 1] = char(3) then							begin								delete(s, length(s) - 1, 2);								if thisUser.canANSI then									doM(0);							end							else if (s[length(s)] = char(8)) then							begin								delete(s, length(s), 1);								OutLine(' ', false, -1);							end							else							begin								backspace(1);								delete(s, length(s), 1);							end;						end;						curMessage^^[onLine] := s;					end					else if (mychar = char(24)) then					begin						if gBBSwindows[activeNode]^.cursor.h > 0 then							backspace(gBBSwindows[activeNode]^.cursor.h);						curMessage^^[onLine] := '';						if thisUser.canANSI then							doM(0);					end					else if (myChar = char(14)) then					begin						if gBBSwindows[activeNode]^.cursor.h > 0 then						begin							curMessage^^[onLine] := concat(curMessage^^[onLine], char(8));							outChr(char(8));						end;					end					else if (mychar = char(16)) then					begin						curMessage^^[onLine] := concat(curMessage^^[online], char(3));					end					else if (mychar = char(9)) then					begin						if ((4 + length(curMessage^^[onLine]) < 160)) then						begin							curMessage^^[onLine] := concat(curMessage^^[onLine], '    ');							OutLine('    ', false, -1);						end;					end;				end;			end			else			begin				if mychar <> char(13) then				begin					excess := '';					s := curMessage^^[onLine];					i := length(s);					while ((i > 1) and (s[i] <> char(32)) and (s[i] <> char(8)) and (s[i - 1] <> char(3))) do						i := i - 1;					if (i < (length(s))) and (i > (gBBSwindows[activeNode]^.cursor.h div 2)) then					begin						excess := copy(s, length(s) - (length(s) - i) + 1, length(s) - i);						excess := concat(excess, myChar);						backspace(length(s) - i);						delete(s, length(s) - (length(s) - i), (length(s) - i) + 1);						curMessage^^[onLine] := s;					end					else						excess := mychar;				end				else					excess := '';				CheckLine;			end;		end;	end;	procedure EnterMessage (maxLins: integer);		var			i: integer;			ts: str255;	begin		with curglobs^ do		begin			if curWriting <> nil then				disposHandle(handle(curWriting));			curWriting := nil;			if curmessage <> nil then				DisposHandle(handle(curMessage));			curMessage := nil;			if maxLins > 200 then				maxLins := 200;			if maxLins < 10 then				maxLins := 10;			maxLines := maxLins;			curMessage := messgHand(NewHandle(maxLines * 162));			if memError = noErr then			begin				HNoPurge(handle(curMessage));				MoveHHi(handle(curMessage));				maxLines := maxLins;				onLine := 1;				savedLine := -1;				for i := 1 to maxLines do					curmessage^^[i] := '';				NumToString(maxLins, ts);				OutLine(concat('Enter message now, max ', ts, ' lines.'), false, 0);				OutLine('Enter ''/HELP'' for help, ''/ES'' to save.', true, 0);				ts := '[---=----=----=----=----=----=----=----]----=----=----=----=----=----=----=----]';				if thisUser.scrnWdth < 80 then					delete(ts, thisUser.scrnWdth, 80 - thisUser.scrnWdth);				OutLine(ts, true, 0);				bCR;				bCR;				lnsPause := 0;				BoardAction := Writing;			end			else			begin				OutLine('Out of memory!', true, 0);				BoardAction := none;			end;		end;	end;	procedure GetScrnLineToStr (num, scrnNum: integer; var ts: str255);		var			i: integer;	begin		with gBBSwindows[num]^ do		begin			ts := '';			for i := 1 to 80 do				ts := concat(ts, ' ');			BlockMove(@screen[(topLine + scrnNum) mod 24, 0], pointer(ord4(@ts) + 1), 80);		end;	end;	procedure ScrollChatSide (num: integer; sysopSide: boolean);		var			i: integer;			t1: str255;	begin		with curGlobs^ do		begin			if sysopSide then			begin				ANSIcode('H');				for i := 1 to 6 do				begin					GetScrnLineToStr(activeNode, i + 5, t1);					OutLine(concat(char(27), '[K', t1), false, -1);					bCR;				end;				for i := 6 to 11 do				begin					NumToString(i + 1, t1);					ANSIcode(concat(t1, 'H'));					ANSIcode('K');				end;				ANSIcode(concat('7H'));			end			else			begin				ANSIcode('14H');				for i := 1 to 6 do				begin					GetScrnLineToStr(activeNode, i + 16, t1);					OutLine(concat(char(27), '[K', t1), false, -1);					bCR;				end;				for i := 20 to 24 do				begin					NumToString(i, t1);					ANSIcode(concat(t1, 'H'));					ANSIcode('K');				end;				ANSIcode('20H');			end;		end;	end;	procedure DoChatShow (init, sysopSide: boolean; typed: char);		var			t1, t2, s: str255;			i, i1: INTEGER;			tempPt: point;			intwowaychat: boolean;	begin		with curglobs^ do		begin			inTwoWayChat := intSystRec.twoWayChat and thisUser.canANSI;			LnsPause := 0;			if typed = char(127) then				typed := char(8);			if init then			begin				bCR;				if inTwoWayChat then				begin					ANSICode('2J');					gBBSwindows[activeNode]^.saveH := 0;					gBBSwindows[activeNode]^.saveV := 13;					ANSICode('13;1H');					t1 := '';					for i := 1 to thisUser.scrnWdth do						t1 := concat(t1, char(205));					OutLine(t1, false, 3);					t1 := concat(' ', myUsers^^[0].Uname, ' chatting with ', thisUser.userName, ' ');					NumToString((thisUser.scrnWdth - length(t1)) div 2, t2);					ANSICode(concat('13;', t2, 'H'));					OutLine(t1, false, 4);					ANSICode('H');					chatKeySysop := true;				end				else				begin					ClearScreen;					gBBSwindows[activeNode]^.saveH := $FFFF;					gBBSwindows[activeNode]^.saveV := $FFFF;					OutLine(concat(myUsers^^[0].UName, '''s here ... '), false, 1);					bCR;					bCR;					chatKeySysop := true;				end;				if intSystRec.twoColorchat then					OutLine('', false, 1)				else					OutLine('', false, 0);			end  {init chat}			else			begin				if inTwoWayChat and (sysopSide <> chatKeySysop) then				begin					NumToString(gBBSwindows[activeNode]^.saveV + 1, t1);					NumToString(gBBSwindows[activeNode]^.saveH + 1, t2);					gBBSwindows[activeNode]^.saveV := gBBSwindows[activeNode]^.cursor.v;					gBBSwindows[activeNode]^.saveH := gBBSwindows[activeNode]^.cursor.h;					ANSIcode(concat('[', t1, ';', t2, 'H'));					chatKeySysop := not chatKeySysop;					if intSystRec.twoColorChat then					begin						if chatKeySysop then							OutLine('', false, 1)						else							OutLine('', false, 5);					end;				end;				if (gBBSwindows[activeNode]^.cursor.h = 79) and (typed <> char(8)) and (typed <> char(13)) then				begin					excess := '';					GetScrnLineToStr(activeNode, gBBSwindows[activeNode]^.cursor.v, s);					delete(s, 80, 1);					i := 79;					while ((i > 1) and (s[i] <> char(32))) do						i := i - 1;					if (i < 79) and (i > (gBBSwindows[activeNode]^.cursor.h div 2)) then					begin						excess := copy(s, length(s) - (length(s) - i) + 1, length(s) - i);						excess := concat(excess, typed);						backspace(length(s) - i);						delete(s, length(s) - (length(s) - i), (length(s) - i) + 1);					end					else						excess := typed;					t1 := excess;					if inTwoWayChat and sysopSide and (gBBSwindows[activeNode]^.cursor.v = 11) then						ScrollChatSide(activeNode, true)					else if inTwoWayChat and not sysopSide and (gBBSwindows[activeNode]^.cursor.v = 22) then						ScrollChatSide(activeNode, false)					else						bCR;					OutLine(t1, false, -1);				end				else if typed = char(8) then				begin					backspace(1);				end				else if typed = char(13) then					bCR				else if typed = char(7) then					OutChr(char(7))				else if (typed < char(127)) and (typed > char(31)) or (typed > char(127)) then				begin					OutLine(typed, false, -1);				end;				if inTwoWayChat and sysopSide and (gBBSwindows[activeNode]^.cursor.v = 12) then				begin					ScrollChatSide(activeNode, true);				end;				if inTwoWayChat and not sysopSide and (gBBSwindows[activeNode]^.cursor.v = 23) then				begin					ScrollChatSide(activeNode, false);				end;			end;{ key showing sequence}		end; {curGlobs}	end;	procedure printSysopStats;		var			tempString, tempString2: str255;			templong: longInt;	begin		BufClearScreen;		tempString := concat('New User Pass   : ', intSystRec.newUserPass);		bufferIt(tempString, true, 0);		if intSystRec.closed then			tempString := 'Board is        : Closed'		else			tempString := 'Board is        : Open';		bufferIt(tempString, true, 0);		NumToString(intSystRec.numUsers, tempString2);		tempString := concat('Number Users    : ', tempString2);		bufferIt(tempString, true, 0);		NumToString(intSystRec.numCalls, tempString2);		tempString := concat('Number Calls    : ', tempString2);		bufferIt(tempString, true, 0);		NumToString(intSystRec.callsToday, tempString2);		tempString := concat('Calls Today     : ', tempString2);		bufferIt(tempString, true, 0);		NumToString(intSystRec.mPostedToday, tempString2);		tempString := concat('M Posted Today  : ', tempString2);		bufferIt(tempString, true, 0);		NumToString(intSystRec.eMailToday, tempString2);		tempString := concat('E Sent Today    : ', tempString2);		bufferIt(tempString, true, 0);		NumToString(intSystRec.uploadsToday, tempString2);		tempString := concat('Uploads Today   : ', tempString2);		bufferIt(tempString, true, 0);		NumToString(FreeMem, tempString2);		tempString := concat('Free Memory     : ', tempString2);		bufferIt(tempString, true, 0);		tempLong := FreeK(SharedPath);		tempLong := tempLong div 1024;		NumToString(tempLong, tempString);		bufferIt(concat('Disk Free Space : ', tempString, 'k'), true, 0);		ReleaseBuffer;	end;	procedure GoWaitMode;	begin		with curglobs^ do		begin			BoardMode := Waiting;			gBBSwindows[activeNode]^.curStyle := defaultStyle;			if TabbyPaused then				OutLineSysop(concat(char(27), '[H', char(27), '[KWaiting for mailer...'), false)			else				OutLineSysop(concat(char(27), '[H', char(27), '[KWaiting...'), false);			statChanged := true;		end;	end;	procedure AnswerCall;		var			count: longInt;			yaba: str255;			connected, i: integer;	begin		with curglobs^ do		begin			OutLineSysop('*Call detected...press ''H'' to abort answering.', false);			BoardMode := Answering;			frontcharElim := 0;			lastKeyPressed := tickCount;		end;	end;	procedure DoLogon;		var			q: longInt;			ReadItIn: boolean;			WelcomeName, tempString: str255;			tempInt: longint;	begin		with curglobs^ do		begin			NumToBaud(minBaud, tempInt);			if (currentBaud >= tempInt) or sysopLogon then			begin				if visibleNode = activeNode then				begin					EnableItem(GetMHandle(mUser), 0);					DrawMenuBar;				end;				lastKeyPressed := TickCount;				if not sysopLogon and (nodeType = 1) then				begin					repeat					until not UserHungUp or ((lastKeyPressed + 80) < tickCount);					if UserHungUp then					begin						HangupAndReset;						exit(doLogon);					end					else					begin						result := KillIO(inputRef);						result := KillIO(outputRef);					end;				end;				readItIn := false;				boardmode := user;				WelcomeName := '';				if ReadTextFile('Welcome', 1, false) then					readitin := true;				bCR;				bCR;				BoardSection := Logon;				BoardAction := ListText;				LogonStage := Welcome;				ClearScreen;				if readItIn then					ListTextFile				else				begin					BoardAction := none;					OutLine('Welcome file not found.', true, 0);				end;				NumRptPrompt := 3;			end			else			begin				boardmode := user;				sysopLogon := false;				delay(67, q);				bCR;				bCR;				NumToString(tempInt, tempString);				OutLine('This baud rate not supported.', true, 0);				OutLine(concat('Please upgrade your modem to at least ', tempString, ' baud.'), true, 0);				NumToString(currentBaud, tempString);				LogThis(concat('Attempted logon at ', tempString, ' baud.'), 0);				Delay(40, q);				HangupAndReset;			end;		end;	end;	procedure ConnectMade (serKe: char);		var			yaba, ts, noCarrier, t1: str255;			connected, i: integer;			count, tl: longint;	begin		with curglobs^ do		begin			if FrontCharElim = 1 then			begin				if serKe = char(13) then				begin					connected := -1;					NoCarrier := '3';					ts := AnsInProgress;					AnsInProgress := '';					for i := 1 to modemDrivers^^[modemID].numResults do					begin						NumToString(modemDrivers^^[modemID].rs[i - 1].num, t1);						if EqualString(t1, ts, false, false) then							connected := i;					end;					if connected = -1 then					begin						if EqualString(noCarrier, ts, false, false) then							connected := 10000;					end;					if (connected < 0) or (connected = 10000) then					begin						HangupAndReset;					end					else					begin						rsIndex := connected - 1;						currentBaud := modemDrivers^^[modemID].rs[rsIndex].portRate;						if matchInterface then							DoBaudReset(currentBaud);						curBaudNote := modemDrivers^^[modemID].rs[rsIndex].desc;						OutLineSysop(concat('Logging on at ', curBaudNote), true);						sysopLogon := false;						GetDateTime(tl);						IUTimeString(tl, true, ts);						LogThis(concat('Carrier detected: ', curBaudNote, ' at ', ts), 0);						DoLogon;					end;				end				else					ansInProgress := concat(ansInProgress, serKe);			end			else			begin				Delay(40, count);				yaba := concat(modemDrivers^^[modemID].ansModem, char(13));				count := length(yaba);				result := AsyncMWrite(outputRef, count, ptr(ord4(@yaba) + 1));				frontCharElim := 1;				ansInprogress := '';			end;		end;	end;	procedure PrintCurEMail;		var			tempString, tempString2, tempString3, tempString4, tempString5: str255;			tempDate: DateTimeRec;			totEm, numit: integer;			printMail: EmailRec;	begin		with curglobs^ do		begin			FindMyEmail;			totEm := GetHandleSize(handle(myEmailList)) div 2;			if atEmail >= totem then				atEmail := totem - 1;			if atEmail < 0 then				atEmail := 0;			if totEm > 0 then			begin				printMail := theEmail^^[myEmailList^^[atEmail]];				bCR;				if textHnd <> nil then					DisposHandle(handle(texthnd));				textHnd := nil;				textHnd := textHand(ReadMessage(TRUE, printMail.storedAs, 0, 0));				NumToString(atEMail + 1, tempString);				NumToString(totEm, tempString2);				tempString3 := concat('(', tempString, '/', tempString2, '): ', printMail.title);				OutLine(tempString3, true, 0);				if (printMail.anonyFrom) and not (thisUser.coSysop) then					OutLine('Name: >UNKNOWN<', true, 0)				else				begin					if not ((IntSystRec.TabbyNet) and (printMail.fromUser = TABBYTOID)) then					begin						NumToString(printMail.fromUser, tempString2);						if FindUser(tempString2, tempUser) then						begin							IUDateString(tempUser.lastOn, shortDate, Tempstring5);							NumToString(tempUser.UserNum, tempString3);							if (printMail.anonyFrom) and ((thisUser.coSysop) or (intSystRec.SecLevels[thisUser.SecLevel].readAnon)) then								tempString := concat('Name: <<<', tempuser.UserName, ' #', tempString3, '>>> Last on: ', tempString5)							else if (thisUser.coSysop) then								tempString := concat('Name: ', tempuser.UserName, ' #', tempString3, ' [ ', tempUser.realName, ' ]  Last on: ', tempString5)							else								tempString := concat('Name: ', tempuser.UserName, ' #', tempString3, ' Last on: ', tempString5);							OutLine(tempString, true, 0);						end						else							OutLine('Name: <<USER NOT FOUND>>', true, 0);					end					else					begin						curWriting := TextHand(textHnd);						tempstring5 := takeMsgTop;						textHnd := textHand(curWriting);						curWriting := nil;						if FindUser(tempstring5, tempUser) then							NumToString(tempuser.userNum, tempstring3)						else							tempstring3 := '';						if length(tempstring3) > 0 then							tempstring3 := concat(' #', tempstring3);						OutLine(concat('Name: ', tempstring5, tempstring3), true, 0);					end;				end;				IUDateString(printMail.dateSent, abbrevDate, tempstring3);				IUTimeString(printMail.dateSent, true, tempstring2);				if (printMail.anonyFrom) and not (thisUser.coSysop) then					tempstring := 'Date: >>INACTIVE<<'				else					tempString := concat('Date: ', tempString3, ' ', tempString2);				OutLine(tempString, true, 0);				bCR;				if textHnd <> nil then				begin					curtextPos := 0;					openTextSize := GetHandleSize(handle(texthnd));					BoardAction := ListText;					ListTextFile;				end				else					OutLine('Message not found.', true, 0);			end;		end;	end;	procedure ANSIprompter (numch: integer);		var			t1: str255;			i: integer;	begin		with curglobs^ do		begin			if thisUser.canANSI and thisUser.ANSIcolor then			begin				t1 := '';				for i := 1 to numch do				begin					t1 := concat(t1, ' ');				end;				OutLine(t1, false, 4);				NumToString(numCh, t1);				ANSIcode(concat(t1, 'D'));				myPrompt.inputColor := 4;			end;		end;	end;	procedure Read_Mail;		var			MailNums2, i, b, totEm: integer;			ts, ts2, ts3, tempString: str255;			printEmail: emailrec;	begin		with curglobs^ do		begin			FindMyEmail;			totEm := getHandleSize(handle(myEmailList)) div 2;			MailNums2 := 0;			if totEm > 0 then			begin				bufferIt('You have mail from:', true, 0);				bufferbCR;				for i := 1 to totEm do				begin					printEmail := theEmail^^[myEmailList^^[i - 1]];					b := i;					NumToString(printEmail.fromUser, ts);					mailNums2 := mailNums2 + 1;					NumToString(mailNums2, ts3);					NumToString(printEmail.fromUser, ts2);					if not (printEmail.fromUser = TABBYTOID) then					begin						if (not printEmail.anonyFrom) or (thisUser.coSysop) or (intSystRec.SecLevels[thisUser.SecLevel].readAnon) then							tempString := concat(ts3, '. ', MyUsers^^[printEmail.fromUser - 1].UName, ' #', ts2)						else							tempString := concat(ts3, '. >UNKNOWN<');						if myUsers^^[printEmail.fromUser - 1].dltd then							tempString := concat(ts3, '>>DELETED USER<<');					end					else					begin						tempstring := concat(ts3, '. NETWORK');					end;					tempString := concat(tempString, ' / ', printEmail.title);					bufferIt(tempString, true, 0);				end;				BoardSection := ReadMail;				ReadDo := ReadTwo;			end			else			begin				bufferIt('You have no mail.', true, 0);				GoHome;			end;			ReleaseBuffer;		end;	end;	procedure PromptUser (whichNode: integer);	begin		with theNodes[whichNode]^ do		begin			with myPrompt do			begin				lnsPause := 0;				if LogonStage < CheckStuff then				begin					HermesColor := -1;					InputColor := -1;				end;				OutLine(promptLine, false, HermesColor);				BoardAction := Prompt;				Prompting := true;				CurPrompt := '';			end;		end;	end;	procedure PAUSEPrompt (prompt: str255);	begin		with curglobs^ do		begin			with myPrompt do			begin				inPause := true;				promptLine := prompt;				allowedChars := '';				replaceChar := char(0);				Capitalize := true;				enforceNumeric := false;				autoAccept := true;				wrapAround := false;				wrapsonCR := false;				breakChar := char(0);				HermesColor := 3;				InputColor := 0;				numericLow := 0;				numericHigh := 0;				maxChars := 0;				KeyString1 := '';				KeyString2 := '';				KeyString3 := '';				PromptUser(activeNode);			end;		end;	end;	procedure MainMenuPrompt (prompt: str255);		var			t1: str255;	begin		with curglobs^ do		begin			with myPrompt do			begin				statChanged := true;				promptLine := prompt;				if inTransfer then					GetIndString(t1, 16, 1)				else					GetIndString(t1, 16, 2);				allowedChars := t1;				replaceChar := char(0);				Capitalize := true;				enforceNumeric := true;				autoAccept := true;				wrapAround := false;				wrapsonCR := true;				breakChar := '/';				HermesColor := 2;				InputColor := 0;				if thisUser.cosysop and inTransfer then					numericLow := 0				else					numericLow := 1;				if inTransfer then					numericHigh := intDLStuff^^.numDirs - 1				else					numericHigh := intMessStuff^^.numBoards[inForum] + 1;				maxChars := 16;				KeyString1 := '';				KeyString2 := '';				KeyString3 := '';				PromptUser(activeNode);			end;		end;	end;	procedure YesNoQuestion (prompt: STR255; yesIsDefault: boolean);	begin		with curglobs^ do		begin			with myPrompt do			begin				promptLine := prompt;				allowedChars := 'YN';				replaceChar := char(0);				Capitalize := true;				enforceNumeric := true;				autoAccept := true;				wrapAround := false;				wrapsonCR := true;				breakChar := char(0);				HermesColor := 5;				InputColor := 1;				numericLow := -1;				numericHigh := -1;				maxChars := 1;				KeyString1 := 'Yes';				if yesisDefault then					KeyString1 := concat(char(13), keyString1);				KeyString2 := 'No';				if not yesisDefault then					KeyString2 := concat(char(13), keyString2);				KeyString3[1] := char(0);				PromptUser(activeNode);			end;		end;	end;	procedure NumbersPrompt (prompt, accepted: STR255; high, low: integer);	begin		with curglobs^ do		begin			with myPrompt do			begin				promptLine := prompt;				allowedChars := accepted;				replaceChar := char(0);				Capitalize := true;				enforceNumeric := true;				autoAccept := true;				wrapAround := false;				wrapsonCR := true;				breakChar := char(0);				HermesColor := 2;				InputColor := 0;				numericLow := low;				numericHigh := high;				if high < 10 then					maxChars := 1				else if high < 100 then					maxChars := 2				else if high < 1000 then					maxChars := 3				else					MaxChars := 4;				KeyString1 := '';				KeyString2 := '';				KeyString3 := '';				PromptUser(activeNode);			end;		end;	end;	procedure LettersPrompt (prompt, accepted: str255; sizeLimit: integer; auto, wrap, capital: boolean; replace: char);	begin		with curglobs^ do		begin			with myPrompt do			begin				promptLine := prompt;				allowedChars := accepted;				replaceChar := replace;				Capitalize := capital;				enforceNumeric := false;				autoAccept := auto;				wrapAround := wrap;				wrapsonCR := true;				breakChar := char(0);				HermesColor := 2;				InputColor := 0;				numericLow := 0;				numericHigh := 0;				maxChars := sizeLimit;				KeyString1 := '';				KeyString2 := '';				KeyString3 := '';				PromptUser(activeNode);			end;		end;	end;	function ReadTextFile (fileName: str255; storedAs: integer; insertPath: boolean): boolean;		var			myHParmer: HParmBlkPtr;			myParmer: ParmBlkPtr;			myTempStr: str255;			myOSerr: OSerr;			SharedRef: integer;			fullResult: boolean;	begin		with curglobs^ do		begin			listingHelp := false;			fullResult := false;			if textHnd <> nil then			begin				HPurge(handle(texthnd));				DisposHandle(handle(textHnd));				textHnd := nil;			end;			if storedAs = 0 then			begin				if insertPath then					myTempStr := concat(sharedPath, filename)				else					myTempStr := fileName;				myHParmer := HParmBlkPtr(NewPtr(SizeOf(HParamBlockRec)));				myHParmer^.ioCompletion := nil;				myHParmer^.ioNamePtr := @myTempStr;				myHParmer^.ioVRefNum := 0;				myHParmer^.ioPermssn := fsRdPerm;				myHParmer^.ioMisc := nil;				myHParmer^.ioDirID := 0;				myOSerr := PBHOpen(myHParmer, false);				OpenTextRef := myHParmer^.ioRefNum;				if myHParmer^.ioResult = noErr then				begin					result := GetEOF(OpenTextRef, openTextSize);					result := SetFPos(OpenTextRef, fsFromStart, 0);					TextHnd := TextHand(NewHandle(openTextSize));					if memError = noErr then					begin						MoveHHi(handle(TextHnd));						HNoPurge(handle(TextHnd));						Result := FSRead(OpenTextRef, OpenTextSize, pointer(TextHnd^));					end					else						OpenTextSize := 0;					myParmer := ParmBlkPtr(NewPtr(sizeOf(ParamBlockRec)));					myParmer^.ioCompletion := nil;					myParmer^.ioRefNum := OpenTextRef;					myOSerr := PBClose(myParmer, false);					DisposPtr(ptr(myParmer));					fullResult := True;				end				else					fullResult := false;				DisposPtr(ptr(myHParmer));			end			else if storedAs = 1 then			begin				UseResFile(RShared);				myTempStr := concat('ANSI ', fileName);				if thisUser.canANSI then				begin					textHnd := TextHand(GetNamedResource('HTxt', myTempStr));					if textHnd = nil then						TextHnd := TextHand(GetNamedResource('HTxt', fileName));				end				else					TextHnd := TextHand(GetNamedResource('HTxt', fileName));				if (ResError = noErr) and (TextHnd <> nil) then				begin					OpenTextSize := SizeResource(handle(textHnd));					DetachResource(handle(texthnd));					MoveHHi(handle(texthnd));					HNoPurge(handle(textHnd));					fullResult := true;				end				else					fullResult := false;				UseResFile(myResourceFile);			end;			if fullResult then			begin				CurTextPos := 0;				InPause := false;				SysopStop := false;			end;		end;		readtextFile := FullResult;	end;	procedure ReprintPrompt;		var			i: integer;	begin		with curGlobs^ do		begin			with myPrompt do			begin				lnsPause := 0;				if LogonStage < CheckStuff then				begin					HermesColor := -1;					InputColor := -1;				end;				OutLine(promptLine, false, HermesColor);				BoardAction := Prompt;				Prompting := true;				if replaceChar = char(0) then					OutLine(curPrompt, false, inputColor)				else				begin					OutLine('', false, inputColor);					for i := 1 to length(curPrompt) do						OutLine(replaceChar, false, -1);				end;			end;		end;	end;	procedure ListTextFile;		const			speed = 400;		var			tBuf: CharsPtr;			built, i, simLnsPause: integer;			nowStyle: CharStyle;			num: longint;			tANSI: str255;	begin		with curGlobs^ do		begin			nowStyle := gBBSwindows[activeNode]^.curStyle;			tBuf := CharsPtr(NewPtr(speed * 2));			built := 0;			simLnsPause := LnsPause;			if listingHelp then				lnsPause := 0;			while ((simLnsPause < thisUser.scrnHght) or not thisUser.pauseScreen) and (built < speed - 1) and (curTextPos < OpenTextSize) and not sysopStop do			begin				if (textHnd^^[curTextPos] = char(13)) then				begin					simLnsPause := simLnsPause + 1;					tBuf^[built] := char(13);					tBuf^[built + 1] := char(10);					built := built + 2;				end				else if (textHnd^^[curTextPos] = char(3)) then				begin					curTextPos := curTextPos + 1;					if thisUser.canANSI then					begin						StringToNum(textHnd^^[curTextPos], num);						if (num >= 0) and (num <= 7) then						begin							DecodeM(num, nowStyle, tANSI);							nowStyle.fCol := thisUser.foregrounds[num];							nowStyle.bCol := thisUser.backgrounds[num];							nowStyle.bold := thisUser.bolds[num];							nowStyle.underline := thisUser.underlines[num];							for i := 1 to length(tANSI) do							begin								tBuf^[built] := tANSI[i];								built := built + 1;							end;						end;					end;				end				else if (textHnd^^[curTextPos] = char(27)) then				begin					if thisUser.canANSI then					begin						tBuf^[built] := textHnd^^[curTextPos];						built := built + 1;					end;				end				else if (textHnd^^[curTextPos] > char(31)) or (textHnd^^[curTextPos] >= char(14)) or (textHnd^^[curTextPos] <= char(6)) then				begin					tBuf^[built] := textHnd^^[curTextPos];					built := built + 1;				end;				curTextPos := curTextPos + 1;			end;			if built > 0 then			begin				if not sysopLogon then					result := AsyncMWrite(outputRef, built, ptr(tBuf));				ProcessData(activeNode, ptr(tBuf), built);			end;			if curTextPos >= openTextSize then			begin				if textHnd <> nil then				begin					HPurge(handle(TextHnd));					DisposHandle(handle(TextHnd));				end;				TextHnd := nil;				BoardAction := none;				if thisUser.canANSI then					doM(0);				bCR;				if listingHelp then				begin					listingHelp := false;					ReprintPrompt;				end;			end;			DisposPtr(ptr(tBuf));		end;	end;	procedure ClearScreen;		var			t1: str255;			c: longint;	begin		with curGlobs^ do		begin			if thisUser.screenClears then			begin				if thisUser.canANSI then					t1 := concat(char(27), '[2J', char(27), '[H')				else				begin					t1 := ' ';					t1[1] := char(12);				end;				c := length(t1);				if not sysopLogon then					result := AsyncMWrite(outputRef, c, ptr(ord4(@t1) + 1));				ProcessData(activeNode, @t1[1], c);			end;		end;	end;	procedure OutChr (theChar: char);		var			count: longInt;			result: OSerr;			tempString: str255;	begin		with curglobs^ do		begin			if (theChar <> char(12)) or thisUser.screenClears then			begin				if (theChar = char(12)) and (thisUser.canANSI) then				begin					OutLine(concat(char(27), '[2J', char(27), '[H'), false, -1);				end				else				begin					count := 1;					tempString := ' ';					tempString[1] := theChar;					if not sysopLogon then						result := AsyncMWrite(outputRef, count, @tempString[1]);					ProcessData(activeNode, @tempstring[1], count);				end;			end;		end;	end;	procedure OutLineSysop (goingOut: str255; NLatBegin: boolean);		var			count: longint;			i: integer;			tempRect: rect;			savePort: grafPtr;	begin		with curglobs^ do		begin			if NLatBegin then				bCR;			ProcessData(activeNode, @goingOut[1], length(goingOut));		end;	end;end.