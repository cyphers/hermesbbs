unit inpOut2;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, aliases, Initial, nodePrefs, systemPrefs, Message_Editor, user, Terminal;	procedure ContinueTrans;	function FragFile (path: str255): boolean;	function CallUtility (message: integer; extRecPtr: ptr; refCon: longint): OSerr;	procedure SysopFileConfigure;	procedure StartTrans;	procedure AbortTrans;	procedure SaveDirectory;	procedure bCR;	procedure DoUpdate (window: WindowPtr);	procedure AddExtended (theFil: filEntryRec; whichDir: integer);	procedure DeleteExtDesc (theFile: filEntryRec; whichDir: integer);	procedure OutLine (goingOut: str255; NLatBegin: boolean; typeLine: integer);	procedure GiveTime (tickstoGive: longint; multiplier: real; tellUser: boolean);	procedure AnsiCode (theCode: str255);	procedure DoM (typeL: integer);	procedure BufferIt (goingOut: str255; NLatBegin: boolean; typeLine: integer);	procedure ReleaseBuffer;	procedure BufClearScreen;	procedure bufferbcr;	procedure FileEntry (theFil: FilEntryRec; theDir: integer; var SizeinK: integer; atDirPos: integer);	procedure DecodeM (typeL: integer; nowStyle: CharStyle; var ts: str255);	function usemodaltime (theDialog: dialogPtr; var theEvent: eventRecord; var itemHit: integer): boolean;implementation	procedure SysCloseDirectory;	begin		if SysopOpenDir <> nil then		begin			HPurge(handle(SysopOpenDir));			DisposHandle(handle(SysopOpenDir));		end;		SysopDirNum := -1;		SysopOpenDir := nil;	end;	function SysOpenDirectory (whichDir: integer): boolean;		var			result: OSerr;			DirRef: integer;			tempLong: LongInt;			myHParmer: HParamBlockRec;			myParmer: ParamBlockRec;			tempString: str255;			s1: str255;	begin		SysOpenDirectory := false;		SysCloseDirectory;		SysopNumFiles := 0;		if intDLStuff^^.numDirs >= (whichDir) then		begin			tempString := concat(sharedPath, 'Data:', intDLStuff^^.dr[whichDir].dirName);			myHParmer.ioCompletion := nil;			myHParmer.ioNamePtr := @TEMPSTRING;			myHParmer.ioVRefNum := 0;			myHParmer.ioPermssn := fsRdPerm;			myHParmer.ioMisc := nil;			myHParmer.ioDirID := 0;			result := PBHOpen(@myHParmer, false);			if result = noErr then			begin				dirRef := myHParmer.ioRefNum;				result := SetFPos(DirRef, fsFromStart, 0);				result := GetEOF(DirRef, tempLong);				sysopOpenDir := aDirHand(NewHandle(tempLong));				if MemError = noErr then				begin					MoveHHi(handle(sysopOpenDir));					HNoPurge(handle(sysopOpenDir));					result := FSRead(dirRef, tempLong, pointer(sysopOpenDir^));					SysOpenDirectory := true;					SysopDirNum := whichDir;					SysopnumFiles := tempLong div SizeOf(filEntryRec);				end				else					sysopOpenDir := nil;				myParmer.ioCompletion := nil;				myParmer.ioRefNum := dirRef;				result := PBClose(@myParmer, false);			end;		end;	end;	procedure FileEntry (theFil: filEntryRec; theDir: integer; var SizeinK: integer; atDirPos: integer);		var			tempString: str255;			tempRef, tempInt: integer;			tempLong, tl2: longInt;			result: OSerr;			yyyy: handle;			hhh: HParamBlockRec;			savedOpenDir: integer;			ty: boolean;			tempFS: FSSpec;	begin		with curglobs^ do		begin			savedOpenDir := dirOpenNum;			CloseDirectory;			hhh.ioCompletion := nil;			if (pos(':', theFil.realFName) = 0) then				tempString := concat(intDLStuff^^.dr[theDir].path, theFil.realFName)			else				tempstring := theFil.realFName;			if (Gestalt(gestaltAliasMgrAttr, tempLong) = noErr) and (tempLong = 1) then			begin				result := FSMakeFSSpec(0, 0, tempString, tempFS);				hhh.ioVRefNum := tempFS.vrefnum;				hhh.ioDirID := tempFS.parID;				hhh.ioNamePtr := @tempstring;			end			else			begin				hhh.ioNamePtr := @tempString;				hhh.ioVRefNum := 0;				hhh.ioDirID := 0;			end;			hhh.ioFVersNum := 0;			hhh.ioFDirIndex := 0;			SizeInK := 0;			theFil.byteLen := 0;			if PBHGetFInfo(@hhh, false) = noErr then			begin				theFil.byteLen := hhh.ioFLLgLen + hhh.ioFLRLgLen;				SizeInK := theFil.byteLen div 1024 + 1;				if SizeinK < 0 then					SizeinK := 1;			end;			tempstring := concat(sharedPath, 'Data:', intDLStuff^^.dr[theDir].dirName);			result := FSOpen(tempstring, 0, tempRef);			if result <> noErr then			begin				result := Create(tempstring, 0, 'HRMS', 'DATA');				result := FSOpen(tempstring, 0, tempref);			end;			if atDirPos < 1 then			begin				result := GetEOF(tempRef, tempLong);				if (result = noErr) then				begin					yyyy := NewHandle(tempLong);					if memError = noErr then					begin						HLock(yyyy);						if (templong > 0) then							result := FSRead(tempRef, tempLong, pointer(yyyy^));						result := SetFPos(tempRef, fsFromStart, 0);						tl2 := SizeOf(filEntryRec);						result := FSWrite(tempRef, tl2, @theFil);						if (tempLong > 0) then							result := FSWrite(tempRef, tempLong, pointer(yyyy^));						HUnlock(yyyy);						DisposHandle(yyyy);					end					else						SysBeep(1);				end;			end			else			begin				result := SetFPos(tempRef, fsFromStart, SizeOf(filEntryRec) * (longInt(atDirPos) - 1));				tempLong := SizeOf(filEntryRec);				result := FSWrite(tempRef, tempLong, @theFil);			end;			result := FSClose(tempRef);			if savedOpenDir > -1 then				ty := OpenDirectory(savedOpenDir);		end;	end;	procedure FileDLd;		var			tempers: FilEntryRec;			tempEM: EmailRec;			tempInt: integer;			tsr: str255;			tempTime, count: longint;			emaildataref: integer;	begin		with curglobs^ do		begin			if (BoardSection = Batch) then			begin				tempindir := fileTransit^^.filesGoing[extTrans^^.filesDone + 1].fromDir;				curFil := fileTransit^^.filesGoing[extTrans^^.filesDone + 1].theFile;			end;			if OpenDirectory(tempIndir) then			begin				descSearch := false;				curDirPos := 0;				repeat					GetNextFile(tempIndir, curFil.flName, curDirPos, tempers, 0)				until (tempers.flname = '') or (tempers.flName = curFil.flName);				if (tempers.flName = curFil.flName) then				begin					tempers.numDLoads := tempers.numDLoads + 1;					GetDateTime(tempers.lastDL);					FileEntry(tempers, tempInDir, tempInt, curDirPos);					if tempers.uploaderNum <> 1 then					begin						if FindUser(tempers.uploadername, tempUser) then						begin							if (tempUser.userNum = tempers.uploaderNum) and not (tempUser.deleting) then							begin								GetDateTime(tempEM.dateSent);								tempEM.title := tempers.flName;								tempEM.fromUser := thisUser.userNum;								tempEM.touser := tempuser.userNum;								tempEM.anonyFrom := false;								tempEM.anonyTo := false;								tempEM.MType := 0;								tempEM.multimail := false;								tempEm.storedAs := 0;								for tempInt := 0 to 9 do									tempEM.reserved[tempint] := char(0);								SetHandleSize(handle(theEmail), GetHandleSize(handle(theEmail)) + SizeOf(emailRec));								BlockMove(@tempEm, @theEmail^^[availEmails], sizeof(emailrec));								availEmails := availEmails + 1;								emailDirty := true;							end;						end;					end;				end;			end;		end;	end;	function ProtocolCall (message: integer; ExtRecPtr: ptr; refcon: longint; PP: procptr): OSerr;	inline		$205f,  	{   movea.l (a7)+,a0  }		$4e90;	{	jsr(a0)			   }	function CallUtility (message: integer; extRecPtr: ptr; refCon: longint): OSerr;		var			utilHand: handle;	begin		utilHand := GetResource('PROC', 900);		if utilHand <> nil then		begin			MoveHHi(utilHand);			HLock(utilHand);			CallUtility := ProtocolCall(message, extRecPtr, refCon, StripAddress(pointer(utilHand^)));			HUnlock(utilHand);		end;	end;	procedure AddExtFile (Fname: str255; mabName: str255);	begin		with curglobs^ do		begin			HUnlock(handle(extTrans));			if extTrans^^.fileCount > 0 then				SetHandleSize(HANDLE(extTrans), GetHandleSize(handle(extTrans)) + SizeOf(pathsFilesRec));			extTrans^^.fPaths[extTrans^^.fileCount + 1].fname := NewString(fname);			extTrans^^.fPaths[extTrans^^.fileCount + 1].mbName := NewString(mabName);			extTrans^^.fPaths[extTrans^^.fileCount + 1].myVRef := 0;			extTrans^^.fPaths[extTrans^^.fileCount + 1].myDirID := 0;			extTrans^^.fPaths[extTrans^^.fileCount + 1].myFileID := 0;			extTrans^^.fileCount := extTrans^^.fileCount + 1;			HLock(handle(extTrans));		end;	end;	procedure StartTrans;		var			myCRHandle, aHandle: handle;			tempint, i, sharedRef: integer;			temprect: rect;			tems, T2, t3: str255;			thisEditText: TEHandle;			theDialogptr: dialogpeek;	begin		with curglobs^ do		begin			if BoardMode = User then				InitXFerRec			else if (BoardMode = Terminal) then			begin				DisableItem(getMHandle(mTerminal), 0);				DisableItem(getMHandle(1009), 0);				DrawMenuBar;			end;			lastCurBytes := 0;			if intSystRec.useXWind and (activeNode = visibleNode) and (gBBSwindows[activeNode]^.ansiPort <> nil) then			begin				SetDAFont(monaco);				transDilg := GetNewDialog(982, nil, pointer(-1));				tems := theProts^^.prots[activeProtocol].protoName;				if myTrans.sending then					tems := concat(tems, ' Send')				else					tems := concat(tems, ' Receive');				SetWTitle(transdilg, tems);				SetPort(transDilg);				TextFont(monaco);				TextSize(9);				SetDAFont(0);				ShowWindow(transDilg);				DrawDialog(transDilg);			end			else			begin				TransDilg := nil;				t2 := '^C to Cancel';				for i := 1 to 10 do					t2 := concat(char(205), t2, char(205));				t2 := concat(char(27), '[22H', t2, char(13), char(10), 'Transferring:');				for i := 1 to 30 do					t2 := concat(t2, ' ');				t2 := concat(t2, char(13), char(10));				for i := 1 to 40 do					t2 := concat(t2, ' ');				for i := 1 to 3 do					t2 := concat(char(13), char(10), t2);				ProcessData(activeNode, @t2[1], length(t2));			end;			protCodeHand := Get1Resource('PROC', theProts^^.prots[activeProtocol].resID);			if protCodeHand <> nil then			begin				DetachResource(protCodeHand);				MoveHHi(protCodeHand);				HLock(protCodeHand);				if (theProts^^.prots[activeProtocol].pFlags[SENDFLOW] and myTrans.sending) or (theProts^^.prots[activeProtocol].pFlags[RECEIVEFLOW] and not myTrans.sending) then					flowie(true)				else					flowie(false);				if visibleNode = activeNode then					DisableItem(getMHandle(mDisconnects), 0);				if (BoardMode = User) then				begin					if (BoardSection = Upload) or (BoardSection = Download) then					begin						tems := curFil.realFName;						if (pos(':', curFil.realFName) = 0) then							tems := concat(intDLStuff^^.dr[tempinDir].path, curFil.realFName)						else							tems := curFil.realFName;						AddExtFile(tems, curFil.flName);						if intDLStuff^^.dr[tempInDir].nonMacFiles = 1 then							extTrans^^.flags[useMacbinary] := false;					end					else if (BoardSection = Batch) then					begin						for i := 1 to fileTransit^^.numFiles do						begin							if (pos(':', fileTransit^^.filesGoing[i].theFile.realFName) = 0) then								AddExtFile(concat(intDLStuff^^.dr[fileTransit^^.filesGoing[i].fromDir].path, fileTransit^^.filesGoing[i].theFile.realFName), fileTransit^^.filesGoing[i].theFile.flName)							else								AddExtFile(fileTransit^^.filesGoing[i].theFile.realFName, fileTransit^^.filesGoing[i].theFile.flName);						end;					end					else if (BoardSection = MessUp) then						AddExtFile('Local Workspace', 'Local Workspace');				end;				startCPS := 0;				bUploadCompense := 0;				lastTransError := '';				t2 := extTrans^^.fPaths[1].fName^^;				i := length(t2);				t3 := '';				while (t2[i] <> ':') and (i > 0) do				begin					i := i - 1;				end;				if t2[i] = ':' then					t3 := copy(t2, i + 1, length(t2) - i)				else					t3 := t2;				if transDilg <> nil then				begin					GetDItem(transDilg, 6, tempInt, aHandle, tempRect);					SetIText(aHandle, t3);				end				else				begin					t3 := concat(char(27), '[23;15H', char(27), '[K', t3);					ProcessData(activeNode, @t3[1], length(t3));				end;			end			else			begin				myTrans.active := false;				if transDilg <> nil then					DisposDialog(transDilg);				transDilg := nil;				GoHome;			end;			lastFTUpdate := tickCount;		end;	end;	procedure AnsiCode (theCode: str255);		var			t1: str255;			count: longInt;			Result: OSerr;			tempInt, i: integer;	begin		with curglobs^ do		begin			t1 := theCode;			if t1[1] <> '[' then				t1 := concat(' [', theCode)			else				t1 := concat(' ', t1);			t1[1] := char(27);			count := length(t1);			if not sysopLogon then				result := AsyncMWrite(outputRef, count, @t1[1]);			ProcessData(activeNode, @t1[1], count);		end;	end;	procedure DecodeM (typeL: integer; nowStyle: CharStyle; var ts: str255);		var			t1, t2: str255;			hadToInit: boolean;	begin		with curglobs^ do		begin			t1 := '';			t2 := '';			if ((nowStyle.bold) and not (thisUser.bolds[typeL])) or ((nowStyle.underLine) and not (thisUser.underLines[typeL])) then				hadtoInit := true			else				hadToInit := false;			if thisUser.ansiColor and ((thisUser.foreGrounds[typeL] <> nowStyle.fCol) or hadToInit) then			begin				NumToString(thisUser.foregrounds[typeL] + 30, t1);			end;			if thisUser.ansiColor and ((thisUser.backGrounds[typeL] <> nowStyle.bCol) or hadToInit) then			begin				NumToString(thisUser.backgrounds[typeL] + 40, t2);			end;			if (length(t2) > 0) and (length(t1) > 0) then				t1 := concat(';', t1);			t1 := concat(t2, t1);			if not nowStyle.bold and thisUser.bolds[typeL] then			begin				if length(t1) > 0 then					t1 := concat('1;', t1)				else					t1 := '1';			end;			if not nowStyle.underLine and thisUser.underlines[typeL] then				if length(t1) > 0 then					t1 := concat('4;', t1)				else					t1 := '4';			if hadToInit then				t1 := concat('0;', t1);			if length(t1) > 0 then				ts := concat(char(27), '[', t1, 'm')			else				ts := '';		end;	end;	procedure DoM (typeL: integer);		var			t1, t2: str255;			hadToInit: boolean;	begin		with curglobs^ do		begin			with gBBSwindows[activeNode]^ do			begin				if not sysopLogon then				begin					t1 := '';					t2 := '';					if ((curStyle.bold) and not (thisUser.bolds[typeL])) or ((curStyle.underLine) and not (thisUser.underLines[typeL])) then						hadtoInit := true					else						hadToInit := false;					if (thisUser.ansiColor) and ((thisUser.foreGrounds[typeL] <> curStyle.fCol) or hadToInit) then					begin						NumToString(thisUser.foregrounds[typeL] + 30, t1);						if not thisUser.ansiColor then							NumToString(defaultStyle.fCol, t1);					end;					if (thisUser.ansiColor) and ((thisUser.backGrounds[typeL] <> curStyle.bCol) or hadToInit) then					begin						NumToString(thisUser.backgrounds[typeL] + 40, t2);						if not thisUser.ansiColor then							NumToString(defaultStyle.bCol, t2);					end;					if (length(t2) > 0) and (length(t1) > 0) then						t1 := concat(';', t1);					t1 := concat(t2, t1);					if not curStyle.bold and thisUser.bolds[typeL] then					begin						if length(t1) > 0 then							t1 := concat('1;', t1)						else							t1 := '1';					end;					if not curStyle.underLine and thisUser.underlines[typeL] then						if length(t1) > 0 then							t1 := concat('4;', t1)						else							t1 := '4';					if hadToInit then						t1 := concat('0;', t1);					if length(t1) > 0 then					begin						t1 := concat(char(27), '[', t1, 'm');						result := AsyncMWrite(outputRef, length(t1), pointer(ord4(@t1) + 1));					end;				end;				if thisUser.ansiColor then				begin					curStyle.fCol := thisUser.foregrounds[typeL];					curStyle.bCol := thisUser.backgrounds[typeL];				end;				curStyle.bold := thisUser.bolds[typeL];				curStyle.underline := thisUser.underlines[typeL];			end;		end;	end;	procedure BufferIt (goingOut: str255; NLatBegin: boolean; typeLine: integer);		var			ts: str255;	begin		with curGlobs^ do		begin			if optBuffer = nil then				gBBSwindows[activeNode]^.bufStyle := gBBSwindows[activeNode]^.curStyle;			if (typeLine >= 0) and (typeLine <= 7) and (thisUser.canANSI) then			begin				DecodeM(typeLine, gBBSwindows[activeNode]^.bufStyle, ts);				gBBSwindows[activeNode]^.bufStyle.fCol := thisUser.foregrounds[typeLine];				gBBSwindows[activeNode]^.bufStyle.bCol := thisUser.backgrounds[typeLine];				gBBSwindows[activeNode]^.bufStyle.bold := thisUser.bolds[typeLine];				gBBSwindows[activeNode]^.bufStyle.underline := thisUser.underlines[typeLine];				goingOut := concat(ts, goingOut);			end;			if NLatBegin and not negatebCR then				goingOut := concat(char(13), char(10), goingOut)			else if negatebCR then				negatebCR := false;			if optBuffer = nil then			begin				optBuffer := CharsHandle(NewHandle(length(goingOut)));				HNoPurge(handle(optBuffer));			end			else				SetHandleSize(handle(optBuffer), GetHandleSize(handle(optBuffer)) + length(goingOut));			HLock(handle(optBuffer));			BlockMove(ptr(ord4(@goingOut) + 1), pointer(ord4(pointer(optBuffer^)) + GetHandleSize(handle(optBuffer)) - length(goingOut)), length(goingOut));			HUnlock(handle(optBuffer));		end;	end;	procedure bufferbcr;	begin		if not curGlobs^.negateBCR then		begin			bufferIt('', true, -1);		end		else			curGlobs^.negateBCR := false;	end;	procedure BufClearScreen;		var			t1: str255;			c: longint;	begin		with curGlobs^ do		begin			if thisUser.screenClears then			begin				if thisUser.canANSI then					t1 := concat(char(27), '[2J', char(27), '[H')				else				begin					t1 := ' ';					t1[1] := char(12);				end;				bufferIt(t1, false, -1);			end;		end;	end;	procedure ReleaseBuffer;		var			count: longint;	begin		with curGlobs^ do		begin			if optBuffer <> nil then			begin				count := GetHandleSize(handle(optBuffer));				if not sysopLogon then					result := asyncMWrite(outputRef, count, pointer(optBuffer^));				ProcessData(activeNode, pointer(optBuffer^), count);				HPurge(handle(optBuffer));				DisposHandle(handle(optBuffer));				optBuffer := nil;			end;		end;	end;	procedure OutLine (goingOut: str255; NLatBegin: boolean; typeLine: integer);		var			count: longint;			i: integer;			ts: str255;	begin		with curglobs^ do		begin			if NLatBegin then				bCR;			if thisUser.canANSI and (typeLine >= 0) then				doM(typeLine);			if not sysopLogon then			begin				count := length(GoingOut);				result := asyncMWrite(outputRef, count, ptr(ord4(@goingOut) + 1));			end;			ProcessData(activeNode, ptr(ord4(@goingOut) + 1), length(goingOut));		end;	end;	procedure bCR;		var			count: Longint;			yaba: str255;	begin		with curglobs^ do		begin			if not negateBCR then			begin				yaba := concat(char(13), char(10));				if not sysopLogon then					result := AsyncMWrite(outputRef, 2, ptr(ord4(@yaba) + 1));				ProcessData(activeNode, ptr(ord4(@yaba) + 1), 2);			end			else				negateBCR := false;		end;	end;	procedure GiveTime (tickstoGive: longint; multiplier: real; tellUser: boolean);		var			myReal: real;			templong: longint;	begin		with curglobs^ do		begin			if (multiplier > 0) and not shutdownsoon then			begin				if (ticksLeft(activeNode) < NextDownticks) or (nextDownTicks < 0) then				begin					myReal := ticksToGive * multiplier;					tempLong := trunc(myReal);					extraTime := extraTime + tempLong;					if tellUser then					begin						OutLine(concat('Granted ', tickToTime(tempLong), ' compensation time.'), true, 1);						bCR;						bCR;					end;				end;			end;		end;	end;	procedure AddExtended (theFil: filEntryRec; whichDir: integer);		var			s1, tempstring: str255;			myRef, tempint: integer;			tuba: longint;			tempers: filentryrec;	begin		with curglobs^ do		begin			DeleteExtDesc(theFil, whichDir);			tempString := concat(sharedPath, 'Data:', intDLStuff^^.dr[whichDir].dirName, '.EXT');			result := FSOpen(tempString, 0, myref);			if result <> noErr then			begin				result := Create(tempString, 0, 'HRMS', 'DATA');				result := FSOpen(tempString, 0, myRef);			end;			if result = noErr then			begin				result := SetFPos(myRef, fsFromLEOF, 0);				tuba := sizeOf(extDescRec);				curExtDesc.fName := theFil.flName;				curExtDesc.DescLeng := GetHandleSize(handle(curWriting));				result := FSWrite(myRef, tuba, @curExtDesc);				tuba := getHandleSize(HANDLE(curWriting));				result := FSWrite(myRef, tuba, pointer(curWriting^));				result := FSClose(myRef);				if OpenDirectory(whichdir) then				begin					curDirPos := 0;					repeat						GetNextFile(whichdir, theFil.FlName, curDirPos, tempers, 0)					until (tempers.flname = '') or (tempers.flName = theFil.flname);					tempers.hasExtended := true;					if (tempers.flName = theFil.flName) then					begin						FileEntry(tempers, whichdir, tempInt, curDirPos);					end;				end;			end			else				OutLine('Could not save extended description!', true, 0);		end;	end;	procedure SysopAddExtended (theFil: filEntryRec; whichDir: integer; curWriting: charsHandle);		var			s1, tempstring: str255;			myRef, tempint: integer;			tuba: longint;			tempers: filentryrec;			curExtDesc: extDescrec;	begin		tempString := concat(sharedPath, 'Data:', intDLStuff^^.dr[whichDir].dirName, '.EXT');		result := FSOpen(tempString, 0, myref);		if result <> noErr then		begin			result := Create(tempString, 0, 'HRMS', 'DATA');			result := FSOpen(tempString, 0, myRef);		end;		if result = noErr then		begin			result := SetFPos(myRef, fsFromLEOF, 0);			tuba := sizeOf(extDescRec);			curExtDesc.fName := theFil.flName;			curExtDesc.DescLeng := GetHandleSize(handle(curWriting));			result := FSWrite(myRef, tuba, @curExtDesc);			tuba := getHandleSize(HANDLE(curWriting));			result := FSWrite(myRef, tuba, pointer(curWriting^));			result := FSClose(myRef);		end		else			SysBeep(10);	end;	procedure DeleteExtDesc (theFile: filEntryRec; whichDir: integer);		var			tempString, s1: str255;			L1, r, w, tempLong: longint;			myRef: integer;			ss: handle;			ed: extDescRec;	begin		r := 0;		w := 0;		ss := nil;		ss := NewHandle(10000);		HNoPurge(ss);		if memerror = noErr then		begin			tempString := concat(sharedPath, 'Data:', intDLStuff^^.dr[whichDir].dirName, '.EXT');			result := FSOpen(tempString, 0, myRef);			if result = noErr then			begin				result := GetEOF(myRef, L1);				while (r < L1) do				begin					result := SetFPos(myRef, fsFromStart, r);					tempLong := SizeOf(extDescRec);					result := FSRead(myRef, tempLong, @ed);					tempLong := ed.descLeng;					result := FSRead(myRef, tempLong, pointer(ss^));					if not (ed.fName = theFile.flName) then					begin						if r <> w then						begin							result := SetFPos(myRef, fsFromStart, w);							tempLong := SizeOf(extDescRec);							result := FSWrite(myRef, tempLong, @ed);							tempLong := ed.DescLeng;							result := FSWrite(myRef, tempLong, pointer(ss^));						end;						w := w + (SizeOf(extDescRec)) + ed.descLeng;					end;					r := r + (SizeOf(extDescRec)) + ed.descLeng;				end;				result := SetEOF(myRef, w);				result := FSClose(myRef);			end;		end;		HPurge(ss);		DisposHandle(ss);	end;	function FragFile (path: str255): boolean;		var			myFInfo: FInfo;	begin		result := GetFInfo(path, 0, myFInfo);		if result = noErr then		begin			if myFInfo.fdType = 'FRAG' then				FragFile := true			else				FragFile := false;		end		else			FragFile := false;	end;	procedure ContinueTrans;		var			tempint, i: integer;			temprect: rect;			FRAGGED, stored: boolean;			aHandle: handle;			tempstring, ts1, ts2, t2, t3: str255;			hhh: paramBlockRec;			tempLong: longint;	begin		with curglobs^ do		begin			result := noErr;			t3 := '';			if myTrans.sending then				result := ProtocolCall(DOWNLOADCALL, pointer(extTrans^), theprots^^.prots[activeProtocol].refCon, pointer(protCodeHand^))			else				result := ProtocolCall(UPLOADCALL, pointer(extTrans^), theprots^^.prots[activeProtocol].refCon, pointer(protCodeHand^));  {theProts^^.prots[activeProtocol].protHand}			if extTrans^^.flags[newMBName] then			begin				extTrans^^.flags[newMBName] := false;				if (BoardMode = Terminal) then				begin					if (transDilg <> nil) then					begin						SetPort(transDilg);						GetDItem(transDilg, 6, tempInt, aHandle, tempRect);						t2 := extTrans^^.fPaths[extTrans^^.filesDone + 1].mbName^^;						SetIText(aHandle, t2);					end;				end;				DisposHandle(handle(extTrans^^.fpaths[extTrans^^.filesDone + 1].mbName));				extTrans^^.fpaths[extTrans^^.filesDone + 1].mbName := nil;			end;			if extTrans^^.flags[newError] then			begin				HLock(handle(extTrans^^.errorReason));				if (transDilg <> nil) then				begin					GetDItem(transDilg, 9, tempInt, aHandle, tempRect);					SetIText(aHandle, extTrans^^.errorReason^^);				end;				lastTransError := extTrans^^.errorReason^^;				HUnlock(handle(extTrans^^.errorReason));				DisposHandle(handle(extTrans^^.errorReason));				ExtTrans^^.flags[newError] := false;				extTrans^^.errorReason := nil;			end;			if extTrans^^.flags[recovering] then			begin				startCPS := extTrans^^.curBytesDone;				extTrans^^.flags[recovering] := false;			end;			if (extTrans^^.flags[newFile]) then			begin				startCPS := 0;				lastTransError := '';				extTrans^^.flags[newFile] := false;				if (tickCount - extTrans^^.curStartTime) > 60 then					NumToString((extTrans^^.curBytesTotal - startCPS) div ((tickCount - extTrans^^.curStartTime) div 60), t3)				else					t3 := '?';				if (BoardMode = User) then				begin					if (extTrans^^.filesDone < (extTrans^^.fileCount - 1)) and (BoardSection = Batch) then					begin						t2 := FileTransit^^.filesGoing[extTrans^^.filesDone + 2].theFile.flName;						if (transDilg <> nil) then						begin							SetPort(transDilg);							GetDItem(transDilg, 6, tempInt, aHandle, tempRect);							SetIText(aHandle, t2);							GetDItem(transDilg, 5, tempInt, aHandle, tempRect);							EraseRect(temprect);						end						else						begin							t2 := concat(char(27), '[23;15H', char(27), '[K', t2);							ProcessData(activeNode, @t2[1], length(t2));						end;					end;					if (BoardSection = Upload) or ((BoardSection = Batch) and not (fileTransit^^.sendingBatch)) then					begin						if (BoardSection = Batch) then						begin							curFil := fileTransit^^.filesGoing[extTrans^^.filesDone + 1].theFile;							tempinDir := fileTransit^^.filesgoing[extTrans^^.filesDone + 1].fromDir;						end;						if (pos(':', curFil.realFName) = 0) then							tempstring := concat(intDLStuff^^.dr[tempindir].path, curFil.realFName)						else							tempString := curFil.realFName;						if (FExist(tempstring)) then						begin							hhh.ioCompletion := nil;							if (pos(':', curFil.realFName) = 0) then								tempstring := concat(intDLStuff^^.dr[tempindir].path, curFil.realFName)							else								tempString := curFil.realFName;							hhh.ioNamePtr := @tempString;							hhh.ioVRefNum := 0;							hhh.ioFVersNum := 0;							hhh.ioFDirIndex := 0;							if PBGetFInfo(@hhh, false) = noErr then								curFil.byteLen := hhh.ioFLLgLen + hhh.ioFLRLgLen;							stored := false;							if OpenDirectory(tempInDir) then							begin								if curNumFiles > 0 then								begin									for i := 1 to curNumFiles do									begin										if not stored then										begin											if (EqualString(curOpenDir^^[i - 1].flName, curFil.flname, false, false)) then											begin												curOpenDir^^[i - 1].byteLen := curFil.byteLen;												curOpenDir^^[i - 1].fileStat := char(0);												tempInt := curFil.byteLen div 1024;												if tempint < 1 then													tempInt := 1;												stored := true;												SaveDirectory;											end;										end;									end;								end;							end;							CloseDirectory;							if not stored then								FileEntry(curFil, tempinDir, tempInt, 0);							thisUser.numUploaded := thisUser.numUploaded + 1;							thisUser.UploadedK := thisUser.UploadedK + tempint;							intSystRec.uploadsToday := intSystRec.uploadsToday + 1;							DoSystRec(true);							tempLong := tickcount - extTrans^^.curStartTime;							GiveTime(tempLong, intSystRec.xfercomp, false);							bUploadCompense := bUploadCompense + tempLong;							if (tickCount - extTrans^^.curStartTime) > 60 then								NumToString((extTrans^^.curBytesTotal - startCPS) div ((tickCount - extTrans^^.curStartTime) div 60), t3)							else								t3 := '?';							sysopLog(concat('      U/L:', theprots^^.prots[activeProtocol].ProtoName, ': ', curFil.flName, ' on ', intDLstuff^^.dr[tempinDir].dirName, ' :', t3, 'cps. '), 0);						end;					end					else					begin						if (BoardSection = Download) then						begin							if not intDLstuff^^.dr[tempindir].freeDir then							begin								thisUser.numDownloaded := thisUser.numDownloaded + 1;								thisuser.downloadedK := thisUser.downloadedK + (extTrans^^.curBytesTotal div 1024) + 1;							end;							sysopLog(concat('      D/L:', theprots^^.prots[activeProtocol].ProtoName, ': ', curFil.flName, ' from ', intDLstuff^^.dr[tempInDir].dirName, ':', t3, 'cps. '), 0);						end						else if (BoardSection = Batch) then						begin							if not intDLstuff^^.dr[FileTransit^^.filesGoing[extTrans^^.filesDone + 1].fromDir].freeDir then							begin								thisUser.numDownloaded := thisUser.numDownloaded + 1;								thisuser.downloadedK := thisUser.downloadedK + (extTrans^^.curBytesTotal div 1024) + 1;							end;							sysopLog(concat('      D/L:', theprots^^.prots[activeProtocol].ProtoName, ': ', FileTransit^^.filesGoing[extTrans^^.filesDone + 1].theFile.flName, ' from ', intDLstuff^^.dr[FileTransit^^.filesGoing[extTrans^^.filesDone + 1].fromDir].dirName, ':', t3, 'cps. '), 0);						end;						FileDLd;					end;				end;			end;			if ((tickCount - lastFTUpdate) > 80) and (lastCurBytes <> extTrans^^.curBytesDone) then			begin				UpdateProgress;				lastCurBytes := extTrans^^.curBytesDone;				lastFTUpdate := tickCount;			end;			lastKeyPressed := tickCount;			if result <> noErr then			begin				lastKeyPressed := tickCount;				flowie(true);				ClearInBuf;				if transDilg <> nil then					DisposDialog(transDilg);				transDilg := nil;				if (BoardMode = User) then				begin					if (extTrans^^.fileCount > extTrans^^.filesDone) then					begin						if (BoardSection = Batch) and fileTransit^^.sendingBatch then							sysopLog(concat('      Failed D/L(', fileTransit^^.filesGoing[extTrans^^.filesDone + 1].theFile.flName, '):', lastTransError), 0)						else if (BoardSection = Download) then							sysopLog(concat('      Failed D/L(', curFil.flName, '):', lastTransError), 0)						else if (BoardSection = Upload) or (BoardSection = Batch) or (BoardSection = MessUp) then						begin							if (BoardSection = MessUp) then								tempString := 'Local Workspace'							else							begin								if (BoardSection = Batch) then								begin									curFil := fileTransit^^.filesGoing[extTrans^^.filesDone + 1].theFile;									tempinDir := fileTransit^^.filesgoing[extTrans^^.filesDone + 1].fromDir;								end;								if (pos(':', curFil.realFName) = 0) then									tempstring := concat(intDLStuff^^.dr[tempindir].path, curFil.realFName)								else									tempString := curFil.realFName;							end;							fragged := FragFile(tempstring);							if fragged and (BoardSection <> MessUp) then							begin								curFil.fileStat := 'F';								stored := false;								if OpenDirectory(tempInDir) then								begin									if curNumFiles > 0 then									begin										for i := 1 to curNumFiles do										begin											if not stored then											begin												if (EqualString(curOpenDir^^[i - 1].flName, curFil.flname, false, false)) then													stored := true;											end;										end;									end;								end;								CloseDirectory;								if not stored then									FileEntry(curFil, tempinDir, tempInt, 0);								bCR;								OutLine('Fragment upload received.', true, 3);								SysopLog(concat('      FRAG U/L(', curFil.flname, '):', ts2), 0);								bCR;								GoHome;							end							else							begin								crossInt := 10;								ts1 := curFil.flname;								if (BoardSection = MessUp) then									ts1 := 'Message Upload'								else if curFil.hasExtended then									DeleteExtDesc(curFil, tempinDir);								SysopLog(concat('      Failed U/L(', ts1, '):', lastTransError), 0);								OutLine('Upload aborted.', true, 0);								goHome;							end;						end;					end					else if (BoardSection = Upload) or ((BoardSection = Batch) and not (fileTransit^^.sendingBatch)) then					begin						bCR;						OutLine('Upload(s) completed successfully.', true, 3);						bCR;						DLRatioStr(tempString, activeNode);						Outline(concat('Your ratio is now: ', tempString), true, 3);						bCR;						OutLine(concat('Granted ', tickToTime(bUploadCompense), ' compensation time.'), true, 1);						bCR;						bCR;						bCR;						if (BoardSection = Upload) then							GoHome;					end;				end;				if (BoardSection = Batch) then				begin					FileTransit^^.numFiles := 0;					FileTransit^^.batchTime := 0;					FileTransit^^.batchKBytes := 0;				end;				myTrans.active := false;				KillXferRec;				if (visibleNode = activeNode) then				begin					if BoardMode = Terminal then					begin						EnableItem(getMHandle(1009), 0);						EnableItem(getMHandle(mTerminal), 0);					end;					EnableItem(getMHandle(mDisconnects), 0);				end;				DrawMenuBar;				DownDo := DownThree;				BatDo := BatSix;				HUnlock(protCodeHand);				DisposHandle(protCodeHand);				protCodeHand := nil;			end;		end;	end;	procedure AbortTrans;		var			tempint: integer;			aHandle: handle;			temprect: rect;	begin		with curglobs^ do		begin			if extTrans^^.flags[stopTrans] then				extTrans^^.flags[carrierLoss] := true			else				extTrans^^.flags[stopTrans] := true;			if transDilg <> nil then			begin				GetDItem(transDilg, 1, tempInt, aHandle, tempRect);				SetCTitle(controlHandle(pointer(aHandle)), 'EXIT');			end;		end;	end;	procedure SaveDirectory;		var			DirFileName: str255;			theDirref: integer;			tempLong: longint;	begin		with curglobs^ do		begin			dirFileName := concat(sharedPath, 'Data:', intDLStuff^^.dr[dirOpenNum].dirName);			result := FSDelete(dirFileName, 0);			result := Create(dirFileName, 0, 'HRMS', 'DATA');			result := FSOpen(dirFileName, 0, theDirRef);			if result = noErr then			begin				tempLong := SizeOf(filEntryRec) * longint(curNumFiles);				HLock(handle(curOpenDir));				result := FSWrite(theDirRef, tempLong, pointer(curOpenDir^));				HUnlock(handle(curOpenDir));				result := FSClose(theDirRef);			end;		end;	end;	procedure SysSaveDirectory;		var			DirFileName: str255;			theDirref: integer;			tempLong: longint;	begin		dirFileName := concat(sharedPath, 'Data:', intDLStuff^^.dr[sysopDirNum].dirName);		result := FSDelete(dirFileName, 0);		result := Create(dirFileName, 0, 'HRMS', 'DATA');		result := FSOpen(dirFileName, 0, theDirRef);		if result = noErr then		begin			tempLong := SizeOf(filEntryRec) * longint(sysopNumFiles);			HLock(handle(sysopOpenDir));			result := FSWrite(theDirRef, tempLong, pointer(sysopOpenDir^));			HUnlock(handle(sysopOpenDir));			result := FSClose(theDirRef);		end;	end;	function SysopFileFilter (p: ParmBlkPtr): BOOLEAN;		var			gotOne: boolean;			place: longint;			theV, i: integer;			hhh: HparamBlockRec;			Tetatet: CInfoPBRec;			t2, t3, t4, t5: str255;	begin		SysopFileFilter := false;		if maskFiles then		begin			t3 := p^.ioNamePtr^;			gotOne := false;			place := 0;			t2 := intDLStuff^^.dr[sysopDirNum].path;			with hhh do			begin				iocompletion := nil;				ioNamePtr := @t2;				ioVolIndex := -1;				ioVRefNum := 0;			end;			result := PBHGetVInfo(@hhh, false);			t2 := intDLStuff^^.dr[sysopDirNum].path;			with tetatet do			begin				iocompletion := nil;				ioNamePtr := @t2;				iovRefNum := HHH.ioVRefNum;				ioFDirIndex := 0;			end;			result := PBGetCatInfo(@tetatet, false);			if (tetatet.ioDrDirID = curDirStore^) and (hhh.ioVRefNum = (-SFSaveDisk^)) then			begin				if sysopNumFiles > 0 then				begin					repeat						if EqualString(sysopOpenDir^^[place].flName, t3, false, false) then							gotOne := true;						place := place + 1;					until GotOne or (place > sysopNumFiles);				end;				if gotOne then					SysopFileFilter := true;			end;		end;	end;	procedure DrawSFLine (theWindow: WindowPtr; item: integer);		const			ListItem = 13;		var			kind: integer;			h: handle;			r: rect;	begin		if (item = ListItem) then		begin			SetPort(theWindow);			GetDItem(theWindow, ListItem, kind, h, r);			FillRect(r, gray);		end;	end;	procedure DrawXFerList (theWindow: WindowPtr; item: integer);		var			kind: integer;			h: handle;			r: rect;	begin		if (item = 11) then		begin			SetPort(theWindow);			GetDItem(theWindow, 11, kind, h, r);			FrameRect(r);			LUpdate(theWindow^.visRgn, XFerList);			if SFXferTE <> nil then			begin				EraseRect(SFXFerTE^^.viewRect);				TEUpdate(SFXFerTE^^.viewRect, SFXferTE);			end;			DrawClippedGrow(theWindow);		end;	end;	function GenFileNote (which: integer): str255;		var			b, tempint: integer;			s2, s3, s4: str255;	begin		s3 := sysopOpenDir^^[which].flName;		if length(S3) < intDLStuff^^.dr[sysopDirNum].fileNameLength then			for b := length(s3) to (intDLStuff^^.dr[sysopDirNum].fileNameLength - 1) do				s3 := concat(s3, ' ');		if length(S3) > intDLStuff^^.dr[sysopDirNum].fileNameLength then		begin			s3[intDLStuff^^.dr[sysopDirNum].fileNameLength] := '*';			s3[0] := char(intDLStuff^^.dr[sysopDirNum].fileNameLength);		end;		if sysopOpenDir^^[which].fileStat <> 'F' then		begin			tempInt := sysopOpenDir^^[which].byteLen div 1024;			if (tempInt < 1) and (sysopOpenDir^^[which].byteLen <> 0) then			begin				tempInt := 1;				NumToString(tempInt, s2);				s2 := concat(s2, 'k+');			end			else if (sysopOpenDir^^[which].byteLen = -1) then				s2 := 'ASK'			else			begin				NumToString(tempInt, s2);				s2 := concat(s2, 'k+');			end;			if length(s2) < 7 then				for b := length(s2) to 7 do					s2 := concat(' ', s2);			if sysopOpenDir^^[which].hasExtended then				s2[1] := char(249);			if (pos(':', sysopOpenDir^^[which].realFName) = 0) then				s4 := concat(intDLStuff^^.dr[sysopDirNum].path, sysopOpenDir^^[which].realFName)			else				s4 := sysopOpenDir^^[which].realFName;			if FExist(s4) then				s2[2] := char(249);		end		else		begin			s2 := 'U/L FRAG';		end;		genFileNote := concat(s3, ':', s2, ':', sysopOpenDir^^[which].flDesc);	end;	procedure FillXFerList;		label			100;		var			i, b: integer;			tempInt: longint;			s2, s3, endUp: str255;			cSize: cell;	begin		LDelRow(0, 0, XFERList);		LDoDraw(false, XFerList);		if sysopNumFiles > 0 then		begin			cSize.v := LAddRow(sysopNumFiles, 5000, XFerList);			for i := 1 to sysopNumFiles do			begin				endUp := GenFileNote(i - 1);				cSize.h := 0;				cSize.v := i - 1;				LSetCell(Pointer(ord(@endUp) + 1), length(endUp), cSize, XFerList);				if GetHandleSize(handle(XFerList^^.cells)) > 32000 then				begin					ProblemRep('Displayable list size is limited to 32K.  List will be truncated.');					LDelRow(sysopNumFiles - i, i, XFerList);					goto 100;				end;			end;100:		end;		LDoDraw(true, XFerList);	end;	procedure ClearRename (dptr: dialogPtr);		var			kind: integer;			h: handle;			r: rect;			tempChars: charsHandle;			load, t2: str255;			tempCell: cell;	begin		if (BeingRenamed > -1) and (SFXFerTE <> nil) then		begin			tempChars := TEGetText(SFXferTE);			load := '';			if SFXFerTE^^.teLength > 0 then			begin				for kind := 1 to SFXFerTE^^.teLength do					load := concat(load, ' ');				BlockMove(@tempChars^^[0], @load[1], SFXFerTE^^.teLength);			end;			if nameOrDesc then			begin				if (length(load) > 0) and (length(load) < 21) then				begin					kind := pos(':', sysopOpenDir^^[beingRenamed].realFName);					t2 := '';					if (kind = 0) then						result := Rename(concat(intDLStuff^^.dr[sysopDirNum].path, sysopOpenDir^^[beingRenamed].realFName), 0, concat(intDLStuff^^.dr[sysopDirNum].path, load))					else					begin						t2 := copy(sysopOpenDir^^[beingRenamed].realFName, 1, kind);						result := Rename(sysopOpenDir^^[beingRenamed].realFName, 0, load);					end;					if result = noErr then					begin						if sysopOpenDir^^[beingRenamed].hasExtended then						begin							ReadExtended(sysopOpenDir^^[beingRenamed], sysopDirNum);							DeleteExtDesc(sysopOpenDir^^[beingRenamed], sysopDirNum);						end;						sysopOpenDir^^[beingRenamed].realFName := concat(t2, load);						sysopOpenDir^^[beingRenamed].flName := load;						if sysopOpenDir^^[beingRenamed].hasExtended then							AddExtended(sysopOpenDir^^[beingRenamed], sysopDirNum);					end					else						SysBeep(10);				end				else					SysBeep(10);			end			else			begin				sysopOpenDir^^[beingRenamed].flDesc := load;			end;			TEDispose(SFXFerTE);			SFXferTE := nil;			tempCell.h := 0;			tempCell.v := beingRenamed;			load := GenFileNote(beingRenamed);			LSetCell(@load[1], length(load), tempCell, XFerList);		end;		beingRenamed := -1;	end;	procedure IdleUser;	external;	procedure giveBBSTime;		var			savedNode, i: integer;			savePort: GrafPtr;	begin		GetPort(savePort);		if lastIdle + 15 < tickCount then		begin			savedNode := activeNode;			for i := 1 to intSystRec.numNodes do			begin				curGlobs := theNodes[i];				activeNode := i;				IdleUser;			end;			activeNode := savedNode;			curGlobs := theNodes[activeNode];			lastIdle := tickCount;		end;		SetPort(savePort);	end;	function usemodaltime (theDialog: dialogPtr; var theEvent: eventRecord; var itemHit: integer): boolean;		var			myPt: point;			key: char;			kind: integer;			h: handle;			r: rect;	begin		usemodaltime := false;		giveBBStime;	end;	function SysopUploadHook (item: integer; dPtr: DialogPtr): integer;		label			900, 1000, 444;		var			messageTitle, t2: str255;			h: Handle;			kind, wid, i, ky: integer;			r, rView, dataBounds: rect;			cSize: point;			hhh: HparamBlockRec;			Tetatet: CInfoPBRec;			myPop: myPopContHand;			sysCurFil: filEntryRec;			myC: controlHandle;			citem: controlhandle;			tempcell: cell;			deleteRemoved, isAnAlias: boolean;			kbNunc: keyMap;			tempFS: FSSpec;			myTempInt: integer;	begin		SysopUploadHook := item;		isAnAlias := false;		SetPort(dPtr);		TextSize(12);		TextFont(0);		if XFerNeedsUpdate and (item = 100) then		begin			SysopUploadHook := 101;			XFerNeedsUpdate := false;			item := 101;		end		else			case item of				100: 				begin					if SFXferTE <> nil then						TEIdle(SFXferTE);					giveBBStime;				end;				-1: 				begin					ClearRename(dPtr);					GetDItem(dPtr, 13, kind, h, r);					SetDItem(dPtr, 13, kind, handle(@DrawSFLine), r);					GetDItem(dPtr, 17, kind, h, r);					myPop := pointer(h);					DelMenuItem(myPop^^.contrlData^^.mHandle, 1);					for i := 1 to intDLStuff^^.numDirs do					begin						AppendMenu(myPop^^.contrlData^^.mHandle, 'B');						SetItem(myPop^^.contrlData^^.mHandle, i, intDLStuff^^.dr[i - 1].DirName);					end;					SetCtlValue(controlhandle(myPop), 1);					GetDItem(dPtr, 12, kind, h, r);					SetCtlValue(controlHandle(h), 1);					GetDItem(dPtr, 15, kind, h, r);					HiLiteControl(controlHandle(h), 255);					GetDItem(dPtr, 14, kind, h, r);					HiLiteControl(controlHandle(h), 255);					GetDItem(dPtr, 11, kind, h, r);					SetDItem(dPtr, 11, kind, handle(@DrawXFerList), r);					rView := r;					rView.right := rView.right - 15;					InsetRect(rView, 1, 1);					dataBounds.topLeft := Point(0);					dataBounds.bottom := 0;					databounds.Right := 1;					cSize.v := 11;					cSize.h := rView.right - rView.left;					XFerList := LNew(rView, dataBounds, cSize, 2056, dPtr, FALSE, FALSE, FALSE, TRUE);  {2056 is custom LDEF}					XFerList^^.selFlags := lNoNilHilite;					FillXFerList;					GetDItem(dPtr, 16, kind, h, r);					EraseRect(r);					r.left := -(r.right - r.left);					r.right := 0;					OffsetRect(r, intDLStuff^^.dr[sysopDirNum].fileNameLength * 6 + 20, 0);					SetDItem(dptr, 16, kind, h, r);				end;				21: 				begin					t2 := intDLStuff^^.dr[sysopDirNum].path;					with hhh do					begin						iocompletion := nil;						ioNamePtr := @t2;						ioVolIndex := -1;						ioVRefNum := 0;					end;					result := PBHGetVInfo(@hhh, false);					t2 := intDLStuff^^.dr[sysopDirNum].path;					with tetatet do					begin						iocompletion := nil;						ioNamePtr := @t2;						iovRefNum := HHH.ioVRefNum;						ioFDirIndex := 0;					end;					result := PBGetCatInfo(@tetatet, false);					curDirStore^ := tetaTet.ioDrDirId;					SFSaveDisk^ := -(hhh.ioVRefNum);					XFerNeedsUpdate := true;				end;				15: 				begin					ClearRename(dPtr);					wid := SelectDirectory('Move to which directory:');					if wid >= 0 then					begin						if wid <> sysopDirNum then						begin							tempcell.v := 0;							tempcell.h := 0;							result := noErr;							while (LGetSelect(true, tempCell, XFerList)) and (result = noErr) do							begin								kind := sysopDirNum;								sysCurFil := sysopOpenDir^^[tempCell.v];								ky := pos(':', sysCurFil.realFName);								if (ky = 0) then									result := copy1File(concat(intDLStuff^^.dr[sysopDirNum].path, sysCurFil.realFName), concat(intDLStuff^^.dr[wid].path, sysCurFil.realFname));								if (result = noErr) then								begin									if (ky = 0) then										result := FSDelete(concat(intDLStuff^^.dr[sysopDirNum].path, sysCurFil.realFName), 0)									else									begin										if (ModalQuestion('Do you want to move the file itself too?', false, true) = 1) then										begin											result := copy1File(sysCurFil.realFName, concat(intDLStuff^^.dr[wid].path, GetFNameFromPath(sysCurFil.realFName)));											result := FSDelete(sysCurFil.realFName, 0);										end;									end;									if tempCell.v < sysopNumFiles then									begin										for i := 1 to ((sysopNumFiles - tempCell.v) - 1) do										begin											sysopOpenDir^^[tempCell.v + (i - 1)] := sysopOpenDir^^[tempCell.v + i];										end;									end;									LDelRow(1, tempCell.v, XFERList);									sysopNumFiles := sysopNumFiles - 1;									SysSaveDirectory;									readExtended(sysCurFil, sysopDirNum);									deleteExtDesc(sysCurFil, sysopDirNum);									AddExtended(sysCurFil, wid);									FileEntry(sysCurFil, wid, myTempInt, 0);									if SysOpenDirectory(kind) then										;								end								else								begin									NumToString(result, t2);									ProblemRep(concat('Move aborted, file copy error: ', t2));								end;							end;							XFERNeedsUpdate := true;						end						else							ProblemRep('The file(s) are already in that directory!');						SetPort(dPtr);					end;				end;				18: 				begin					ClearRename(dPtr);					GetDItem(dPtr, 18, kind, h, r);					kind := GetCtlValue(controlhandle(h));					SetCtlValue(controlHandle(h), (kind + 1) mod 2);					if (GetCtlValue(controlHandle(h)) = 1) then						maskFiles := true					else						maskFiles := false;					XFerNeedsUpdate := true;				end;				19: 				begin					ClearRename(dPtr);					GetDItem(dPtr, 12, kind, h, r);					if (GetCtlValue(controlHandle(h)) = 1) then						deleteRemoved := true					else						deleteRemoved := false;					SysQuickSort(0, sysopNumFiles - 1, deleteRemoved);					FillXFerList;					GetDItem(dptr, 11, kind, h, r);					FrameRect(r);					LUpdate(dPtr^.visRgn, XFerList);				end;				14: 				begin					ClearRename(dPtr);					GetKeys(KBNunc);					if not KBNunc[58] then					begin						if (ModalQuestion('Delete file(s) from the disk?', false, true) = 1) then							deleteRemoved := true						else							deleteRemoved := false;						SetPort(dPtr);					end					else						deleteRemoved := true;					tempcell.v := 0;					tempcell.h := 0;					while LGetSelect(true, tempCell, XFerList) do					begin						if deleteRemoved then						begin							if (pos(':', sysopOpenDir^^[tempCell.v].realFName) = 0) then								t2 := concat(intDLStuff^^.dr[sysopDirNum].path, sysopOpenDir^^[tempCell.v].realFName)							else								t2 := sysopOpenDir^^[tempCell.v].realFName;							result := FSDelete(t2, 0);						end;						deleteExtDesc(sysopOpenDir^^[tempCell.v], sysopDirNum);						if tempCell.v < (sysopNumFiles - 1) then						begin							BlockMove(@sysopOpenDir^^[tempCell.v + 1], @sysopOpenDir^^[tempCell.v], SizeOf(filEntryRec) * longint(sysopNumFiles - (tempCell.v + 1)));						end;						sysopNumFiles := sysopNumFiles - 1;						LDelRow(1, tempCell.v, XFerList);						XFerNeedsUpdate := true;					end;				end;				12: 				begin					GetDItem(dPtr, 12, kind, h, r);					kind := GetCtlValue(controlhandle(h));					SetCtlValue(controlHandle(h), (kind + 1) mod 2);				end;				17: 				begin					GetDItem(dPtr, 17, kind, h, r);					kind := GetCtlValue(controlhandle(h));					if (kind - 1) <> sysopDirNum then					begin						GetDItem(dPtr, 14, tempCell.v, h, r);						HiLiteControl(controlHandle(h), 255);						ClearRename(dPtr);						SysSaveDirectory;						if SysOpenDirectory(kind - 1) then							;						if sysopOpenDir = nil then						begin							sysopNumFiles := 0;							sysopOpenDir := aDirHand(NewHandle(0));							HNoPurge(handle(sysopOpenDir));							sysopDirNum := kind - 1;						end;						FillXFerList;						GetDItem(dptr, 11, kind, h, r);						FrameRect(r);						LUpdate(dPtr^.visRgn, XFerList);						GetDItem(dPtr, 16, kind, h, r);						EraseRect(r);						r.left := -(r.right - r.left);						r.right := 0;						OffSetRect(r, intDLStuff^^.dr[sysopDirNum].fileNameLength * 6 + 20, 0);						SetDItem(dptr, 16, kind, h, r);						DrawDialog(dPtr);						XFerNeedsUpdate := true;					end;				end;				sfHookOpenAlias: 				begin					isAnAlias := true;					goto 900;				end;				getOpen: 				begin900:					ClearRename(dPtr);					deleteRemoved := false;					messageTitle := PathnameFromDirID(curDirStore^, -(SFSaveDisk^));					t2 := replySF.fname;					if (length(t2) > 0) then					begin						result := noErr;						sysCurFil.realFName := replySF.fName;						if messageTitle <> intDLStuff^^.dr[sysopDirNum].path then						begin							if not FEXIST(concat(intDLStuff^^.dr[sysopDirNum].path, replySF.fName)) then							begin								GetKeys(KBNunc);								if not KBNunc[58] then								begin									if (ModalQuestion('Move file into directory path?', false, true) = 0) then									begin										sysCurFil.realFName := concat(messageTitle, replySF.fName);										goto 444;									end									else if (ModalQuestion('Delete original file?', false, true) = 1) then										deleteRemoved := true									else										deleteRemoved := false;									SetPort(dPtr);								end								else									deleteRemoved := true;								SetPort(dPtr);								t2 := concat(intDLStuff^^.dr[sysopDirNum].path, replySF.fName);								messageTitle := concat(messageTitle, replySF.fName);								result := copy1File(messageTitle, t2);								if (result <> noErr) then								begin									NumToString(result, t2);									ProblemRep(concat('Error copying file: ', t2));									sysopUploadHook := 100;									exit(sysopUploadHook);								end								else if deleteRemoved then									result := FSDelete(messageTitle, 0);							end							else							begin								ProblemRep('File already exists in this directory.');								sysopUploadHook := 100;								exit(sysopUploadHook);							end;						end;						if result = noErr then						begin444:							t2 := replySF.fName;							if (length(t2) > 20) then								t2[0] := char(20);							sysCurFil.flName := t2;							sysCurFil.flDesc := '';							GetDateTime(sysCurFil.whenUL);							sysCurFil.uploaderName := myUsers^^[0].UName;							sysCurFil.uploaderNum := 1;							sysCurFil.numDLoads := 0;							hhh.ioCompletion := nil;							if (pos(':', sysCurFil.realFName) = 0) then								messageTitle := concat(intDLStuff^^.dr[sysopDirNum].path, sysCurFil.realFName)							else								messageTitle := sysCurFil.realFName;							sysCurFil.byteLen := 0;							if (gMac.systemVersion >= $0700) then							begin								result := FSMakeFSSpec(0, 0, messageTitle, tempFS);								result := ResolveAliasFile(tempFS, true, deleteRemoved, isAnAlias);								if deleteRemoved then									goto 1000;								hhh.ioVRefNum := tempFS.vrefnum;								hhh.ioFDirIndex := 0;								hhh.ioDirID := tempFS.parID;								hhh.ioNamePtr := @tempFS.name;								if (PBHGetFInfo(@hhh, false) = noErr) then									sysCurFil.byteLen := hhh.ioFLLgLen + hhh.ioFLRLgLen;							end							else							begin								hhh.ioNamePtr := @messageTitle;								hhh.ioVRefNum := 0;								hhh.ioFVersNum := 0;								hhh.ioFDirIndex := 0;								if PBGetFInfo(@hhh, false) = noErr then									sysCurFil.byteLen := hhh.ioFLLgLen + hhh.ioFLRLgLen;							end;							if sysCurFil.byteLen < 1024 then								sysCurFil.byteLen := 1024;							sysCurFil.hasExtended := false;							sysCurFil.fileStat := char(0);							sysCurFil.lastDL := 0;							for i := 1 to 4 do								sysCurFil.reserved[i] := char(0);							SetHandleSize(handle(sysopOpenDir), GetHandleSize(handle(sysopOpenDir)) + SizeOf(filEntryRec));							BlockMove(pointer(sysopOpenDir^), @sysopOpenDir^^[1], longInt(sysopNumFiles) * SizeOf(filEntryRec));							sysopNumFiles := sysopNumFiles + 1;							sysopOpenDir^^[0] := sysCurFil;							kind := LAddRow(1, 0, XFerList);							tempCell.h := 0;							tempCell.v := kind;							t2 := GenFileNote(0);							LSetCell(@t2[1], length(t2), tempCell, XFerList);							GetDItem(dptr, 11, kind, h, r);							FrameRect(r);							LUpdate(dPtr^.visRgn, XFerList);							GetDItem(dPtr, 18, kind, h, r);							if (GetCtlValue(controlHandle(h)) = 1) or deleteRemoved then								XFerNeedsUpdate := true;						end						else1000:							SysBeep(10);					end					else						SysBeep(10);					SysopUploadHook := 100;				end;				20: 				begin					ClearRename(dPtr);					SysSaveDirectory;					LDispose(XFerList);					if SFXFerTE <> nil then						TEDispose(SFXFerTE);					SFXferTE := nil;					SysopUploadHook := getCancel;				end;				otherwise			end;	end;	function ExtMyFilter (theDialog: dialogPtr; var theEvent: eventRecord; var itemHit: integer): boolean;		var			myPt: point;			key: char;			kind: integer;			h: handle;			r: rect;	begin		ExtMyFilter := false;		SetPort(theDialog);		TEIdle(myTE);		mypt := theEvent.where;		GlobalToLocal(mypt);		if (theEvent.what = mouseDown) then		begin			GetDItem(theDialog, 1, kind, h, r);			if PtInRect(myPt, r) then				TEClick(myPt, false, myTE);		end		else if (theEvent.what = keyDown) or (theEvent.what = autoKey) then		begin			key := CHR(BAnd(theevent.message, charCodeMask));			TEKey(key, myTE);			extMyFilter := true;		end		else			giveBBStime;	end;	procedure SysopExtDesc (var myFRec: filEntryRec; whichDir: integer);		var			descDilg, askDilg: dialogPtr;			kind, a, i: integer;			h: handle;			r, r2: rect;			myChars: charsHandle;			t1: str255;			ThisEditText: TEHandle;			TheDialogPtr: DialogPeek;			ttUser: UserRec;	begin		descDilg := GetNewDialog(624, nil, pointer(-1));		SetPort(descDilg);		TheDialogPtr := DialogPeek(descDilg);		ThisEditText := TheDialogPtr^.textH;		HLock(Handle(ThisEditText));		ThisEditText^^.txSize := 9;		TextSize(9);		ThisEditText^^.txFont := 150;		TextFont(150);		ThisEditText^^.txFont := 150;		ThisEditText^^.fontAscent := 9;		ThisEditText^^.lineHeight := 9 + 2 + 0;		HUnLock(Handle(ThisEditText));		NumToString(myFRec.uploaderNum, t1);		GetDItem(descDilg, 8, kind, h, r);		SetIText(h, myFRec.uploaderName);		GetDItem(descDilg, 3, kind, h, r);		SetIText(h, myFRec.flName);		GetDItem(descDilg, 9, kind, h, r);		SetIText(h, concat('#', t1));		GetDItem(descDilg, 1, kind, h, r);		r2 := r;		InsetRect(r2, 2, 2);		myTE := TENew(r2, r2);		if myTE <> nil then		begin			myTE^^.txFont := 150;			myTE^^.txSize := 9;			myTE^^.crOnly := -1;			myTE^^.lineHeight := 11;			myTE^^.fontAscent := 9;			if myFRec.hasExtended then			begin				myChars := SysopReadExtended(myFRec, whichDir);				HLock(handle(myChars));				if myChars <> nil then					TESetText(pointer(myChars^), GetHandleSize(handle(myChars)), myTE);				HUnLock(handle(myChars));				DisposHandle(handle(myChars));				myChars := nil;			end;			TEUpdate(descDilg^.portRect, myTE);			ShowWindow(descDilg);			DrawDialog(descDilg);			FrameRect(r);			TEUpdate(descDilg^.portRect, myTE);			TEActivate(myTE);			repeat				ModalDialog(@extMyFilter, a);				if a = 8 then				begin					askDilg := GetNewDialog(744, nil, pointer(-1));					SetPort(askDilg);					ParamText('Enter name or number, * wildcard allowed.', '', '', '');					DrawDialog(askDilg);					repeat						ModalDialog(nil, i);					until (i = 1);					GetDItem(askDilg, 3, kind, h, r);					GetIText(h, t1);					DisposDialog(askDilg);					SetPort(descDilg);					DrawDialog(descDilg);					TEUpdate(descDilg^.portRect, myTE);					if FindUser(t1, ttUser) then					begin						myFRec.uploaderName := ttUser.UserName;						myFRec.uploaderNum := ttUser.userNum;					end;					NumToString(myFRec.uploaderNum, t1);					GetDItem(descDilg, 8, kind, h, r);					SetIText(h, myFRec.uploaderName);					GetDItem(descDilg, 3, kind, h, r);					SetIText(h, myFRec.flName);					GetDItem(descDilg, 9, kind, h, r);					SetIText(h, concat('#', t1));					GetDItem(descDilg, 1, kind, h, r);					FrameRect(r);				end;			until (a = 6);			DeleteExtDesc(myFRec, whichDir);			myChars := TEGetText(myTE);			result := HandToHand(handle(myChars));			if result = noErr then			begin				HNoPurge(handle(myChars));				myFRec.hasExtended := false;				if GetHandleSize(handle(myChars)) > 0 then				begin					SysopAddExtended(myFRec, whichDir, myChars);					myFRec.hasExtended := true;				end;				HPurge(handle(myChars));				DisposHandle(handle(myChars));			end			else				SysBeep(10);			TEDispose(myTE);		end		else			SysBeep(10);		DisposDialog(descDilg);	end;	procedure DoUpdate (window: WindowPtr);		var			indWind, id2: integer;	begin		indWind := isMyTextWindow(window);		id2 := ismyBBSwindow(window);		if (window = statWindow) or (window = ssWind) then		begin			BeginUpdate(window);			EndUpdate(window);			if window = statWindow then				UpdateStatWindow;		end		else if id2 > 0 then		begin			if id2 = 1 then				id2 := 1;			BeginUpdate(window);			UpdateBBSwindow(id2);			EndUpdate(window);		end		else if indWind >= 0 then		begin			with textWinds[indWind] do			begin				BeginUpdate(w);				SetPort(w);				with w^ do				begin					EraseRect(portRect);					TEUpdate(portRect, t);					DrawControls(w);					DrawGrowIcon(w);				end;				EndUpdate(w);			end;		end;	end;	function XFerListModal (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			localPt: Point;			kind, maxLen, part: integer;			h: handle;			key: char;			shiftDown, didSomething: boolean;			growReturn: longint;			t5, t6: str255;			r, rView, dataBounds, dumRect: rect;			tempcell, cSize: cell;			whereWindow: WindowPtr;	begin		didSomething := false;		XFerListModal := FALSE;		SetPort(theDialog);		if (theEvent.what = updateEvt) then		begin			if (DialogPtr(theEvent.message) <> theDialog) then			begin				itemHit := 100;				XFerListModal := TRUE;				DoUpdate(windowPtr(theEvent.message));			end;		end		else if (theEvent.what = KeyDown) or (theEvent.what = AutoKey) then		begin			if SFXFerTE <> nil then			begin				if nameOrDesc then					maxLen := intDLStuff^^.dr[sysopDirNum].fileNameLength				else					MaxLen := 70 - intDLStuff^^.dr[sysopDirNum].fileNameLength;				key := CHR(BAnd(theevent.message, charCodeMask));				if (key = CHR(8)) | (SFXferTE^^.teLength - (SFXferTE^^.selEnd - SFXferTE^^.selStart) + 1 <= maxLen) then				begin					TEKey(key, SFXferTE);				end				else					SysBeep(10);				XFerListModal := true;				itemHit := 100;			end;		end		else if (theEvent.what = mouseDown) then		begin			localPt := theEvent.where;			GlobalToLocal(localPt);			part := FindWindow(theEvent.where, whereWindow);			case part of				inDrag: 				begin					if whereWindow = theDialog then					begin						xferlistmodal := true;						dumrect := screenbits.bounds;						SetRect(dumRect, dumRect.Left + 5, dumRect.Top + 25, dumRect.Right - 5, dumRect.Bottom - 5);						DragWindow(theDialog, theEvent.where, dumRect);					end;				end;				inContent: 				begin					if whereWindow = theDialog then					begin						if (SFXferTE <> nil) then						begin							if (PtInRect(localPt, SFXferTE^^.viewRect)) then							begin								shiftDown := BAnd(theevent.modifiers, shiftKey) <> 0;	{extend if Shift is down}								TEClick(localPt, shiftDown, SFXferTE);							end							else								ClearRename(theDialog);						end						else if LClick(localPt, theEvent.modifiers, XFerList) then						begin							if beingRenamed >= 0 then							begin								ClearRename(theDialog);							end;							tempcell.v := 0;							tempcell.h := 0;							if LGetSelect(true, tempCell, XFerList) then							begin								if tempCell.v <= sysopNumFiles then								begin									LRect(r, tempCell, XFerList);									if localpt.h < ((intDLStuff^^.dr[sysopDirNum].fileNameLength * 6) + 2) then									begin										r.left := 2;										r.right := (intDLStuff^^.dr[sysopDirNum].fileNameLength * 6) + 1;										nameOrDesc := true;									end									else if localPt.h > (intDLStuff^^.dr[sysopdirnum].filenamelength + 10) * 6 + 2 then									begin										r.left := ((intDLStuff^^.dr[sysopDirNum].fileNameLength + 10) * 6) + 2;										nameOrDesc := false;									end									else									begin										SysopExtDesc(sysopOpenDir^^[tempCell.v], sysopDirNum);										didSomething := true;										SetPort(theDialog);										t5 := GenFileNote(tempCell.v);										LSetCell(pointer(ord4(@t5) + 1), length(t5), tempCell, XFerList);									end;									if not didSomething then									begin										SFXferTE := TENew(r, r);										SFXferTE^^.txFont := 150;										SFXferTE^^.txSize := 9;										SFXferTE^^.crOnly := -1;										SFXferTE^^.lineHeight := 11;										SFXferTE^^.fontAscent := 9;										if nameOrDesc then											TESetText(@sysopOpenDir^^[tempCell.v].flName[1], length(sysopOpenDir^^[tempCell.v].flName), SFXferTE)										else											TESetText(@sysopOpenDir^^[tempCell.v].flDesc[1], length(sysopOpenDir^^[tempCell.v].flDesc), SFXferTE);										InvalRect(r);										TEActivate(SFXferTE);										beingRenamed := tempCell.v;									end;								end;							end;						end						else if beingRenamed >= 0 then						begin							ClearRename(theDialog);						end;					end;				end;				otherwise					SysBeep(10);			end;			tempcell.v := 0;			tempcell.h := 0;			if LGetSelect(true, tempCell, XFerList) then			begin				GetDItem(theDialog, 15, kind, h, r);				HiLiteControl(controlHandle(h), 0);				GetDItem(theDialog, 14, kind, h, r);				HiLiteControl(controlHandle(h), 0);			end			else			begin				GetDItem(theDialog, 15, kind, h, r);				HiLiteControl(controlHandle(h), 255);				GetDItem(theDialog, 14, kind, h, r);				HiLiteControl(controlHandle(h), 255);			end;			SetRect(r, theDialog^.portRect.right - 15, theDialog^.portRect.bottom - 15, theDialog^.portRect.right, theDialog^.portRect.bottom);			if PtInRect(localPt, r) then			begin				SetRect(r, 499, 299, 499, 900);				growReturn := GrowWindow(theDialog, theEvent.where, r);				if growReturn <> 0 then				begin					SizeWindow(theDialog, loWord(growReturn), hiWord(growReturn), true);					LDispose(XFerList);					GetDItem(theDialog, 11, kind, h, r);					r.bottom := theDialog^.portRect.bottom - 14;					SetDItem(theDialog, 11, kind, handle(@DrawXFerList), r);					SetPort(theDialog);					rView := r;					rView.bottom := theDialog^.portRect.bottom;					EraseRect(rView);					InvalRect(theDialog^.portRect);					rView := r;					rView.right := rView.right - 15;					InsetRect(rView, 1, 1);					dataBounds.topLeft := Point(0);					dataBounds.bottom := 0;					databounds.Right := 1;					cSize.v := 11;					cSize.h := rView.right - rView.left;					XFerList := LNew(rView, dataBounds, cSize, 2056, theDialog, FALSE, FALSE, FALSE, TRUE);					XFerList^^.selFlags := lNoNilHilite;					FillXFerList;				end;				localPt := point($00000000);				LocalToGlobal(localPt);				theEvent.where := localPt;			end;		end;	end;	procedure SysopFileConfigure;		var			typeList: SFTypeList;			t1: str255;			atPt: point;	begin		if intDLStuff^^.numdirs > 0 then		begin			if SysOpenDirectory(0) then				;			if sysopOpenDir = nil then			begin				sysopNumFiles := 0;				sysopOpenDir := aDirHand(NewHandle(0));				HNoPurge(handle(sysopOpenDir));				sysopDirNum := 0;			end;			XferNeedsUpdate := false;			beingRenamed := -1;			maskFiles := false;			SFXferTE := nil;			if gMac.systemVersion >= $0700 then				SFPGetFile(Point($00280005), '', @sysopFileFilter, -1, typeList, @SysopUploadHook, replySF, 7070, @xferlistmodal)			else				SFPGetFile(Point($00280005), '', @sysopFileFilter, -1, typeList, @SysopUploadHook, replySF, 6767, @xferlistmodal);			SysCloseDirectory;		end		else			ProblemRep('You must first set up your transfer directories.');	end;end.