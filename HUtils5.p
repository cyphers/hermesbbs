unit HUtils5;interface	uses		Processes, AppleTalk, ADSP, Serial, Sound, SANE, Initial, NodePrefs, inpout2, InpOut, User, terminal, SystemPrefs, Message_Editor, fileTrans, FileTrans2, HUtilsTWO, HermesUtils, notification, PPCToolbox, Processes, EPPC, AppleEvents, HUtils3, HUtils4;	procedure IdleUser;	procedure PixelToBBSPos (thePixel: point; var thetextpos: point);	procedure HighlightChar (whichChar: point);	procedure HandleSelection (aPoint: point; theEvent: EventRecord);	procedure VActionProc (control: ControlHandle; part: INTEGER);	procedure StartSS;	procedure EndSS;	procedure DrawSSInfo;implementation	const		GrayRgn = $09EE;		MBarHeight = $0BAA;	type		RgnHdlPtr = ^RgnHandle;		WordPtr = ^INTEGER;	var		ourProcess, savedFProcess: ProcessSerialNumber;	procedure StartSS;		var			screenRgn, savedGray, newGray: RgnHandle;			same: boolean;	begin		screenSaver := true;		if (gMac.systemVersion >= $0700) then		begin			result := GetFrontProcess(savedFProcess);			result := GetCurrentProcess(ourProcess);			result := SameProcess(savedFProcess, ourProcess, same);			if not same then				result := SetFrontProcess(ourProcess);		end;		gMBarHeight := WordPtr(MBarHeight)^;		WordPtr(MBarHeight)^ := 0;		screenRgn := NewRgn;		RectRgn(screenRgn, screenBits.bounds);		savedGray := RgnHdlPtr(GrayRgn)^;		newGray := NewRgn;		UnionRgn(screenRgn, savedGray, newGray);		RgnHdlPtr(GrayRgn)^ := newGray;		ssWind := NewWindow(nil, screenBits.bounds, '', true, 2, pointer(-1), false, 0);		SetPort(ssWind);		BackColor(blackColor);		EraseRect(screenBits.bounds);		RgnHdlPtr(GrayRgn)^ := savedGray;		DisposeRgn(newGray);		HideCursor;		lastSSDraw := 0;	end;	procedure EndSS;		var			clobberedRgn: RgnHandle;			savePort: GrafPtr;			wMgrPort: GrafPtr;	begin		screenSaver := false;		WordPtr(MBarHeight)^ := gMBarHeight;		if (gMac.systemVersion >= $0700) then			result := SetFrontProcess(savedFProcess);		DisposeWindow(ssWind);		ssWind := nil;		HiliteMenu(0);		DrawMenuBar;		ShowCursor;	end;	procedure DrawSSInfo;		var			infoStr: array[1..10] of str255;			ts: str255;			i, maxLen, b: integer;			stp: point;			noUsersOn: boolean;	begin		noUsersOn := true;		for i := 1 to intSystRec.numNodes do			if (theNodes[i]^.boardMode = User) or (theNodes[i]^.boardMode = answering) then				noUsersOn := false;		SetPort(ssWind);		BackColor(blackColor);		ForeColor(whiteColor);		EraseRect(screenBits.bounds);		if noUsersOn then		begin			TextSize(9);			TextFont(3);		end		else		begin			TextFont(0);			TextSize(16);		end;		maxLen := 0;		for i := 1 to intSystRec.numNodes do		begin			NumToString(i, infoStr[i]);			case (theNodes[i]^.boardMode) of				waiting: 					if noUsersOn then						infoStr[i] := GetStatLine					else						infoStr[i] := '';				failed: 					infoStr[i] := 'Initialization failed';				terminal: 					infoStr[i] := 'Terminal';				answering: 					infoStr[i] := concat(infoStr[i], ': Logon in progress');				user: 				begin					if theNodes[i]^.thisUser.userNum > 0 then					begin						infoStr[i] := concat(infoStr[i], ': ', theNodes[i]^.thisUser.userName);						case (theNodes[i]^.boardSection) of							Logon: 								ts := 'Logging on';							NewUser: 								ts := 'New User';							MainMenu: 								ts := 'Main Menu';							rmv: 								ts := 'Removing Messages';							MoveFiles: 								ts := 'Moving Files';							killMail: 								ts := 'Killing Mail';							autoval: 								ts := 'Auto Validating';							Batch: 								ts := 'Batch Transferring';							MultiChat: 								ts := 'Multiuser Chat';							tranDef: 								ts := 'Transfer Defaults';							MultiMail: 								ts := 'Multi-Mail';							Noder: 								ts := 'Examining Nodes';							messUp: 								ts := 'Uploading Message';							renFiles: 								ts := 'Renaming Files';							readAll: 								ts := 'Reading All Mail';							RmvFiles: 								ts := 'Removing Files';							GFiles: 								ts := 'Reading GFiles';							UEdit: 								ts := 'Editing Users';							USList: 								ts := 'Listing Users';							BBSlist: 								ts := 'BBS List';							chUser: 								ts := 'Switching User';							limdate: 								ts := 'Limiting Date';							Download: 								ts := 'Downloading';							Sort: 								ts := 'Sorting Files';							Upload: 								ts := 'Uploading Files';							OffStage: 								ts := 'Logging Off';							ListFiles: 								ts := 'Listing Files';							post: 								ts := 'Posting Message';							ChatStage: 								ts := 'Chatting';							Defaults: 								ts := 'Defaults';							Email, ReadMail: 								ts := 'Reading Mail';							qscan: 								ts := 'Reading Messages ';							Amsg: 								ts := 'Setting Auto-message';							Transfers: 								ts := 'Transfer Menu';							Ext: 								ts := 'Selecting External';							EXTERNAL: 								ts := 'Using External';							ScanNew: 								ts := 'Scanning Messages';							otherwise								NumToString(longint(theNodes[i]^.boardSection), ts);						end;						infoStr[i] := concat(infoStr[i], ' : ', ts);						if theNodes[i]^.triedChat then							infoStr[i] := concat(infoStr[i], ' <<CHAT>>');					end					else						infoStr[i] := concat(infoStr[i], ': Logon in progress');				end;				otherwise			end;			b := StringWidth(infoStr[i]);			if (b > maxLen) then				maxLen := b;		end;		SetPt(stp, 0, 0);		b := (screenbits.bounds.right - maxLen);		if b > 0 then			stp.h := (ABS(RANDOM) mod b) + 1;		b := (screenbits.bounds.bottom - (intSystRec.numNodes * 20));		if b > 0 then			stp.v := (ABS(RANDOM) mod b) + 16;		lastSSDraw := TickCount;		for i := 1 to intSystRec.numNodes do		begin			if infoStr[i] <> '' then			begin				MoveTo(stp.h, stp.v);				DrawString(infoStr[i]);				if noUsersOn then					exit(drawSSInfo);				stp.v := stp.v + 20;			end;		end;	end;	procedure VActionProc (control: ControlHandle; part: INTEGER);		var			amount: INTEGER;			window: WindowPtr;			theT: TEHandle;	begin		if part <> 0 then		begin			window := control^^.contrlOwner;			theT := TEHandle(windowPeek(window)^.refCon);			case part of				inUpButton, inDownButton: 					amount := 1;												{one line}				inPageUp, inPageDown: 					amount := (theT^^.viewRect.bottom - theT^^.viewRect.top) div theT^^.lineHeight;	{one page}				otherwise			end;			if (part = inDownButton) | (part = inPageDown) then				amount := -amount;												{reverse direction}			CommonAction(control, amount);			if amount <> 0 then				TEPinScroll(0, amount * theT^^.lineHeight, theT);		end;	end; {VActionProc}	procedure IdleUser;		var			tempLong, tempLong2: longint;			i, b: integer;			savePort: GrafPtr;			tempstring: str255;			mysavedBD: BDact;	begin		with curglobs^ do		begin			if (BoardMode = User) and not sysopLogon and (hangingUp < 0) then			begin				if UserHungUp then				begin					if myTrans.active then					begin						extTrans^^.flags[carrierLoss] := true;						ClearInBuf;						repeat							ContinueTrans;						until not myTrans.active;					end;					if (thisUser.userNum) > 0 then						sysopLog(retinstr(17, 2), 6);					HangupAndReset;				end;			end;			if not myTrans.active then			begin				if TabbyPaused then				begin					if (length(SavedInPort) > 0) then					begin						if FSOpen('ActivateNode.temp', 0, i) = noErr then						begin							result := FSClose(i);							result := FSDelete('ActivateNode.temp', 0);							CloseComPort;							InPortName := SavedInPort;							SavedInPort := '';							TabbyPaused := false;							OpenComPort;							HangUpAndReset;						end;					end;				end;				if hangingUp >= 0 then					HangUpAndReset;				if ((BoardMode = Failed) and ((lastTry + 1800) < tickCount)) or ((BoardMode = Waiting) and ((lastTry + 72000) < tickCount)) then					HangUpAndReset;				i := isMyBBSwindow(frontWindow);				if (i > 0) and (tickCount > (lastBlink + getCaretTime)) then				begin					if not gBBSwindows[i]^.scrollFreeze and (visibleNode = activeNode) then					begin						if (gBBSwindows[i]^.cursorRect.top > gBBSwindows[i]^.ansiRect.top) and (gBBSwindows[i]^.cursorRect.right <= gBBSwindows[i]^.ansiRect.right) then						begin							GetPort(savePort);							with gBBSwindows[i]^ do							begin								SetPort(ansiPort);								InvertRect(cursorRect);								cursorOn := not cursorOn;							end;							lastBlink := tickCount;							SetPort(savePort);						end;					end;				end;				if (toBeSent <> nil) then				begin					if (nodeType = 2) then					begin						if (nodeDSPWritePtr^.ioResult <> 1) then							if AsyncMWrite(outputRef, 0, nil) <> noErr then								;					end					else if (nodeType = 1) then					begin						if (myBlocker.ioResult <> 1) then							if AsyncMWrite(outputRef, 0, nil) <> noErr then								;					end;				end;				if (BoardMode = Answering) then				begin					if (tickCount > (lastKeyPressed + 14400)) then						HangUpAndReset;				end				else if (BoardMode = Terminal) then				begin					if dialing and not waitdialresponse then						doDialIdle;				end				else if (BoardMode = User) and (hangingUp < 0) then				begin					if prompting then					begin						if (BoardSection <> Post) and (BoardSection <> Email) and (BoardSection <> NewUser) and (BoardSection <> Logon) then						begin							if (ticksLeft(activeNode) <= 0) then							begin								bCR;								tempstring := retinstr(17, 3);								OutLine(tempstring, true, 0);								sysopLog(concat('      ', tempstring), 0);								HangupAndReset;								exit(idleUser);							end;						end;					end;					tempLong := tickCount;					if timeFlagged then					begin						if (tempLong > (lastKeyPressed + longint(timeout * 60 * 60))) then						begin							timeFlagged := false;							OutLine(retinstr(17, 6), true, 6);							OutLine('', false, 0);							bCR;							Delay(30, tempLong);							sysopLog('      ***TIMEOUT***', 0);							HangupAndReset;							exit(idleUser);						end;					end					else if (tempLong > (lastkeyPressed + longint((timeOut * 60 * 60) div 2))) then					begin						if (sysopStop or (not inZScan and not continuous and not ((BoardSection = ListFiles) and (ListDo = ListFour)) and not (BoardAction = Repeating))) and not TimeFlagged then						begin							mySavedBD := BoardAction;							BoardAction := none;							bCR;							OutChr(char(7));							NumToString(timeout, tempstring);							OutLine(concat(Retinstr(17, 4), tempstring, retinstr(17, 5)), false, 6);							if thisUser.canANSI then								dom(0);							bCR;							BoardAction := mySavedBD;							timeFlagged := true;							if BoardAction = Writing then								ListLine(online)							else if boardAction = Prompt then								ReprintPrompt;						end;					end;					if (myBlocker.ioResult <> 1) and (BoardAction = ListText) then						ListTextFile					else if ((BoardAction = none) or (BoardAction = Repeating)) then						if not SysopStop then							SetBookmark;					if (lnsPause >= thisUser.ScrnHght) then					begin						if thisUser.PauseScreen and not listingHelp and not continuous and not inZScan then						begin							if BoardAction <> ListText then								bCR;							savedBdAction := BoardAction;							InPause := true;							PausePrompt(retinstr(17, 7));						end;					end;				end;				if (hangingUp < 0) then				begin					tempLong := GetHandleSize(handle(sysopkeyBuffer));					if tempLong > 0 then					begin						i := 0;						while (i < tempLong) and (BoardAction <> none) and (BoardAction <> ListText) do						begin							doSysopKey(sysopKeyBuffer^^[i], false);							i := i + 1;						end;						BlockMove(pointer(ord4(sysopKeyBuffer^) + i), pointer(sysopKeyBuffer^), GetHandleSize(handle(sysopKeyBuffer)) - i);						SetHandleSize(handle(sysopKeyBuffer), getHandleSize(handle(sysopKeyBuffer)) - i);					end;					if not stopRemote then					begin						if not sysopLogon then							CheckForChars;						if (BoardMode = Terminal) and (XferAutoStart = 2) then						begin							if XFerAutoStart = 2 then								DoMenuCommand(longint($03F10007));							XferAutoStart := 0;						end;						i := length(typeBuffer);						if i > 0 then						begin							if (i > 80) then								i := 80;							b := 1;							while (b <= i) and (BoardAction <> none) and (BoardAction <> ListText) do							begin								doSerialChar(typeBuffer[b]);								b := b + 1;							end;							if (b > 1) then								delete(typeBuffer, 1, b - 1);						end;					end;				end;			end			else				ContinueTrans;		end;	end;end.