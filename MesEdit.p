unit Message_Editor;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, systemprefs, NodePrefs;	procedure Update_Message_Editor (theWindow: WindowPtr);	procedure Open_Message_Editor;	procedure OpenBase (whichForum, whichSub: integer; extraRec: boolean);	procedure CloseBase;	procedure SaveBase (wForum, wSub: integer);	procedure LoadFileAsMsg (name: str255);	procedure AddLine (toAdd: str255);	procedure DeletePost (whForum, whSub, whMesg: integer; delePost: boolean);	function takeMsgTop: str255;	procedure SaveNetMail;	procedure Do_Message_Editor (theEvent: EventRecord; theWindow: WindowPtr; itemHit: integer);	procedure Close_Message_Editor (theWindow: WindowPtr);	function SaveMessAsEmail: boolean;	procedure DoBoardsStuff (writeIt: boolean);	procedure LoadHelpFile;	procedure HeReadIt (ReadMa: eMailRec);	function LoadSpecialText (myText: charsHandle; which: integer): boolean;	procedure DeleteMail (whichNum: longint);	function isPostRatioOK: boolean;	procedure AddListString (theString: Str255; theList: ListHandle);	procedure OpenEmail;	procedure CloseEmail;	procedure FindMyEmail;	procedure SaveEmailData;	function OpenMData (wforum, wsub: integer): integer;	function SaveMessage (storageType: boolean; charsToSave: TextHand; wForum, wSub: integer): longint;	function ReadMessage (storageType: boolean; storedAs: longint; wForum, wSub: integer): TextHand;	procedure RemoveMessage (storageType: boolean; storedAs: longint; wforum, wsub: integer);	function SavePost (wForum, wSub: integer): boolean;	procedure SaveNetPost;	function OptionDown: boolean;implementation	var		List_I_List1: ListHandle;		Rect_I_List1, MPOPUPRECT: Rect;		Popup_I_Forum: integer;		ExitDialog: Boolean;		tempRect: Rect;		DType: Integer;		Index: Integer;		DItem: Handle;		CItem, CTempItem: controlhandle;		sTemp: Str255;		itemHit: Integer;		temp: Integer;		dataBounds: Rect;		cSize: Point;		ChangedSelection: boolean;		tempMenu: MenuHandle;	procedure DeleteMail;		var			tempStored: longint;			i, theNum, twoNum: integer;	begin		theNum := whichNum;		if (theEmail <> nil) and (theNum >= 0) and (theNum < availEmails) then		begin			if theEmail^^[theNum].multiMail then			begin				twoNum := -1;				tempStored := theEmail^^[theNum].storedAs;				for i := 1 to availEmails do					if (theEmail^^[i - 1].storedAs = tempStored) and ((i - 1) <> theNum) then						twoNum := i;				if twoNum = -1 then					RemoveMessage(true, theEmail^^[theNum].storedAs, 0, 0);			end			else if theEmail^^[theNum].MType = 1 then				RemoveMessage(true, theEmail^^[theNum].storedAs, 0, 0);			if (availEmails - 1) > theNum then			begin				BlockMove(@theEmail^^[theNum + 1], @theEmail^^[theNum], longint(availEmails - 1 - theNum) * SizeOf(emailRec));			end;			SetHandleSize(handle(theEmail), GetHandleSize(handle(theEmail)) - SizeOf(emailRec));			availEmails := availEmails - 1;			emailDirty := true;			SaveEmailData;			emailDirty := false;		end;	end;	procedure FindMyEmail;		var			i: integer;			numOfEm: integer;	begin		with curGlobs^ do		begin			if myEmailList <> nil then				SetHandleSize(handle(myEmailList), 0)			else				myEmailList := intListHand(NewHandle(0));			HNoPurge(handle(myEmailList));			if (theEmail <> nil) and (availEmails > 0) then			begin				numOfEm := 0;				for i := 1 to availEmails do				begin					if (theEmail^^[i - 1].toUser = thisUser.userNum) and (theEmail^^[i - 1].MType = 1) then					begin						numOfEm := numOfEm + 1;						SetHandleSize(handle(myEmailList), getHandleSize(handle(myEmailList)) + 2);						myEmailList^^[numOfEm - 1] := i - 1;					end;				end;			end;		end;	end;	procedure SaveEmailData;		var			result: OSerr;			MailRef, i: integer;			count: longInt;			pathToEm: str255;	begin		if emailDirty and (theEmail <> nil) then		begin			HLock(handle(theEMail));			pathToEm := concat(IntSystRec.MsgsPath, 'Email:EMail Data');			result := FSDelete(pathToEm, 0);			result := Create(pathToEm, 0, 'HRMS', 'DATA');			result := FSOpen(pathToEm, 0, MailRef);			if result = noErr then			begin				count := GetHandleSize(handle(theEmail));				result := FSWrite(MailRef, count, pointer(theEmail^));				result := FSClose(MailRef);			end;			HUnLock(handle(theEMail));		end;	end;	procedure CloseEMail;	begin		with curglobs^ do		begin			if (theEmail <> nil) then			begin				if emailDirty then					SaveEmailData;				emailDirty := false;				HUnlock(handle(theEmail));			end;		end;	end;	procedure OpenEMail;		var			result: OSerr;			EMRef, b, i: integer;			tempLong: longInt;			numAvail: longint;	begin		if (theEmail = nil) then		begin			result := FSOpen(concat(IntSystRec.MsgsPath, 'Email:', 'EMail Data'), 0, EMRef);			if result = noErr then			begin				result := GetEOF(EMref, tempLong);				availEmails := tempLong div SizeOf(emailRec);				theEmail := mesghand(NewHandle(longint(availEmails) * SizeOf(emailRec)));				HNoPurge(handle(theEmail));				if memError = noErr then				begin					tempLong := longint(availEmails) * SizeOf(emailRec);					HLock(handle(theEmail));					result := FSRead(emRef, tempLong, pointer(theEmail^));					HUnlock(handle(theEmail));					emailDirty := false;				end				else				begin					availEmails := 0;					SysBeep(10);				end;				result := FSClose(EMref);			end			else			begin				theEmail := mesgHand(NewHandle(0));				HNoPurge(handle(theEmail));				emailDirty := false;				availEmails := 0;			end;		end;	end;	procedure DeletePost;		var			MessDataHnd: MesgHand;			result: OSerr;			tempString, tempString2, s2, s3: str255;			MesgRef, tempInt, i: integer;			AllRecsSize, tempLong: longint;			tempBool: boolean;			tempMesg: MesgRec;			booshi: handle;	begin		with curglobs^ do		begin			NumToString(whForum, s2);			NumToString(whSub, s3);			tempstring := concat(intSystRec.msgsPath, 'for', s2, ':Sub Data#', s3);			result := FSOpen(tempString, 0, mesgRef);			if result = noErr then			begin				result := GetEOF(mesgRef, AllRecsSize);				if (AllRecsSize div SizeOf(mesgRec)) >= whMesg then				begin					result := SetFPos(mesgRef, fsFromStart, longint(whMesg - 1) * SizeOf(mesgRec));					tempLong := SizeOf(mesgrec);					result := FSRead(mesgref, templong, @tempMesg);					if (AllRecsSize - SizeOf(MesgRec) * longint(whMesg)) > 0 then					begin						booshi := NewHandle(AllRecsSize - SizeOf(MesgRec) * longint(whMesg));						if memerror = 0 then						begin							HLock(handle(booshi));							tempLong := AllRecsSize - SizeOf(MesgRec) * longint(whMesg);							result := FSRead(mesgRef, tempLong, pointer(booshi^));							result := SetFPos(mesgRef, fsFromStart, longint(whMesg - 1) * SizeOf(mesgRec));							tempLong := AllRecsSize - SizeOf(MesgRec) * longint(whMesg);							result := FSWrite(mesgRef, tempLong, pointer(booshi^));							HUnlock(handle(booshi));							DisposHandle(handle(booshi));						end						else							SysBeep(1);					end;					result := SetEOF(mesgRef, AllRecsSize - SizeOf(mesgRec));					result := FSClose(mesgRef);					if allrecsSize - (SizeOf(MesgRec)) <= 0 then						result := FSDelete(tempString, 0);					if delePost then					begin						RemoveMessage(tempMesg.storageType, tempMesg.storedAs, whForum, whSub);					end;					if curBase <> nil then					begin						if whMesg <= curNumMess then						begin							if (whMesg < curNumMess) then							begin								BlockMove(@curBase^^[whMesg], @curBase^^[whMesg - 1], Sizeof(mesgRec) * longint(curNumMess - whMesg));							end;							curNumMess := curNumMess - 1;						end;					end;				end				else					result := FSClose(mesgRef);			end;		end;	end;	function OpenMData (wforum, wsub: integer): integer;		var			s, s1: str255;			myRef, i: integer;			templong: longint;	begin		with curglobs^ do		begin			if curIndex <> nil then			begin				HPurge(handle(curIndex));				DisposHandle(handle(curIndex));				curIndex := nil;			end;			NumToString(wForum, s);			NumToString(wSub, s1);			if wForum > 0 then				s1 := concat(intSystRec.msgsPath, 'for', s, ':Sub', s1, ' Messages')			else				s1 := concat(intSystRec.msgsPath, 'Email:Email Text');			result := FSOpen(s1, 0, myRef);			if result <> noErr then			begin				result := Create(s1, 0, 'HRMS', 'MESG');				result := FSOpen(s1, 0, myRef);				curIndex := IndxHand(NewHandle(Sizeof(indxRec)));				MoveHHi(handle(curIndex));				HNoPurge(handle(curIndex));				for i := 0 to 2047 do					curIndex^^[i] := 0;				tempLong := SizeOf(indxRec);				result := FSWrite(myRef, tempLong, pointer(curIndex^));				result := SetEOF(myRef, longint(4096) + longint(76800));			end			else			begin				curIndex := IndxHand(NewHandle(Sizeof(indxRec)));				MoveHHi(handle(curIndex));				HNoPurge(handle(curIndex));				tempLong := SizeOf(indxRec);				result := FSRead(myRef, tempLong, pointer(curIndex^));			end;			OpenMData := Myref;		end;	end;	procedure RemoveMessage (storageType: boolean; storedAs: longint; wforum, wsub: integer);		var			theref: integer;			csec, nsec, templong: longint;			t1, t2: str255;	begin		with curglobs^ do		begin			if storageType then			begin				theref := OpenMData(wforum, wsub);				csec := storedas;				while (csec > 0) and (csec < 2048) do				begin					nsec := curIndex^^[csec];					curIndex^^[csec] := 0;					csec := nsec;				end;				result := SetFPos(theref, fsFromStart, 0);				templong := sizeOf(indxrec);				result := FSWrite(theRef, tempLong, pointer(curIndex^));				result := FSClose(theref);			end			else			begin				NumToString(storedAs, t1);				NumToString(wForum, t2);				result := FSDelete(concat(intSystrec.msgsPath, 'for', t2, ':', t1), 0);			end;		end;	end;	function SaveMessage (storageType: boolean; charsToSave: TextHand; wForum, wSub: integer): longint;  {returns the stored as value}		var			mLength, templong, l1: longint;			theref, gatp, i5, i4: integer;			gati: array[0..49] of integer;			t1, t2: str255;	begin		with curglobs^ do		begin			if storageType then			begin				mLength := GetHandleSize(handle(charsToSave));				theref := OpenMData(wForum, wSub);				gatp := 0;				i5 := (mLength + 511) div 512;				i4 := 1;				while (gatP < i5) and (i4 < 2048) do				begin					if (curIndex^^[i4] = 0) then					begin						gati[gatp] := i4;						gatP := gatP + 1;					end;					i4 := i4 + 1;				end;				if (i4 >= 2048) then					saveMessage := -1				else				begin					gati[gatp] := -1;					i4 := 0;					while i4 < i5 do					begin						result := SetFPos(theRef, fsFromStart, sizeof(indxRec) + ((longint(512)) * (longint(gati[i4]))));						templong := 512;						result := FSWrite(theRef, templong, @charsToSave^^[i4 * 512]);						curIndex^^[gati[i4]] := gati[i4 + 1];						i4 := i4 + 1;					end;					result := SetFPos(theRef, fsFromStart, 0);					tempLong := Sizeof(indxRec);					result := FSWrite(theRef, templong, pointer(curIndex^));					saveMessage := gati[0];				end;				result := FSClose(theRef);			end			else			begin				NumToString(curmesgrec.qScnPtr, t1);				NumToString(wForum, t2);				t2 := concat(intSystrec.msgsPath, 'for', t2, ':', t1);				result := Create(T2, 0, 'HRMS', 'TEXT');				result := FSOpen(T2, 0, theref);				if result = noErr then				begin					l1 := GetHandleSize(handle(charsToSave));					HLock(handle(charsTosave));					result := FSWrite(theRef, l1, pointer(charsToSave^));					HUnlock(handle(charsTosave));					result := FSClose(theRef);				end;				SaveMessage := curmesgrec.qScnPtr;			end;		end;	end;	function ReadMessage (storageType: boolean; storedAs: longint; wForum, wSub: integer): TextHand;		var			theRef: integer;			l1, l2, templong, csec: longint;			tempchars: Texthand;			t1, t2: str255;	begin		with curglobs^ do		begin			if storageType then			begin				theRef := OpenMData(wForum, wSub);				csec := storedAs;				l1 := 0;				while (csec > 0) and (csec < 2048) do				begin					l1 := l1 + 512;					csec := curIndex^^[csec];				end;				if l1 = 0 then				begin					readMessage := nil;					result := FSClose(theRef);					exit(readMessage);				end;				tempChars := TextHand(NewHandle(l1));				if memerror <> noErr then				begin					readMessage := nil;					result := FSClose(theRef);					exit(readMessage);				end;				HNoPurge(handle(tempChars));				csec := storedAs;				l1 := 0;				while (csec > 0) and (csec < 2048) do				begin					result := SetFPos(theRef, fsFromStart, longint(4096) + (longint(512) * longint(csec)));					templong := 512;					result := FSRead(theRef, templong, @tempChars^^[l1]);					l1 := l1 + templong;					csec := curIndex^^[csec];				end;				result := FSClose(theRef);				l2 := l1 - 512;				while (l2 < l1) and (tempchars^^[l2] <> char(26)) do					l2 := l2 + 1;				SetHandleSize(handle(tempChars), l2);				MoveHHi(handle(tempChars));			end			else			begin				NumToString(storedAs, t1);				NumToString(wForum, t2);				result := FSOpen(concat(intSystrec.msgsPath, 'for', t2, ':', t1), 0, theref);				if result = noErr then				begin					result := GetEOF(theRef, l1);					tempChars := TextHand(NewHandle(l1));					MoveHHi(handle(tempChars));					HLock(handle(tempChars));					HNoPurge(handle(tempChars));					result := FSRead(theRef, l1, pointer(tempchars^));					HUnlock(handle(tempChars));					result := FSClose(theRef);					if tempChars^^[l1 - 1] = char(26) then						SetHandleSize(handle(tempChars), l1 - 1);				end				else					tempChars := nil;			end;			readMessage := tempchars;		end;	end;	function SavePost (wForum, wSub: integer): boolean;		var			s, s1: str255;			myRef: integer;			templong: longint;	begin		with curglobs^ do		begin			curMesgRec.storedAs := SaveMessage(curmesgRec.storageType, curWriting, wForum, wSub);			if (curMesgRec.storedAs <> -1) then			begin				NumToString(wForum, s);				NumToString(wSub, s1);				s := concat(intSystRec.msgsPath, 'for', s, ':Sub Data#', s1);				result := FSOpen(s, 0, myRef);				if result <> noErr then				begin					result := Create(s, 0, 'HRMS', 'DATA');					result := FSOpen(s, 0, myRef);				end;				result := SetFPos(myRef, fsFromLEOF, 0);				tempLong := SizeOf(mesgRec);				result := FSWrite(myRef, tempLong, @curMesgRec);				result := FSClose(myRef);				SavePost := true;			end			else				SavePost := false;		end;	end;	function isPostRatioOK: boolean;		var			tempReal, tempReal2, tempReal3: real;	begin		tempReal := curglobs^.thisUser.messagesPosted;		tempReal2 := curglobs^.thisUser.totalLogons;		tempReal3 := intSystRec.secLevels[curglobs^.thisUser.secLevel].postRatioOneTo;		if tempReal3 = 0 then			tempreal3 := 1;		if (tempReal / tempReal2) >= (1 / tempReal3) then			isPostRatioOK := TRUE		else			isPostRatioOK := FALSE;	end;	function takeMsgTop: str255;		var			i, b, c: longint;			ts: str255;	begin		with curglobs^ do		begin			i := GetHandleSize(handle(curWriting));			b := 0;			while (b < i) and (curWriting^^[b] <> char(13)) do				b := b + 1;			if curWriting^^[b] = char(13) then			begin				if (b < 80) then				begin					ts := '';					for c := 1 to (b) do						ts := concat(ts, '.');					BlockMove(@curWriting^^[0], @ts[1], b);					BlockMove(@curWriting^^[b + 1], @curWriting^^[0], i - (b + 1));					SetHandleSize(handle(curWriting), i - (b + 1));					takemsgTop := ts;				end				else					takeMsgTop := '';			end			else				takemsgtop := '';		end;	end;	procedure AddLine (toAdd: str255);		var			i, b: longint;	begin		with curglobs^ do		begin			toAdd := concat(toAdd, char(13));			i := length(toAdd);			b := getHandleSize(handle(curWriting));			SetHandleSize(handle(curWriting), b + i);			BlockMove(@curWriting^^[0], @curWriting^^[i], b);			BlockMove(@toAdd[1], pointer(curWriting^), i);		end;	end;	function LoadSpecialText (myText: charsHandle; which: integer): boolean;		var			numChars, searchPos, i, searchPos2: integer;	begin		with curglobs^ do		begin			LoadSpecialText := false;			if mytext <> nil then			begin				numChars := GetHandleSize(handle(myText));				if textHnd <> nil then				begin					HPurge(handle(texthnd));					DisposHandle(handle(textHnd));				end;				textHnd := nil;				CurTextPos := 0;				OpenTextSize := 0;				SysopStop := false;				SearchPos := 0;				i := 0;				while (i <> which) and (SearchPos < numChars) do				begin					if (myText^^[SearchPos] = char(24)) then						i := i + 1;					SearchPos := SearchPos + 1;				end;				if (i = which) then				begin					while (myText^^[searchPos] <> char(13)) and (searchPos < numChars) do						SearchPos := searchPos + 1;					SearchPos := SearchPos + 1;					SearchPos2 := SearchPos;					while (MyText^^[searchPos2] <> char(24)) and (SearchPos2 < numChars) do					begin						SearchPos2 := SearchPos2 + 1;					end;					SearchPos2 := SearchPos2 - 1;					SearchPos2 := SearchPos2 - SearchPos;					TextHnd := Texthand(NewHandle(SearchPos2));					MoveHHi(handle(textHnd));					HNoPurge(handle(textHnd));					OpenTextSize := SearchPos2;					curtextPos := 0;					BlockMove(@myText^^[searchPos], @textHnd^^[0], SearchPos2);					LoadSpecialText := true;				end;			end;		end;	end;	procedure LoadHelpFile;		var			myTempStr: str255;			sharedref, i: integer;			myHUtils2: CharsHandle;			LENGTH, cksm: longint;	begin		HelpFile := nil;		UseResFile(RShared);		HelpFile := CharsHandle(GetNamedResource('HTxt', 'Help'));		if (ResError = noErr) and (HelpFile <> nil) then		begin			DetachResource(handle(HelpFile));			MoveHHi(handle(HelpFile));			HNoPurge(handle(HelpFile));		end;		useResFile(myResourceFile);	end;	procedure LoadFileAsMsg (name: str255);		var			tempint: integer;			templong: longint;	begin		with curglobs^ do		begin			if curWriting <> nil then			begin				HPurge(handle(curWriting));				DisposHandle(handle(curwriting));			end;			curwriting := nil;			result := FSOpen(name, 0, tempint);			if (result <> 0) then			begin				name := concat(sharedPath, name);				result := FSOpen(name, 0, tempint);			end;			if (result = 0) then			begin				result := GetEOF(tempint, templong);				curWriting := TextHand(NewHandle(templong));				HNoPurge(handle(curWriting));				MoveHHi(handle(curWriting));				result := FSRead(tempint, templong, pointer(curWriting^));				result := FSClose(tempint);				SetHandleSize(handle(curWriting), getHandleSize(handle(curWriting)) + 1);				curWriting^^[getHandleSize(handle(curWriting)) - 1] := char(26);			end;		end;	end;	procedure HeReadIt;		var			tempEM: emailrec;			tempInt: integer;	begin		GetDateTime(tempEM.dateSent);		tempEM.title := '';		if not myUsers^^[readMa.touser - 1].dltd then		begin			tempEM.fromUser := ReadMa.toUser;			tempEM.touser := ReadMa.fromUser;			tempEM.anonyFrom := false;			if readma.anonyFrom then				tempEM.anonyFrom := true;			tempEM.anonyTo := false;			tempEM.MType := 0;			tempEM.multimail := false;			tempEM.storedAs := 0;			for tempInt := 0 to 9 do				tempEM.reserved[tempint] := char(0);			SetHandleSize(handle(theEmail), GetHandleSize(handle(theEmail)) + SizeOf(emailRec));			BlockMove(@tempEm, @theEmail^^[availEmails], sizeof(emailrec));			availEmails := availEmails + 1;			emailDirty := true;		end;	end;{$D-}	function FindCell (mousPos: point): cell;		var			startCell, selCell: cell;			temprect: rect;	begin		StartCell := cell($00000000);		selCell := cell($FFFFFFFF);		repeat			LRect(temprect, startCell, List_I_List1);			if PtInRect(mousPos, tempRect) then				selCell := startCell;		until not LNextCell(false, true, startCell, List_I_list1);		FindCell := selcell;	end;	function myListDragger: boolean;		var			myCell, myCell2: cell;			tempRect: rect;			tempBool, tempbool2, tb3: boolean;			tempsub: subboardrec;			curMouse: point;			addLine, i, useddiff, tempint: integer;			movedTo, hDiff, vDiff: longint;			takeThis, toHere: integer;			dragged: rgnHandle;			MovingBrds: array[1..30] of subBoardRec;			bbk: string[41];	begin		tempbool2 := true;		SetPort(getESelection);		myCell := LLastClick(List_I_List1);		myCell2 := cell($00000000);		tempbool := LGetSelect(true, myCell2, list_I_list1);		if (longint(myCell) = longint(mycell2)) and (myCell.v >= 0) and (myCell.v < List_I_list1^^.dataBounds.bottom) and tempBool and (myCell2.v < List_I_list1^^.dataBounds.bottom) then		begin			if (longint(myCell) = longint(DragFirst)) then			begin				myCell2.h := 0;				myCell2.v := 0;				LRect(temprect, myCell, List_I_List1);				dragged := NewRgn;				OpenRgn;				FrameRect(tempRect);				CloseRgn(dragged);				movedTo := DragGrayRgn(dragged, List_I_List1^^.clikLoc, List_I_List1^^.rView, GetESelection^.portRect, vAxisOnly, nil);				DisposeRgn(dragged);				vDiff := hiWord(movedTo);				hDiff := LoWord(movedTo);				usedDiff := temprect.top + abs(vDiff);				if ((vDiff <> $8000) and (hDiff <> $8000)) and (abs(usedDiff - tempRect.top) > 8) then				begin					curMouse.v := list_I_List1^^.clikLoc.v + vDiff;					curmouse.h := list_I_List1^^.clikLoc.h + hDiff;					myCell2 := FindCell(curMouse);					if (longint(mycell2) <> $FFFFFFFF) and (longint(mycell2) <> longint(myCell)) then					begin						if forumsub then						begin							takeThis := myCell.v + 1;							toHere := myCell2.v + 1;							for i := 1 to 30 do								MovingBrds[i] := intMessStuff^^.boards[takethis, i];							for i := 1 to 30 do								intmessStuff^^.boards[takeThis, i] := intMessStuff^^.boards[toHere, i];							for i := 1 to 30 do								intMessStuff^^.boards[toHere, i] := movingBrds[i];							tempint := intMessStuff^^.numBoards[takeThis];							intMessStuff^^.numBoards[takeThis] := intMessStuff^^.numBoards[toHere];							IntMessStuff^^.numBoards[toHere] := tempInt;							bbk := intMessStuff^^.forums[takeThis];							intMessStuff^^.forums[takeThis] := intMessStuff^^.forums[toHere];							intMessStuff^^.forums[toHere] := bbk;							LDelRow(0, 0, List_I_List1);							for i := 1 to intMessStuff^^.numForums do							begin								AddListString(intMessStuff^^.Forums[i], List_I_List1);							end;						end						else						begin							takeThis := myCell.v + 1;							toHere := myCell2.v + 1;							tempSub := intmessStuff^^.boards[editForum, takeThis];							intMessStuff^^.boards[editforum, takethis] := intMessStuff^^.boards[editForum, toHere];							intMessStuff^^.boards[editForum, toHere] := tempsub;							LDelRow(0, 0, List_I_List1);							for i := 1 to intMessStuff^^.numBoards[editForum] do							begin								AddListString(intMessStuff^^.Boards[editForum, i].Name, List_I_List1);							end;						end;					end;				end;			end;			DragFirst := myCell;		end;		myListDragger := tempbool2;	end;{$D+}	procedure RePopUp;		var			wid, i: integer;			myPop: popupHand;	begin		GetDItem(getESelection, 2, DType, DItem, tempRect);		CItem := Pointer(DItem);		myPop := popupHand(Citem^^.contrlData);		wid := CountMItems(myPop^^.mHandle);		for i := wid downto 1 do		begin			DelMenuItem(myPop^^.mHandle, i);		end;		AppendMenu(myPop^^.mHandle, 'Forums');		for i := 1 to intMessStuff^^.numForums do			AppendMenu(myPop^^.mHandle, intMessStuff^^.forums[i]);	end;	procedure Update_Message_Editor;		var			SavedPort: GrafPtr;	begin		if (getESelection <> nil) and (theWindow = getESelection) then		begin			GetPort(SavedPort);			SetPort(getESelection);			EraseRect(getESelection^.portRect);			tempRect := Rect_I_List1;			tempRect.Right := tempRect.Right - 15;			if (tempRect.Right <= (tempRect.Left + 10)) then				tempRect.Right := tempRect.Left + 10;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			TextFont(monaco);			TextSize(9);			LUpdate(getESelection^.visRgn, List_I_List1);			DrawDialog(getESelection);			SetPort(SavedPort);		end;	end;	procedure AddListString (theString: Str255; theList: ListHandle);		var			theRow: integer;	begin		if (theList <> nil) then		begin			cSize.h := 0;			theRow := LAddRow(1, 9000, theList);			cSize.v := theRow;			sTemp := theString;			LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);		end;	end;	procedure Open_Message_Editor;		var			Index, i: integer;			theRow: integer;			sTemp: Str255;			ThisEditText: TEHandle;			TheDialogPtr: DialogPeek;	begin		if (getESelection = nil) then		begin			DoBoardsStuff(false);			getESelection := GetNewDialog(209, nil, Pointer(-1));			ShowWindow(getESelection);			SelectWindow(getESelection);			SetPort(getESelection);			TheDialogPtr := DialogPeek(GetESelection);			ThisEditText := TheDialogPtr^.textH;			HLock(Handle(ThisEditText));			ThisEditText^^.txSize := 9;			TextSize(9);			TextFont(monaco);			ThisEditText^^.txFont := monaco;			ThisEditText^^.fontAscent := 9;			ThisEditText^^.lineHeight := 9 + 2 + 0;			HUnLock(Handle(ThisEditText));			forumSub := true;			GetDItem(GetESelection, 5, DType, DItem, tempRect);			Rect_I_List1 := tempRect;			tempRect := Rect_I_List1;			tempRect.Right := tempRect.Right - 15;			if (tempRect.Right <= (tempRect.Left + 15)) then				tempRect.Right := tempRect.Left + 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			InsetRect(tempRect, 1, 1);			SetRect(dataBounds, 0, 0, 1, 0);			cSize.h := tempRect.Right - tempRect.Left;			cSize.v := 11;			List_I_List1 := LNew(tempRect, dataBounds, cSize, 0, getESelection, FALSE, FALSE, FALSE, TRUE);			List_I_List1^^.selFlags := lOnlyOne + lNoNilHilite;			List_I_List1^^.lClikLoop := @myListDragger;			for i := 1 to intMessStuff^^.numForums do			begin				AddListString(intMessStuff^^.Forums[i], List_I_List1);			end;			LdoDraw(TRUE, List_I_List1);			cSize.v := 0;			cSize.h := 0;			LSetSelect(TRUE, cSize, List_I_List1);			RePopup;			GetDItem(GetESelection, 2, DType, DItem, tempRect);			CItem := Pointer(DItem);			SetCtlValue(CItem, 1);		end		else			SelectWindow(getESelection);	end;	procedure Close_Message_Editor;	begin		if (theWindow = getESelection) and (getESelection <> nil) then		begin			DisposDialog(getESelection);			getESelection := nil;		end;	end;	function OptionDown: boolean;		var			KBNunc: KeyMap;	begin		GetKeys(KBnunc);		charnum := 58 div 8;		bitnum := 7 - (58 mod 8);		optiondown := false;		if (BitTst(@KBNunc, 8 * charnum + bitnum)) then			optiondown := true;	end;	procedure EditSub (new: boolean; inFor, inSub: integer);		var			subEd: dialogPtr;			tempLong: longint;			tempbool: boolean;			t1, t2: str255;			a, adder: integer;			savePort: GrafPtr;	begin		GetPort(savePort);		SubEd := GetNewDialog(888, nil, pointer(-1));		SetPort(SubEd);		if new then		begin			with intMessStuff^^.boards[inFor, inSub] do			begin				name := '';				SLtoRead := 50;				SLtoPost := 50;				MaxMessages := 50;				AnonID := -1;				MinAge := 0;				SubType := 0;				StoreType := true;				restrict := char(0);				threading := false;				echoConf := false;			end;		end;		GetDItem(subEd, 10, DType, DItem, tempRect);		SetIText(DItem, intMessStuff^^.boards[inFor, inSub].name);		GetDItem(subEd, 22, DType, DItem, tempRect);		NumToString(intMessStuff^^.boards[inFor, inSub].SLtoRead, t1);		SetIText(DItem, t1);		GetDItem(subEd, 23, DType, DItem, tempRect);		NumToString(intMessStuff^^.boards[inFor, inSub].SLtoPost, t1);		SetIText(DItem, t1);		GetDItem(subEd, 26, DType, DItem, tempRect);		NumToString(intMessStuff^^.boards[inFor, inSub].MaxMessages, t1);		SetIText(DItem, t1);		GetDItem(subEd, 17, DType, DItem, tempRect);		citem := pointer(ditem);		if intMessStuff^^.boards[infor, insub].anonID = -1 then			SetCtlValue(citem, 1)		else			SetCtlValue(citem, 0);		GetDItem(subEd, 18, DType, DItem, tempRect);		citem := pointer(ditem);		if intMessStuff^^.boards[infor, insub].anonID = 0 then			SetCtlValue(citem, 1)		else			SetCtlValue(citem, 0);		GetDItem(subEd, 35, DType, DItem, tempRect);		citem := pointer(ditem);		if intMessStuff^^.boards[infor, insub].anonID = 1 then			SetCtlValue(citem, 1)		else			SetCtlValue(citem, 0);		GetDItem(subEd, 29, DType, DItem, tempRect);		NumToString(intMessStuff^^.boards[inFor, inSub].MinAge, t1);		SetIText(DItem, t1);		GetDItem(subEd, 11, DType, DItem, tempRect);		if intMessStuff^^.boards[inFor, inSub].restrict <> char(0) then			SetIText(DItem, intMessStuff^^.boards[inFor, inSub].restrict);		GetDItem(subEd, 30, DType, DItem, tempRect);		citem := pointer(ditem);		if intMessStuff^^.boards[infor, insub].threading then			SetCtlValue(citem, 1)		else			SetCtlValue(citem, 0);		GetDItem(subEd, 31, DType, DItem, tempRect);		citem := pointer(ditem);		if intMessStuff^^.boards[infor, insub].storetype then			SetCtlValue(citem, 1)		else			SetCtlValue(citem, 0);		GetDItem(subEd, 32, DType, DItem, tempRect);		citem := pointer(ditem);		if intMessStuff^^.boards[infor, insub].storetype then			SetCtlValue(citem, 0)		else			SetCtlValue(citem, 1);		GetDItem(subEd, 34, DType, DItem, tempRect);		citem := pointer(ditem);		if IntSystRec.tabbyNet then		begin			if intMessStuff^^.boards[infor, insub].echoConf then				SetCtlValue(citem, 1);		end		else		begin			HiLiteControl(cItem, 255);		end;		GetDItem(subEd, 1, DType, DItem, tempRect);		InsetRect(tempRect, -4, -4);		PenSize(3, 3);		FrameRoundRect(tempRect, 16, 16);		repeat			modalDialog(nil, a);			if optiondown then				adder := 1			else				adder := 10;			if (a = 34) then			begin				if intMessStuff^^.boards[infor, inSub].echoConf then					intMessStuff^^.boards[infor, insub].echoConf := false				else					intMessStuff^^.boards[infor, insub].echoConf := true;				GetDItem(subEd, 34, DType, DItem, tempRect);				citem := pointer(ditem);				if intMessStuff^^.boards[infor, insub].echoconf then					SetCtlValue(citem, 1)				else					SetCtlValue(citem, 0);			end			else if (a = 31) or (a = 32) then			begin				if (a = 31) then					intMessStuff^^.boards[infor, insub].storeType := true				else					intMessStuff^^.boards[infor, insub].storeType := false;				GetDItem(subEd, 31, DType, DItem, tempRect);				citem := pointer(ditem);				if intMessStuff^^.boards[infor, insub].storetype then					SetCtlValue(citem, 1)				else					SetCtlValue(citem, 0);				GetDItem(subEd, 32, DType, DItem, tempRect);				citem := pointer(ditem);				if intMessStuff^^.boards[infor, insub].storetype then					SetCtlValue(citem, 0)				else					SetCtlValue(citem, 1);				if intMessStuff^^.boards[infor, insub].storetype then				begin					GetDItem(subEd, 26, DType, DItem, tempRect);					GetIText(DItem, t1);					StringToNum(t1, templong);					if templong > 500 then					begin						ProblemRep('Indexed storage type may not have more than 500 messages.');						setPort(subEd);						GetDItem(subEd, 26, DType, DItem, tempRect);						SetIText(DItem, '500');						intMessStuff^^.boards[inFor, inSub].maxMessages := 500;					end;				end;			end			else if (a = 9) then			begin				if intMessStuff^^.boards[inFor, inSub].SLtoRead <= (255 - adder) then				begin					intMessStuff^^.boards[inFor, inSub].SLtoRead := intMessStuff^^.boards[inFor, inSub].SLtoRead + adder;					GetDItem(subEd, 22, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].SLtoRead, t1);					SetIText(DItem, t1);				end;			end			else if (a = 8) then			begin				if intMessStuff^^.boards[inFor, inSub].SLtoRead >= (0 + adder) then				begin					intMessStuff^^.boards[inFor, inSub].SLtoRead := intMessStuff^^.boards[inFor, inSub].SLtoRead - adder;					GetDItem(subEd, 22, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].SLtoRead, t1);					SetIText(DItem, t1);				end;			end			else if (a = 7) then			begin				if intMessStuff^^.boards[inFor, inSub].SLtoPost <= (255 - adder) then				begin					intMessStuff^^.boards[inFor, inSub].SLtoPost := intMessStuff^^.boards[inFor, inSub].SLtoPost + adder;					GetDItem(subEd, 23, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].SLtoPost, t1);					SetIText(DItem, t1);				end;			end			else if (a = 6) then			begin				if intMessStuff^^.boards[inFor, inSub].SLtoPost >= (0 + adder) then				begin					intMessStuff^^.boards[inFor, inSub].SLtoPost := intMessStuff^^.boards[inFor, inSub].SLtoPost - adder;					GetDItem(subEd, 23, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].SLtoPost, t1);					SetIText(DItem, t1);				end;			end			else if (a = 5) then			begin				if intMessStuff^^.boards[infor, insub].storeType then					DType := 500				else					DType := 999;				if intMessStuff^^.boards[inFor, inSub].maxMessages <= (DType - adder) then				begin					intMessStuff^^.boards[inFor, inSub].maxMessages := intMessStuff^^.boards[inFor, inSub].maxMessages + adder;					GetDItem(subEd, 26, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].maxMessages, t1);					SetIText(DItem, t1);				end;			end			else if (a = 4) then			begin				if intMessStuff^^.boards[inFor, inSub].maxMessages >= (1 + adder) then				begin					intMessStuff^^.boards[inFor, inSub].maxMessages := intMessStuff^^.boards[inFor, inSub].maxMessages - adder;					GetDItem(subEd, 26, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].maxMessages, t1);					SetIText(DItem, t1);				end;			end			else if (a = 3) then			begin				if intMessStuff^^.boards[inFor, inSub].minage <= 98 then				begin					intMessStuff^^.boards[inFor, inSub].minage := intMessStuff^^.boards[inFor, inSub].minage + 1;					GetDItem(subEd, 29, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].minage, t1);					SetIText(DItem, t1);				end;			end			else if (a = 2) then			begin				if intMessStuff^^.boards[inFor, inSub].minage >= 1 then				begin					intMessStuff^^.boards[inFor, inSub].minage := intMessStuff^^.boards[inFor, inSub].minage - 1;					GetDItem(subEd, 29, DType, DItem, tempRect);					NumToString(intMessStuff^^.boards[inFor, inSub].minage, t1);					SetIText(DItem, t1);				end;			end			else if (a = 17) or (a = 18) or (a = 35) then			begin				if (a = 17) then					intMessStuff^^.boards[infor, insub].anonID := -1				else if (a = 18) then					intMessStuff^^.boards[infor, insub].anonID := 0				else					intMessStuff^^.boards[infor, insub].anonID := 1;				GetDItem(subEd, 17, DType, DItem, tempRect);				citem := pointer(ditem);				if intMessStuff^^.boards[infor, insub].anonID = -1 then					SetCtlValue(citem, 1)				else					SetCtlValue(citem, 0);				GetDItem(subEd, 18, DType, DItem, tempRect);				citem := pointer(ditem);				if (intMessStuff^^.boards[infor, insub].anonID = 0) then					SetCtlValue(citem, 1)				else					SetCtlValue(citem, 0);				GetDItem(subEd, 35, DType, DItem, tempRect);				citem := pointer(ditem);				if (intMessStuff^^.boards[infor, insub].anonID = 1) then					SetCtlValue(citem, 1)				else					SetCtlValue(citem, 0);			end			else if (a = 30) then			begin				GetDItem(subEd, 30, DType, DItem, tempRect);				citem := pointer(ditem);				IntMessStuff^^.boards[infor, insub].threading := not intMessStuff^^.boards[infor, insub].threading;				if IntMessStuff^^.boards[infor, insub].threading then					SetCtlValue(citem, 1)				else					SetCtlValue(citem, 0);			end;		until (a = 1);		GetDItem(subEd, 10, DType, DItem, tempRect);		GetIText(DItem, t1);		if length(t1) > 0 then		begin			intMessStuff^^.boards[inFor, inSub].name := t1;			GetDItem(subEd, 11, DType, DItem, tempRect);			GetIText(DItem, t1);			if (length(t1) > 0) and ((t1[1] >= char(65)) and (t1[1] <= char(90))) then				intMessStuff^^.boards[inFor, inSub].restrict := copy(t1, 1, 1)			else				intMessStuff^^.boards[inFor, inSub].restrict := char(0);		end		else			IntMessStuff^^.boards[infor, insub].name := '';		DisposDialog(subEd);		SetPort(savePort);	end;	procedure Do_Message_Editor;		var			Index, i, r, tempInt: integer;			myPt: Point;			ExitDialog, DoubleClick, CmdDown: boolean;			chCode: integer;			MyCmdKey: char;			tempLong: longInt;			tempCell: cell;			UserPickDilg: DialogPtr;			tempString: str255;	begin		ExitDialog := FALSE;		if (getESelection <> nil) and (getESelection = theWindow) then		begin			SetPort(getESelection);			myPt := theEvent.where;			GlobalToLocal(myPt);			GetDItem(getESelection, itemHit, DType, DItem, tempRect);			CItem := Pointer(DItem);					{Handle it real time}			if (itemHit = 2) then			begin				LDoDraw(false, List_I_List1);				GetDItem(getESelection, 2, DType, DItem, tempRect);				CItem := Pointer(DItem);				popup_I_forum := GetCtlValue(CItem);				RePopup;				TextFont(monaco);				TextSize(9);				if Popup_I_Forum = 1 then				begin					LDelRow(0, 0, List_I_List1);					forumSub := true;					for i := 1 to intMessStuff^^.numForums do					begin						AddListString(intMessStuff^^.Forums[i], List_I_List1);					end;				end				else if ((Popup_I_Forum - 1) > 0) and ((Popup_I_Forum - 1) <= intMessStuff^^.numForums) then				begin					LDelRow(0, 0, List_I_List1);					editForum := popup_I_Forum - 1;					ForumSub := false;					for i := 1 to intMessStuff^^.numBoards[Popup_I_Forum - 1] do					begin						AddListString(intMessStuff^^.Boards[popup_I_Forum - 1, i].Name, List_I_List1);					end;				end;				LDoDraw(true, List_I_List1);				InvalRect(List_I_List1^^.rView);			end			else if (itemHit = 5) then			begin				DoubleClick := LClick(myPt, theEvent.modifiers, List_I_List1);				if DoubleClick and forumSub then				begin					tempCell.h := 0;					tempCell.v := 0;					if LGetSelect(true, tempCell, List_I_List1) then					begin						UserPickDilg := GetNewDialog(777, nil, pointer(-1));						ParamText('Enter forum title:', '', '', '');						GetDItem(UserPickDilg, 3, DType, DItem, tempRect);						SetIText(DItem, intMessStuff^^.forums[tempCell.v + 1]);						repeat							ModalDialog(nil, tempint);						until tempint = 1;						GetDItem(UserPickDilg, 3, DType, DItem, tempRect);						GetIText(DItem, tempString);						if length(tempString) > 0 then							intMessStuff^^.forums[tempCell.v + 1] := tempString						else							SysBeep(10);						DisposDialog(UserPickDilg);						LDoDraw(false, List_I_List1);						LDelRow(0, 0, List_I_List1);						forumSub := true;						for i := 1 to intMessStuff^^.numForums do						begin							AddListString(intMessStuff^^.Forums[i], List_I_List1);						end;						LDoDraw(true, List_I_List1);						InvalRect(List_I_List1^^.rView);						RePopup;					end;				end				else if doubleClick and not forumSub then				begin					tempCell.h := 0;					tempCell.v := 0;					if LGetSelect(true, tempCell, List_I_List1) then					begin						EditSub(false, editForum, tempCell.v + 1);						LDoDraw(false, List_I_List1);						LDelRow(0, 0, List_I_List1);						for i := 1 to intMessStuff^^.numBoards[editForum] do						begin							AddListString(intMessStuff^^.boards[editForum, i].name, List_I_List1);						end;						LDoDraw(true, List_I_List1);						InvalRect(List_I_List1^^.rView);					end					else						SysBeep(10);				end;			end			else if (itemHit = 3) then {new}			begin				if forumSub then				begin					if IntMessStuff^^.numForums < 10 then					begin						UserPickDilg := GetNewDialog(777, nil, pointer(-1));						ParamText('Enter forum title:', '', '', '');						repeat							ModalDialog(nil, tempint);						until tempint = 1;						GetDItem(UserPickDilg, 3, DType, DItem, tempRect);						GetIText(DItem, sTemp);						DisposDialog(UserPickDilg);						if (length(sTemp) > 0) and (length(sTemp) < 40) then						begin							AddListString(sTemp, List_I_List1);							intMessStuff^^.numForums := intMessStuff^^.numForums + 1;							intMessStuff^^.forums[intMessStuff^^.numForums] := sTemp;							intMessStuff^^.numBoards[intMessStuff^^.numForums] := 0;							RePopup;						end;					end					else						SysBeep(10);				end				else				begin					if IntMessStuff^^.numBoards[EditForum] < 30 then					begin						EditSub(true, editForum, IntMessStuff^^.numBoards[EditForum] + 1);						if intmessStuff^^.boards[editForum, intmessStuff^^.numBoards[editForum] + 1].name <> '' then						begin							intMessStuff^^.numBoards[editForum] := intMessStuff^^.numBoards[editForum] + 1;							AddListString(intMessStuff^^.boards[editforum, intMessStuff^^.numBoards[editForum]].name, list_i_list1);						end;					end					else						SysBeep(10);				end;			end;			if (itemHit = 4) then			begin				if forumSub then				begin					cSize.h := 0;					cSize.v := 0;					if LGetSelect(true, cSize, List_I_List1) then					begin						LDelRow(1, cSize.v, List_I_List1);						if cSize.v + 1 <> intMessStuff^^.numForums then						begin							for i := (cSize.v + 1) to IntMessStuff^^.numForums do							begin								intMessStuff^^.Forums[i] := intMessStuff^^.forums[i + 1];								intMessStuff^^.numBoards[i] := intMessStuff^^.numBoards[i + 1];								for r := 1 to intMessStuff^^.numBoards[i + 1] do								begin									intMessStuff^^.boards[i, r] := intMessStuff^^.boards[i + 1, r];								end;							end;						end;						intMessStuff^^.numForums := intMessStuff^^.numForums - 1;						RePopup;					end					else						SysBeep(10);				end				else				begin					cSize.h := 0;					cSize.v := 0;					if LGetSelect(true, cSize, List_I_List1) then					begin						LDelRow(1, cSize.v, List_I_List1);						if cSize.v + 1 < 30 then						begin							for i := (cSize.v + 1) to (IntMessStuff^^.numBoards[editForum] - 1) do							begin								intMessStuff^^.boards[editforum, i] := intmessStuff^^.boards[editforum, i + 1];							end;						end;						intMessStuff^^.numBoards[editForum] := intMessStuff^^.numBoards[editForum] - 1;					end					else						SysBeep(10);				end;			end;			if (ItemHit = 1) then			begin				DoBoardsStuff(false);				doSystRec(false);				ExitDialog := TRUE;			end;		end;		if ExitDialog then		begin			Close_Message_Editor(getESelection);			getESelection := nil;		end;	end;	procedure CloseBase;	begin		with curglobs^ do		begin			if (curBase <> nil) then			begin				HPurge(handle(curBase));				DisposHandle(handle(curBase));			end;			curNumMess := 0;			curBase := nil;		end;	end;	procedure OpenBase (whichForum, whichSub: integer; extraRec: boolean);		var			s1, s2, tempString: str255;			ref: integer;			tempLong: longInt;	begin		with curglobs^ do		begin			CloseBase;			NumToString(whichForum, s1);			NumToString(whichSub, s2);			tempstring := concat(intSystRec.msgsPath, 'for', s1, ':Sub Data#', s2);			result := FSOpen(tempString, 0, ref);			if result = noErr then			begin				result := GetEOF(ref, tempLong);				if tempLong > 0 then				begin					if not extraRec then						curBase := SubDyHand(NewHandle(tempLong))					else						Curbase := SubDyHand(NewHandle(tempLong + SizeOf(mesgRec)));					if MemError = noErr then					begin						HNoPurge(handle(curBase));						MoveHHi(handle(curBase));						curNumMess := tempLong div SizeOf(mesgRec);						HLock(handle(curBase));						result := SetFPos(ref, fsFromStart, 0);						result := FSRead(ref, tempLong, pointer(curBase^));						HUnlock(handle(curBase));					end					else					begin						curNumMess := 0;					end;				end				else					curNumMess := 0;				result := FSClose(ref);			end			else			begin				curNumMess := 0;				if extraRec then					Curbase := SubDyHand(NewHandle(SizeOf(mesgRec)))				else					curBase := nil;			end;		end;	end;	procedure SaveBase (wForum, wSub: integer);		var			s1, s2, tempstring: str255;			ref: integer;			templong: longint;	begin		with curglobs^ do		begin			NumToString(wForum, s1);			NumToString(wSub, s2);			tempstring := concat(intSystRec.msgsPath, 'for', s1, ':Sub Data#', s2);			result := FSDelete(tempString, 0);			result := Create(tempstring, 0, 'HRMS', 'DATA');			result := FSOpen(tempstring, 0, ref);			templong := getHandleSize(handle(curBase));			result := FSWrite(ref, templong, pointer(curBase^));			result := FSClose(ref);		end;	end;	procedure DoBoardsStuff (writeIt: boolean);		var			tempFileName: str255;			result: OSerr;			i, sharedRef: integer;			tempLong: longInt;			initMessHand: MDescHand;	begin		UseResFile(RShared);		handle(InitMessHand) := Get1Resource('MesD', 0);		HNoPurge(handle(InitMessHand));		if reserror <> noErr then			sysbeep(10);		if writeIt then			InitMessHand^^ := intMessStuff^^		else			intMessStuff^^ := InitMessHand^^;		if writeIt then		begin			ChangedResource(handle(InitMessHand));			WriteResource(handle(InitMessHand));		end;		HPurge(handle(InitMessHand));		UseResFile(myResourceFile);	end;	procedure dToTabbyDate (theDate: dateTimeRec; var dater: str255; var time: str255);		var			t1: str255;	begin		NumToString(theDate.month, t1);		if length(t1) = 1 then			t1 := concat('0', t1);		dater := t1;		NumToString(theDate.day, t1);		if length(t1) = 1 then			t1 := concat('0', t1);		dater := concat(dater, '/', t1);		NumToString(theDate.year - 1900, t1);		if length(t1) = 1 then			t1 := concat('0', t1);		dater := concat(dater, '/', t1);		NumToString(theDate.hour, t1);		if length(t1) = 1 then			t1 := concat('0', t1);		time := t1;		NumToString(theDate.minute, t1);		if length(t1) = 1 then			t1 := concat('0', t1);		time := concat(time, ':', t1);		NumToString(theDate.second, t1);		if length(t1) = 1 then			t1 := concat('0', t1);		time := concat(time, ':', t1);	end;	procedure CleanMessage;		var			tLen, posit: integer;	begin		with curglobs^ do		begin			tLen := GetHandleSize(handle(curWriting));			posit := 0;			tLen := tLen - 1;			if (tLen + 1) > 0 then			begin				while (posit <= tLen) do				begin					if curWriting^^[posit] = char(3) then					begin						BlockMove(@curWriting^^[posit + 2], @curWriting^^[posit], tLen + 1 - (posit + 2));						SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) - 2);						tLen := tlen - 2;					end					else if curWriting^^[posit] = char(8) then					begin						BlockMove(@curWriting^^[posit + 1], @curWriting^^[posit], tLen + 1 - (posit + 1));						SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) - 1);						tLen := tlen - 1;					end;					posit := posit + 1;				end;			end;		end;	end;	procedure SaveNetPost;		var			tempTabby: tabbyHeader;			tempdstr, temptstr, s: str255;			myRef, i: integer;			templong: longint;			nowDate: dateTimeRec;			TabHeader: string[31];			holder: charsHandle;	begin		with curglobs^ do		begin			with tempTabby do			begin				holder := charsHandle(NewHandle(getHandleSize(handle(curWriting))));				HNoPurge(handle(holder));				BlockMove(pointer(curwriting^), pointer(holder^), GetHandleSize(handle(curWriting)));				TabHeader := 'AEA N/A ';				NumToString(((inforum - 1) * 30) + inSub, s);				if length(s) < 3 then					s := concat('0', s);				if length(s) < 3 then					s := concat('0', s);				for i := 5 to 7 do					tabHeader[i] := s[i - 4];				TabHeader[4] := char(13);				TabHeader[8] := char(13);				GetTime(nowDate);				dToTabbyDate(nowDate, tempdstr, temptstr);				tabHeader := concat(tabHeader, tempdStr, char(13), temptStr, char(13));				CleanMessage;				SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) + 1);				CurWriting^^[getHandleSize(handle(curWriting)) - 1] := char(13);				CurWriting^^[getHandleSize(handle(curWriting)) - 2] := char(0);				s := curMesgRec.title;				if s[1] = char(0) then					delete(s, 1, 1);				AddLine(s);				if curMesgRec.toUserNum = 0 then					AddLine('All')				else					AddLine(curMesgRec.toUserName);				AddLine(thisUser.userName);				AddLine('');				s := concat(tabbyPath, 'Generic Export');				result := FSOpen(s, 0, myRef);				if result <> noErr then				begin					result := Create(s, 0, 'HRMS', 'DATA');					result := FSOpen(s, 0, myRef);				end;				result := SetFPos(myRef, fsFromLEOF, 0);				tempLong := 26;				result := FSWrite(myRef, tempLong, @tabHeader[1]);				tempLong := GetHandleSize(handle(curWriting));				HLock(handle(curWriting));				result := FSWrite(myRef, templong, pointer(curWriting^));				HUnlock(handle(curWriting));				result := FSClose(myRef);				DisposHandle(handle(curWriting));				curWriting := TextHand(holder);			end;		end;	end;	procedure SaveNetMail;		var			tempTabby: tabbyHeader;			tempdstr, temptstr, s: str255;			myRef, i: integer;			templong: longint;			nowDate: dateTimeRec;			TabHeader: string[31];	begin		with curglobs^ do		begin			with tempTabby do			begin				TabHeader := 'AMA N/A ';				TabHeader[4] := char(13);				TabHeader[8] := char(13);				GetTime(nowDate);				dToTabbyDate(nowDate, tempdstr, temptstr);				tabHeader := concat(tabHeader, tempdStr, char(13), temptStr, char(13));				CleanMessage;				SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) + 1);				CurWriting^^[getHandleSize(handle(curWriting)) - 1] := char(13);				CurWriting^^[getHandleSize(handle(curWriting)) - 2] := char(0);				AddLine(curEmailRec.title);				AddLine(myFido.name);				AddLine(thisUser.userName);				AddLine(myFido.atNode);				s := concat(tabbyPath, 'Generic Export');				result := FSOpen(s, 0, myRef);				if result <> noErr then				begin					result := Create(s, 0, 'HRMS', 'DATA');					result := FSOpen(s, 0, myRef);				end;				result := SetFPos(myRef, fsFromLEOF, 0);				tempLong := 26;				result := FSWrite(myRef, tempLong, @tabHeader[1]);				tempLong := GetHandleSize(handle(curWriting));				HLock(handle(curWriting));				result := FSWrite(myRef, templong, pointer(curWriting^));				HUnlock(handle(curWriting));				result := FSClose(myRef);			end;		end;	end;	function SaveMessAsEmail: boolean;		var			s: str255;			myRef, i: integer;			templong: longint;	begin		with curglobs^ do		begin			curEmailrec.storedAs := SaveMessage(TRUE, curWriting, 0, 0);			if (curEmailRec.storedAs <> -1) then			begin				if curEmailRec.multimail then					i := numMultiUsers				else					i := 1;				SetHandleSize(handle(theEmail), GetHandleSize(handle(theEmail)) + (SizeOf(emailRec) * longint(i)));				if not CurEmailRec.multiMail then					BlockMove(@curEmailRec, @theEmail^^[availEmails], SizeOf(emailRec))				else				begin					for i := 1 to numMultiUsers do					begin						curEmailRec.toUser := multiUsers[i];						BlockMove(@curEmailRec, @theEmail^^[availEmails + (i - 1)], SizeOf(emailrec));					end;					i := numMultiusers;				end;				availEmails := availEmails + i;				emailDirty := true;				SaveEMailData;				emailDirty := false;				SaveMessAsEmail := true;			end			else				SaveMessAsEmail := false;		end;	end;end.