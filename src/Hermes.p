program Hermes;	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, terminal, FileTrans, FileTrans2, NodePrefs, SystemPrefs, Message_Editor, User, inpout2, InpOut, HermesUtils, HUtilsTwo, notification, AppleTalk, PPCToolbox, Processes, EPPC, AppleEvents, HUtils3, HUtils4, HUtils5;	function DoCloseWindow (window: WindowPtr): BOOLEAN;	begin		DoCloseWindow := TRUE;		if IsDAWindow(window) then			CloseDeskAcc(WindowPeek(window)^.windowKind)		else if IsAppWindow(window) then			CloseWindow(window);	end;	procedure DoActivate (window: WindowPtr; becomingActive: boolean);		var			tempRgn, clipRgn: RgnHandle;			growRect: Rect;			indWind, id2: integer;	begin		if IsAppWindow(window) then			if becomingActive then			begin				indWind := isMyTextWindow(window);				id2 := isMyBBSwindow(window);				if indWind >= 0 then				begin					with textWinds[indWind] do					begin						SetPort(w);						TEActivate(t);						ShowControl(s);						growRect := w^.portRect;						with growRect do						begin							top := bottom - 15;		{adjust for the scrollbars}							left := right - 15;						end;						InvalRect(growRect);					end;				end				else if id2 > 0 then				begin					if id2 <> visibleNode then						SwitchNode(id2);					ActivateBBSwind(true, id2);				end;			end			else			begin				indWind := isMyTextWindow(window);				id2 := isMyBBSwindow(window);				if indWind >= 0 then				begin					with textWinds[indWind] do					begin						TEDeactivate(t);						HideControl(s);						DrawGrowIcon(w);					end;				end				else if id2 > 0 then				begin					ActivateBBSwind(false, id2);				end;			end;	end;	procedure DoEvent (event: EventRecord; isDil: boolean);		label			2;		var			err, keyInt, itemHit, tempint, part, value, tempEventWhat, i: INTEGER;			window, whichwindow, theWindow: WindowPtr;			hit: BOOLEAN;			isADialog, shiftDown, ignoreresult: boolean;			key, keytwo: char;			tempRgn: rgnHandle;			aPoint: Point;			result: OSerr;			count, StrLeng, templong, growResult: longInt;			yaba, tempString: str255;			dumrect, teRect, tempRect: rect;			control: controlHandle;			tvMenu: menuHandle;			h: handle;	begin		tempEventWhat := event.what;		part := FindWindow(event.where, window);		if (isDil) and (event.what = KeyDown) and (BAnd(event.modifiers, cmdKey) <> 0) then			goto 2;		if isDil then		begin			if (event.what = activateEvt) then			begin				if (windowPtr(event.message) = SysConfig) and (sysConfig <> nil) then				begin					LActivate((BAnd(event.modifiers, activeFlag) <> 0), extList);					if (BAnd(event.modifiers, activeFlag) <> 0) then						CallSysopExternal(activDev, -1, event)					else						CallSysopExternal(deActivDev, -1, event);				end;			end;			if (Event.what = UpDateEvt) then			begin				whichWindow := windowPtr(event.message);				BeginUpdate(whichWindow);				if whichWindow = sysConfig then					UpdateSysConfig(event)				else if whichWindow = GetUSelection then					Update_User_Edit(whichWindow)				else if whichWindow = GetESelection then					Update_Message_Editor(whichwindow)				else if whichwindow = GetDSelection then					UpDateTransferSections(whichWindow)				else if whichWindow = NodeDilg then					UpdateNodePrefs				else if whichWindow = theNodes[visibleNode]^.transDilg then				begin					DrawDialog(theNodes[visibleNode]^.transDilg);					UpdateProgress;				end;				EndUpdate(whichWindow);			end			else if (DialogSelect(event, theWindow, itemhit)) and (event.what = mouseDown) then			begin				if theWindow = SysConfig then					ClickSystemConfig(event, itemHit)				else if theWindow = GetUSelection then					Do_User_Edit(event, itemHit)				else if theWindow = GetESelection then					Do_Message_Editor(event, window, itemHit)				else if theWindow = GetDSelection then					DoTransferSections(event, window, itemHit)				else if theWindow = NodeDilg then					ClickInNodePrefs(event, itemHit)				else if theWindow = theNodes[visibleNode]^.transDilg then					if itemHit = 1 then						AbortTrans;			end;		end		else if not IsDil then2:			case tempEventWhat of				mouseDown: 				begin					case part of						inMenuBar: 						begin							if SysopAvailable then								CheckItem(GetMHandle(mSysop), 3, true)							else								CheckItem(GetMHandle(mSysop), 3, false);							for i := 1 to countMItems(getMHandle(mView)) do								DelMenuItem(getMHandle(mView), 1);							tvMenu := GetMHandle(mView);							for i := 1 to intSystRec.numNodes do							begin								NumToString(i, tempstring);								if (theNodes[i]^.boardMode = User) and (thenodes[i]^.thisUser.userNum > 0) then								begin									tempstring := concat(tempstring, ': ', theNodes[i]^.thisUser.userName);									if theNodes[i]^.triedChat then										tempstring := concat(tempstring, '  CHAT');								end;								AppendMenu(tvMenu, ' ');								SetItem(tvMenu, countMItems(tvMenu), tempstring);								if theNodes[i]^.triedChat then									SetItemStyle(tvMenu, i, [bold]);							end;							CheckItem(tvMenu, visibleNode, true);							AppendMenu(tvMenu, '(-');							AppendMenu(tvMenu, 'Status');							DoMenuCommand(MenuSelect(event.where));						end;						inSysWindow: 							SystemClick(event, window);						inContent: 						begin							tempInt := isMyTextWindow(window);							keyInt := isMyBBSWindow(window);							if window <> FrontWindow then							begin								SelectWindow(window);							end							else if keyInt > 0 then								DoANSIClick(keyInt, event.where, BAnd(event.modifiers, shiftKey) <> 0)							else if (tempint >= 0) then							begin								with textWinds[tempint] do								begin									SetPort(w);									aPoint := event.where;									GlobalToLocal(aPoint);									if PtInRect(aPoint, t^^.viewRect) then									begin										shiftDown := BAnd(event.modifiers, shiftKey) <> 0;	{extend if Shift is down}										TEClick(aPoint, shiftDown, t);									end									else									begin										part := FindControl(aPoint, w, control);										case part of											0: 												;											{do nothing for viewRect case}											inThumb: 											begin												value := GetCtlValue(control);												part := TrackControl(control, aPoint, nil);												if part <> 0 then												begin													value := value - GetCtlValue(control);													if value <> 0 then														if control = s then															TEPinScroll(0, value * t^^.lineHeight, t);												end;											end;											otherwise									{must be page or button}												if control = s then													value := TrackControl(control, aPoint, @VactionProc);										end;									end;								end;							end;						end;						inZoomIn, inZoomOut: 						begin							i := isMyBBSWindow(window);							if i > 0 then							begin								if TrackBox(window, event.where, part) then								begin									with gBBSwindows[i]^ do									begin										SetPort(window);										tempRect := ansiPort^.portRect;										LocalToGlobal(tempRect.topLeft);										LocalToGlobal(tempRect.botRight);										GrowBBSwindow(i, savedWPos.right - savedWPos.left, savedWPos.bottom - savedWPos.top);										MoveWindow(window, savedWPos.left, savedWPos.top, false);										savedWPos := tempRect;									end;								end;							end;						end;						inGoAway: 							if TrackGoAway(Window, Event.where) then							begin								i := isMyTextWindow(window);								part := ismyBBSwindow(window);								if (part > 0) then								begin									CloseANSIWindow(part);								end								else if i >= 0 then								begin									CloseTextWindow(i);								end								else if window = statWindow then									CloseStatWindow								else if (GetWRefCon(window) = 4444) then									CloseNodePrefs								else if window = SysConfig then									CloseSystemConfig								else if (GetWRefCon(window) = 5555) then								begin									doDLstuff(true);									CloseTransferSections(window);								end								else if (GetWRefCon(window) = 8888) then								begin									Close_User_Edit(window, false);									statChanged := true;								end								else if (GetWRefCon(window) = 9999) then								begin									doBoardsStuff(true);									doSystRec(true);									Close_Message_Editor(window);								end;							end;						inDrag: 						begin							if window <> FrontWindow then							begin								SelectWindow(window);							end							else							begin								dumrect := screenbits.bounds;								SetRect(dumRect, dumRect.Left + 5, dumRect.Top + 25, dumRect.Right - 5, dumRect.Bottom - 5);								DragWindow(window, event.where, dumRect);							end;						end;						inGrow: 						begin							tempInt := isMyTextWindow(window);							keyInt := isMyBBSWindow(window);							if window = statWindow then							begin								with screenBits.bounds do									SetRect(tempRect, 64, 20, 512, 280);								growResult := GrowWindow(window, event.where, tempRect);								if growResult <> 0 then								begin									SizeWindow(window, LoWrd(growResult), HiWrd(growResult), TRUE);								end;							end							else if (KeyInt > 0) then							begin								with screenBits.bounds do									SetRect(tempRect, HERMESFONTWIDTH * 20 + NOTHINGSPACE * 2 + 16, HERMESFONTHEIGHT * 7 + NOTHINGSPACE * 2, HERMESFONTWIDTH * 80 + NOTHINGSPACE * 2 + 16, bottom);								growResult := GrowWindow(window, event.where, tempRect);								if growResult <> 0 then								begin									GrowBBSWindow(keyInt, loWrd(growResult), hiWrd(growResult));								end;							end							else if (tempInt >= 0) then							begin								with textWinds[tempint] do								begin									with screenBits.bounds do										SetRect(tempRect, 150, 64, 501, bottom);									growResult := GrowWindow(w, event.where, tempRect);									if growResult <> 0 then									begin											{see if changed size}										tempRect := t^^.viewRect;										SizeWindow(w, LoWrd(growResult), HiWrd(growResult), TRUE);										SetPort(w);										t^^.viewRect.bottom := (HiWord(growResult) - 18);										t^^.viewRect.right := (LoWord(growResult) - 18);										AdjustViewRect(t);										MoveControl(s, w^.portRect.right - 15, -1);										SizeControl(s, 16, (w^.portRect.bottom - w^.portRect.top) - 13);										AdjustScrollbars(tempInt, TRUE);										AdjustTE(tempInt);										HiLiteControl(s, 0);										if ((t^^.viewRect.bottom - t^^.viewRect.top) div 11) > t^^.nLines then											HiLiteControl(s, 255);										InvalRect(w^.portRect);									end;								end;							end;						end;					end;				end;				driverEvt: 				begin				end;				keyDown, autoKey: 				begin					if not isDAWindow(frontWindow) then					begin						DoKeyDetect(event);					end;				end;				activateEvt: 					DoActivate(WindowPtr(event.message), BAnd(event.modifiers, activeFlag) <> 0);				updateEvt: 					DoUpdate(WindowPtr(event.message));				diskEvt: 					if HiWrd(event.message) <> noErr then					begin						SetPt(aPoint, kDILeft, kDITop);						err := DIBadMount(aPoint, event.message);					end;				kHighLevelEvent: 				begin					result := AEProcessAppleEvent(event);				end;				kOSEvent: 					case BAnd(BRotL(event.message, 8), $FF) of	{high byte of message}						kSuspendResumeMessage: 						begin							gInBackground := BAnd(event.message, kResumeMask) = 0;							DoActivate(FrontWindow, not gInBackground);						end;					end;			end;	end;	procedure EventLoop;		var			gotEvent, isDil, noUsersOn, recognizedZero: boolean;			event: EventRecord;			mouse, saveMouse: Point;			tempDate, tempDate2: DateTimeRec;			tempLong, tempLong2, lastActEvent: longInt;			i, b: integer;			t1: str255;	begin		lastidle := tickCount;		lastActEvent := tickCount;		recognizedZero := false;		repeat			curGlobs := theNodes[visibleNode];			activeNode := visibleNode;			noUsersOn := true;			for i := 1 to intSystRec.numNodes do				if theNodes[i]^.boardMode = User then					noUsersOn := false;			GetGlobalMouse(mouse);			if not screenSaver then			begin				if (intSystRec.screenSaver[0] = 1) then				begin					if not recognizedZero and (((mouse.h = 0) and (mouse.v = 0)) or (tickCount - lastActEvent > (longint(intSystRec.screenSaver[1]) * longint(60) * longint(60)))) then					begin						recognizedZero := true;						saveMouse := mouse;						StartSS;					end;					AdjustCursor(mouse, cursorRgn);				end;			end			else			begin				if (TickCount - lastSSDraw > 420) then					DrawSSInfo;			end;			if noUsersOn then				gotEvent := WaitNextEvent(everyEvent, event, 10, cursorRgn)			else				gotEvent := WaitNextEvent(everyEvent, event, 0, cursorRgn);			if not EqualPt(saveMouse, event.where) or ((event.what <> nullEvent) and (event.what <> activateEvt) and (event.what <> updateEvt) and (event.what <> app4Evt)) then			begin				if (event.where.h <> 0) or (event.where.v <> 0) then					recognizedZero := false;				lastActEvent := tickCount;				saveMouse := event.where;				if screenSaver then					EndSS;			end;			if frontWindow <> nil then			begin				if isDialogEvent(event) then					isDil := true				else					isDil := false;			end			else				isDil := false;			if (event.what = nullEvent) and (sysConfig <> nil) then				CallSysopExternal(nulDev, -1, event);			if gotEvent or isDil then			begin				AdjustCursor(event.where, cursorRgn);				DoEvent(event, isDil);			end;			if (not gotEvent or ((lastIdle + 15) < tickCount)) and (quit = 0) then			begin				GetTime(tempDate);				if IntSystRec.LastMaint.day <> tempDate.day then					DoDailyMaint;				i := isMytextWindow(frontWindow);				if i >= 0 then					if textWinds[i].editable then						TEIdle(textWinds[i].t);				for i := 1 to numExternals do					if (myExternals^^[i].userExternal) and (myExternals^^[i].allTheTime) then						CallUserExternal(Idle, i);				if ((mppDrvrRefNum <> -1) and (gDSP.ioResult <> 1)) then				begin					i := 1;					while not ((theNodes[i]^.boardMode = Waiting) and (theNodes[i]^.nodeType = 2) and (i <= intSystRec.numNodes)) do						i := i + 1;					if (i <= intSystRec.numNodes) and answerCalls then					begin						curGlobs := theNodes[i];						with curGlobs^ do						begin							activeNode := i;							with nodeDSPPBPtr^ do							begin								ioCRefNum := dspDrvrRefNum;								csCode := dspOpen;								ccbRefNum := nodeCCBRefNum;								ocMode := ocAccept;								ocInterval := 0;								ocMaximum := 0;								remoteCID := gDSP.remoteCID;								remoteAddress := gDSP.remoteAddress;								sendSeq := gDSP.sendSeq;								sendWindow := gDSP.sendWindow;								attnSendSeq := gDSP.attnSendSeq;							end;							result := PBControl(ParmBlkPtr(nodeDSPPBPtr), false);							if (result = noErr) then							begin								currentBaud := 57600;								curBaudNote := ADSPNAME;								sysopLogon := false;								GetDateTime(tempLong);								IUTimeString(tempLong, true, t1);								LogThis(concat('ADSP connection made at ', t1), 0);								DoLogon;							end;						end;					end					else					begin						with gDSP do						begin							csCode := dspCLDeny;							ioCRefNum := dspDrvrRefNum;							ccbRefNum := gCCBRef;						end;						result := PBControl(ParmBlkPtr(@gDSP), false);						if result <> noErr then							sysBeep(10);					end;					StartADSPListener;				end;				for i := 1 to intSystRec.numNodes do				begin					curGlobs := theNodes[i];					activeNode := i;					IdleUser;				end;				if statChanged then				begin					UpdateStatWindow;					statChanged := false;				end;				lastIdle := tickCount;			end;			if IntSystRec.TabbyNet then			begin				GetDateTime(tempLong);				if dailytabbyTime <> 0 then				begin					if tempLong > dailytabbyTime then					begin						for i := 1 to intSystRec.numNodes do						begin							curGlobs := theNodes[i];							activeNode := i;							with curglobs^ do							begin								if myTrans.active then								begin									repeat										extTrans^^.flags[carrierLoss] := true;										ContinueTrans;									until not myTrans.active;								end;							end;							HangUpandReset;						end;						tabbyQuit := true;						quit := 1;					end;				end;			end;			if (quit = 1) and not tabbyQuit then			begin				b := 0;				for i := 1 to intSystRec.numNodes do					if (theNodes[i]^.boardMode = User) then						b := 1;				if (b = 1) then					quit := ModalQuestion(retinstr(17, 1), false, false);			end;		until quit > 0;	end;	procedure GetFinderFiles;		var			fftype, ffnum, i: integer;			theFile: AppFile;			ts: str255;	begin		CountAppFiles(fftype, ffnum);		if (ffnum > 0) and (fftype = 0) then		begin			for i := 1 to ffnum do			begin				GetAppFiles(i, theFile);				if thefile.ftype = 'TEXT' then				begin					ts := PathnameFromWD(thefile.vRefNum);					OpenTextWindow(ts, thefile.fName, false, true);				end				else if theFile.fType = 'MODR' then				begin				end;			end;		end;	end;	function CheckMessagePath: boolean;		var			sTemp: str255;			pbBlock: CInfoPBRec;	begin		checkMessagePath := true;		sTemp := intSystRec.msgsPath;		with pbBlock do		begin			ioCompletion := nil;			ioNamePtr := @sTemp;			ioVRefNum := 0;			ioFDirIndex := 0;		end;		result := PBGetCatInfo(@pbBlock, false);		if (result <> noErr) then		begin			sTemp := concat(sharedPath, 'Messages:');			result := PBGetCatInfo(@pbBlock, false);			if (result = noErr) then			begin				intSystRec.msgsPath := sTemp;				DoSystRec(true);			end;		end;		if (result <> noErr) or OptionDown then		begin			globalStr := 'Select Messages directory:';			stemp := doGetDirectory;			if sTemp <> '' then			begin				intSystRec.msgsPath := sTemp;				DoSystRec(true);			end			else				CheckMessagePath := false;		end;	end;	procedure FindModemDriver;		var			i: integer;	begin		for i := 1 to numModemDrivers do		begin			if EqualString(modemDrivers^^[i - 1].name, curGlobs^.mDriverName, false, false) then				curGlobs^.modemID := i - 1;		end;	end;begin	InitHermes;	OpenAboutBox;	if CheckMessagePath then	begin		intMessStuff := MDescHand(NewHandle(SizeOf(MDescRec)));		MoveHHi(handle(intMessStuff));		HNoPurge(handle(intMessStuff));		intDLStuff := DirDataHand(NewHandle(SizeOf(dirDataFile)));		MoveHHi(handle(intDLstuff));		HNoPurge(handle(intDLstuff));		intGFileHand := GFileSecHand(NewHandle(SizeOf(GFileSecRec)));		MoveHHi(handle(intGFileHand));		HNoPurge(handle(intGFileHand));		DoBoardsStuff(false);		DoDLstuff(false);		DoGFileRec(false);		DoSystRec(true);		LoadHelpFile;		MakeUserList;		UpdateAutoValMenu;		AnalyzeProtocols;		LoadModemDrivers;		MakeExtList;		if theWindPos^^.wIsOpen[0] then			OpenStatWindow;		SetFontVars;		for i := 1 to intSystRec.numNodes do			AllocateANSIWindow(i);		for i := 1 to intSystRec.numNodes do		begin			with theNodes[i]^ do			begin				activeNode := i;				curGlobs := theNodes[i];				OpenComPort;				FindModemDriver;				sendingNow := NewPtr(SENDNOWBUFSIZE);				myBlocker.ioResult := noErr;				toBeSent := nil;				extTrans := nil;				HangupAndReset;			end;		end;		theExtRec := UserXIPtr(NewPtr(SizeOf(UserXInfoRec) + (4 * 17)));		with theExtRec^ do		begin			privates := nil;			totalNodes := intSystRec.numNodes;			message := 0;			curNode := @activeNode;			curUGlobs := @curGlobs;			ResShared := RShared;			DataShared := DShared;			filesPath := @sharedPath;			systemMail := theEMail;			extantEmails := @availEmails;			emailUnclean := @emailDirty;			externals := myExternals;			numExternal := numExternals;			for i := 0 to 255 do				reserved[i] := char(0);			for i := 1 to 10 do				n[i] := theNodes[i];			procs[0] := @bCR;			procs[1] := @OutLine;			procs[2] := @HangupandReset;			procs[3] := @PromptUser;			procs[4] := @LettersPrompt;			procs[5] := @NumbersPrompt;			procs[6] := @YesNoQuestion;			procs[7] := @GoHome;			procs[8] := @BackSpace;			procs[9] := @ANSIPrompter;			procs[10] := @ReadTextFile;			procs[11] := @ReprintPrompt;			procs[12] := @OutChr;			procs[13] := @ANSICode;			procs[14] := @PAUSEPrompt;			procs[15] := @FindUser;			procs[16] := @GiveTime;			procs[17] := @LogThis;		end;		if intSystRec.startDate = 0 then			GetDateTime(intSystRec.startDate);		cursorRgn := NewRgn;		result := CallUtility(BUILDMENU, pointer(@theNodes[visibleNode]^.myProcMenu), longint($03F10001));		if theNodes[visibleNode]^.nodeType = -1 then			DisableItem(getMHandle(mSysop), 8);		DrawMenuBar;		CloseAboutBox;		if IntSystRec.TabbyNet then			doTabbyImport;		if (gMac.systemVersion < $0700) then			GetFinderFiles		else		begin			result := AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, @HandleAEOpenDoc, 0, false);			result := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, @HandleAEQuitApp, 0, false);			result := AEInstallEventHandler('HRMS', 'Logo', @HandleAEHLogoff, 0, false);		end;		EventLoop;		DisposeRgn(cursorRgn);		for i := 1 to intSystRec.numNodes do			DisposeANSIWindow(i);		CloseStatWindow;		CloseEmail;		ChangedResource(handle(theWindPos));		WriteResource(handle(theWindPos));		result := CallUtility(DISPOSETMENU, ptr(theNodes[visibleNode]^.myProcMenu), 0);		CloseNodePrefs;		Close_Message_Editor(GetESelection);		CloseSystemConfig;		Close_User_Edit(getUSelection, true);		CloseTransferSections(getDSelection);		if numTextWinds > 0 then		begin			for i := 1 to numtextWinds do				CloseTextWindow(0);		end;		CloseAboutBox;		for i := 1 to intSystRec.numNodes do		begin			curGlobs := theNodes[i];			activeNode := i;			with curglobs^ do			begin				if (BoardMode = User) and (thisUser.userNum > 0) then					writeUser(thisUser);				if (nodeType = 1) and answerCalls then					TellModem('ATZ');				TerminateRun;			end;		end;		if (mppDrvrRefNum <> -1) then			CloseADSPListener;		DisposHandle(handle(modemDrivers));		if (setNewNodes > 0) then		begin			intSystRec.numNodes := setNewNodes;			DoSystRec(true);		end;		result := FSDelete('Local Workspace', 0);		DisposHandle(handle(myUsers));		if theDials <> nil then		begin			ChangedResource(handle(theDials));			WriteResource(handle(theDials));		end;		if myExternals <> nil then		begin			for i := 1 to numExternals do			begin				if myExternals^^[i].userExternal then				begin					CallUserExternal(CLOSEEXTERNAL, i);					HUnlock(handle(myExternals^^[i].codeHandle));					ReleaseResource(myExternals^^[i].codeHandle);					CloseResFile(myExternals^^[i].UResoFile);				end;				if myExternals^^[i].iconHandle <> nil then				begin					HPurge(myExternals^^[i].iconHandle);					DisposHandle(myExternals^^[i].iconhandle);				end;			end;			DisposHandle(handle(myExternals));			myExternals := nil;		end;	end;	result := FSClose(DShared);	CloseResFile(RShared);	if tabbyQuit then		launchTabby;end.