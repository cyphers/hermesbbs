unit NodePrefs;interface	uses		AppleTalk, ADSP, Serial, Sound, CommResources, CRMSerialDevices, Initial;	procedure ClickInNodePrefs (theEvent: EventRecord; itemHit: integer);	procedure OpenNodePrefs;	procedure UpdateNodePrefs;	function ModalQuestion (askWhat: str255; saveBox, yesNo: boolean): integer;	function TimeToString (theDateTime: longint): str255;	procedure AnalyzeProtocols;	procedure DoCapsName (var doName: str255);	procedure ConOpt2Con (var key: char);	function ConOpt2Num (key: char): integer;	procedure CloseNodePrefs;	function SysopAvailable: boolean;	function isMyTextWindow (theWind: windowPtr): integer;	procedure AdjustViewRect (docTE: TEHandle);	procedure AdjustScrollbars (whichw: integer; needsResize: BOOLEAN);	procedure AdjustTE (whichW: integer);	procedure OpenTextWindow (path, name: str255; isResource: boolean; canEdit: boolean);	procedure CloseTextWindow (accessWind: integer);	procedure SaveTextWindow (accessWind: integer);	function GetMyTime (initialTime: longint; askString: str255): longint;	function AutoValAs (class: str255; pass: str255; passcounts: boolean): boolean;	procedure Init_Node_Prefs;	function doGetDirectory: str255;	procedure ClickForNode (aPoint: point);	procedure UpdateAutoValMenu;	procedure DoAutoValChoice (menuitem: integer);	function FidoNetAccount (toBeParsed: str255): boolean;	procedure KillXFerRec;	procedure InitXFerRec;	function copy1File (inputPath, outputPath: str255): OSErr;	function SelectDirectory (note: str255): integer;	procedure LoadModemDrivers;	procedure CloseComPort;	procedure OpenComPort;	procedure ProblemRep (tellUser: str255);	function RetInStr (resID, index: integer): str255;	function GetFNameFromPath (path: str255): str255;	procedure CloseADSPConnection;	function ADSPBytesToRead: integer;	procedure StartADSPListener;	procedure OpenADSPListener;	procedure CloseADSPListener;	procedure OpenModemFile (name: str255);implementation	var		modDrivList, ListPorts, SDList: ListHandle;		cSize, selectThis: Point;		wasDouble: boolean;		rcList: ListHandle;	function RetInStr (resID, index: integer): str255;		var			ts: str255;	begin		GetIndString(ts, resID, index);		RetInStr := ts;	end;	function GetFNameFromPath (path: str255): str255;		var			marker: integer;	begin		marker := pos(':', path);		while (marker > 0) do		begin			delete(path, 1, marker);			marker := pos(':', path);		end;		GetFNameFromPath := path;	end;	procedure ProblemRep (tellUser: str255);		var			tempDilg: dialogPtr;			a: integer;			DItem: handle;			temprect: rect;			SavePort: GrafPtr;	begin		SysBeep(10);		GetPort(savePort);		tempDilg := GetNewDialog(1055, nil, pointer(-1));		if tempDilg <> nil then		begin			setPort(tempdilg);			GetDItem(tempdilg, 1, a, DItem, tempRect);			InsetRect(tempRect, -4, -4);			PenSize(3, 3);			FrameRoundRect(tempRect, 16, 16);			ParamText(tellUser, '', '', '');			DrawDialog(tempDilg);			repeat				ModalDialog(nil, a);			until (a = 1);			DisposDialog(tempDilg);		end;		SetPort(savePort);	end;	function ModalQuestion (askWhat: str255; saveBox, yesNo: boolean): integer;		var			myTempDilg: dialogPtr;			tempint: integer;			aHandle: handle;			tempRect: rect;			savePort: GrafPtr;	begin		GetPort(savePort);		myTempDilg := GetNewDialog(610, nil, pointer(-1));		SetPort(myTempDilg);		ParamText(askWhat, '', '', '');		GetDItem(myTempDilg, 1, tempInt, aHandle, tempRect);		if saveBox then		begin			SetCTitle(controlHandle(aHandle), 'Save');		end		else if yesNo then		begin			SetCTitle(controlHandle(aHandle), 'Yes');			GetDItem(myTempDilg, 2, tempInt, aHandle, tempRect);			SetCTitle(controlHandle(aHandle), 'No');		end;		if not saveBox or (quit = 1) then		begin			GetDItem(myTempDilg, 5, tempInt, aHandle, tempRect);			HideControl(controlHandle(aHandle));		end;		SetCursor(arrow);		ShowWindow(myTempDilg);		GetDItem(myTempDilg, 1, tempInt, aHandle, tempRect);		InsetRect(tempRect, -4, -4);		PenSize(3, 3);		FrameRoundRect(tempRect, 16, 16);		SysBeep(10);		repeat			modalDialog(nil, tempint);		until (tempint = 1) or (tempInt = 2) or (tempint = 5);		DisposDialog(myTempDilg);		if tempInt = 1 then			ModalQuestion := 1		else if tempint = 2 then			ModalQuestion := 0		else if tempInt = 5 then			ModalQuestion := 2;		SetPort(savePort);	end;	procedure OpenModemFile (name: str255);		var			tr, i: integer;			newModem, tempModem: ModemDriverHand;	begin		tr := OpenResFile(name);		if (tr <> -1) then		begin			newModem := ModemDriverHand(GetResource('MoDr', 1000));			if (newModem <> nil) then			begin				DetachResource(handle(newModem));				UseResFile(myResourceFile);				tempModem := ModemDriverHand(Get1NamedResource('MoDr', newModem^^.name));				if tempModem <> nil then				begin					RmveResource(handle(tempModem));					DisposHandle(handle(tempModem));					for i := 0 to numModemDrivers - 1 do						if EqualString(modemDrivers^^[i].name, newModem^^.name, false, false) then							modemDrivers^^[i] := newModem^^;				end				else				begin					SetHandleSize(handle(modemDrivers), GetHandleSize(handle(modemDrivers)) + SizeOf(modemDriver));					modemDrivers^^[numModemDrivers] := newModem^^;					numModemDrivers := numModemDrivers + 1;				end;				AddResource(handle(newModem), 'MoDr', UniqueID('MoDr'), newModem^^.name);			end;			CloseResFile(tr);		end;	end;	procedure CloseADSPListener;		var			t1: str255;	begin		gMPP.entityPtr := Ptr(ord4(@gNTE.nteData) + 1);		result := PRemoveName(@gMPP, false);		if result <> noErr then		begin			NumToString(result, t1);			ProblemRep(concat('AppleTalk error, RemoveName: ', t1));		end;		with gDSP do		begin			csCode := dspCLRemove;			ioCRefNum := dspDrvrRefNum;			ccbRefNum := gCCBRef;			abort := 1;		end;		result := PBControl(ParmBlkPtr(@gDSP), false);		if result <> noErr then		begin			NumToString(result, t1);			ProblemRep(concat('AppleTalk error, CloseADSP: ', t1));		end;	end;	procedure StartADSPListener;	begin		with gDSP do		begin			csCode := dspCLListen;			ioCRefNum := dspDrvrRefNum;			ccbRefNum := gCCBRef;			filterAddress := AddrBlock(0);		end;		result := PBControl(ParmBlkPtr(@gDSP), true);	end;	procedure OpenADSPListener;	begin		if (mppDrvrRefNum = -1) then		begin			result := OpenDriver('.MPP', mppDrvrRefNum);			if result <> noErr then				exit(OpenADSPListener);			result := OpenDriver('.DSP', dspDrvrRefNum);			if result <> noErr then			begin				ProblemRep('ADSP not installed.  A null port will be created instead.');				exit(OpenADSPListener);			end;			with gDSP do			begin				csCode := dspCLInit;				ioCRefNum := dspDrvrRefNum;				ccbPtr := @gCCB;				localSocket := 0;			end;			result := PBControl(ParmBlkPtr(@gDSP), false);			gCCBRef := gDSP.ccbRefNum;			NBPSetNTE(@gNTE, 'Hermes ', 'ADSP', '*', gDSP.localSocket);			with gMPP do			begin				interval := 7;				count := 3;				entityPtr := @gNTE;				verifyFlag := 0;			end;			result := PRegisterName(@gMPP, false);			if result <> noErr then				SysBeep(10);			StartADSPListener;		end;	end;	function ADSPBytesToRead: integer;	begin		with curGlobs^ do		begin			with nodeDSPPBPtr^ do			begin				csCode := dspStatus;				ioCompletion := nil;				ioCRefNum := dspDrvrRefNum;				ccbRefNum := nodeCCBRefNum;			end;			result := PBControl(ParmBlkPtr(nodeDSPPBPtr), false);			ADSPBytesToRead := nodeDSPPBPtr^.recvQPending;		end;	end;	procedure CloseADSPConnection;	begin		with curGlobs^ do		begin			with nodeDSPPBPtr^ do			begin				csCode := dspClose;				ioCompletion := nil;				ioCRefNum := dspDrvrRefNum;				ccbRefNum := nodeCCBRefNum;				abort := 1;			end;			result := PBControl(ParmBlkPtr(nodeDSPPBPtr), false);			if (result <> noErr) then				SysBeep(10);		end;	end;	procedure CloseComPort;	begin		with curglobs^ do		begin			case nodeType of				1: 				begin					result := KillIO(inputRef);					result := KillIO(outputRef);					result := SerSetBuf(inputRef, @rawBuffer, 0);					if not tabbyQuit then					begin						result := CloseDriver(inputref);						result := CloseDriver(outputRef);					end;				end;				2: 				begin					if (nodeCCBPtr^.state = sOpen) then						CloseADSPConnection;					with nodeDSPPBPtr^ do					begin						csCode := dspRemove;						ioCompletion := nil;						ioCRefNum := dspDrvrRefNum;						ccbRefNum := nodeCCBRefNum;						abort := 1;					end;					result := PBControl(ParmBlkPtr(nodeDSPPBPtr), false);					if (result <> noErr) then						SysBeep(10);					DisposPtr(Ptr(nodeSendCCBPtr));					DisposPtr(Ptr(nodeRecCCBPtr));					DisposPtr(Ptr(nodeAttnCCBPtr));					DisposPtr(Ptr(nodeDSPPBPtr));					DisposPtr(Ptr(nodeDSPWritePtr));					DisposPtr(Ptr(nodeMPPPtr));					DisposPtr(Ptr(nodeCCBPtr));					nodeCCBPtr := nil;				end;				otherwise			end;		end;	end;	procedure OpenComPort;		label			100;		var			tempInt: integer;			tempLong: longint;			t1: str255;			myEvent: EventRecord;	begin		with curglobs^ do		begin			if (inPortName = ADSPNAME) then				nodeType := 2			else if (inportname <> 'None') and (length(inPortName) > 0) then				nodeType := 1			else				nodeType := -1;			case nodeType of				1: 				begin					result := OpenDriver(inportName, inputRef);					if result <> noErr then					begin						ProblemRep(concat('Port: "', inportname, '" is currently in use.  Please free it or select another.'));						goto 100;					end;					result := OpenDriver(outPortName, outputRef);					result := SerSetBuf(inputRef, @rawBuffer, 4096);					result := SerReset(inputRef, data8 + stop10 + noParity + baud19200);				end;				2: 				begin					if nodeCCBPtr = nil then					begin						OpenADSPListener;						nodeCCBPtr := TPCCB(NewPtr(SizeOf(TRCCB)));						nodeSendCCBPtr := NewPtr(ADSPSENDBUFSIZE);						nodeRecCCBPtr := NewPtr(ADSPRECBUFSIZE);						nodeAttnCCBPtr := NewPtr(attnBufSize);						nodeDSPPBPtr := DSPPBPtr(NewPtr(SizeOf(DSPParamBlock)));						nodeDSPWritePtr := DSPPBPtr(NewPtr(SizeOf(DSPParamBlock)));						nodeDSPWritePtr^.ioResult := noErr;						nodeMPPPtr := MPPPBPtr(NewPtr(SizeOf(MPPParamBlock)));						with nodeDSPPBPtr^ do						begin							ioCompletion := nil;							ioCRefNum := dspDrvrRefNum;							csCode := dspInit;							ccbPtr := nodeCCBPtr;							userRoutine := nil;							sendQSize := ADSPSENDBUFSIZE;							recvQSize := ADSPRECBUFSIZE;							sendQueue := nodeSendCCBPtr;							recvQueue := nodeRecCCBPtr;							attnPtr := nodeAttnCCBPtr;							localSocket := 0;						end;						result := PBControl(ParmBlkPtr(nodeDSPPBPtr), false);						if (result <> noErr) then							goto 100;						nodeCCBRefNum := nodeDSPPBPtr^.ccbRefNum;					end;				end;				-1: 				begin100:					nodeType := -1;					inportname := 'None';					inputRef := -1;					outputref := -1;				end;				otherwise			end;		end;	end;	procedure SetTextBox (theDialog: dialogPtr; item: integer; text: str255);		var			dType: integer;			dItem: handle;			tempRect: rect;	begin		GetDItem(theDialog, item, dType, dItem, tempRect);		SetIText(dItem, text);	end;	function GetTextBox (theDialog: dialogPtr; item: integer): str255;		var			dType: integer;			dItem: handle;			tempRect: rect;			t: str255;	begin		GetDItem(theDialog, item, dType, dItem, tempRect);		GetIText(dItem, t);		GetTextBox := t;	end;	procedure SetCheckBox (theDialog: dialogPtr; item: integer; up: boolean);		var			dType: integer;			dItem: handle;			tempRect: rect;	begin		GetDItem(theDialog, item, dType, dItem, tempRect);		if up then			SetCtlValue(controlHandle(dItem), 1)		else			SetCtlValue(controlHandle(dItem), 0);	end;	function GetCheckBox (theDialog: dialogPtr; item: integer): boolean;		var			dType: integer;			dItem: handle;			tempRect: rect;	begin		GetDItem(theDialog, item, dType, dItem, tempRect);		if GetCtlValue(controlHandle(dItem)) = 1 then			GetCheckBox := true		else			GetCheckBox := false;	end;	procedure LoadModemDrivers;		var			numMoDr, i: integer;			moDrHand: ModemDriverHand;	begin		modemDrivers := MoDrListHand(NewHandle(0));		HNoPurge(handle(modemDrivers));		numModemDrivers := 0;		numMoDr := Count1Resources('MoDr');		if numMoDr > 0 then			for i := 1 to numMoDr do			begin				moDrHand := ModemDriverHand(Get1IndResource('MoDr', i));				SetHandleSize(handle(modemDrivers), GetHandleSize(handle(modemDrivers)) + SizeOf(modemDriver));				modemDrivers^^[numModemDrivers] := moDrHand^^;				numModemDrivers := numModemDrivers + 1;			end;	end;	procedure AddListItem (theList: ListHandle; theString: Str255);		var			theRow: integer;			sTemp: str255;	begin		cSize.h := 0;		theRow := LAddRow(1, 200, theList);		cSize.v := theRow;		sTemp := theString;		LSetCell(pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);	end;	function myMDFilter (theDialog: dialogPtr; var ev: EventRecord; var it: integer): boolean;		var			localPt: point;			t: integer;	begin		if (ev.what = mouseDown) then		begin			wasDouble := false;			SetPort(theDialog);			localPt := ev.where;			GlobalToLocal(localPt);			if LClick(localPt, ev.modifiers, rcList) then			begin				wasDouble := true;				selectThis.h := 0;				selectThis.v := 0;				if LGetSelect(true, selectThis, rcList) then					;			end;		end;		myMDFilter := false;	end;	function EditModemDriver (var sdr: modemDriver): boolean;		var			dType, a, i, edr: integer;			dItem: handle;			tempRect, dataBounds: rect;			tempCell: cell;			md: dialogPtr;			td: dialogPeek;			dr: modemDriver;			done, selectNew: boolean;			inp: resultCode;			tte: TEHandle;			t1, t2, t3: str255;		procedure InResult;		begin			NumToString(inp.num, t1);			NumToString(inp.portRate, t2);			NumToString(inp.effRate, t3);			SetTextBox(md, 21, t1);			SetTextBox(md, 22, t2);			SetTextBox(md, 23, t3);			SetTextBox(md, 24, inp.desc);		end;		procedure GetResult;			var				tl: longint;		begin			t1 := GetTextBox(md, 21);			t2 := GetTextBox(md, 22);			t3 := GetTextBox(md, 23);			inp.desc := GetTextBox(md, 24);			StringToNum(t1, tl);			inp.num := tl;			StringToNum(t2, inp.portRate);			StringToNum(t3, inp.effRate);		end;		procedure ResetModemDriverList;			var				i: integer;				tc: cell;		begin			LDoDraw(false, rcList);			tc.h := 0;			tc.v := 0;			if LGetSelect(true, tc, rcList) then				;			LDelRow(0, 0, rcList);			if dr.numResults > 0 then				for i := 0 to dr.numResults - 1 do				begin					NumToString(dr.rs[i].num, t1);					NumToString(dr.rs[i].portRate, t2);					NumToString(dr.rs[i].effRate, t3);					AddListItem(rcList, concat(t1, ',', t2, ',', t3, ',', dr.rs[i].desc));				end;			if selectNew then				tc.v := dr.numResults - 1;			selectNew := false;			LSetSelect(true, tc, rcList);			LAutoScroll(rcList);			LDoDraw(true, rcList);			GetDItem(md, 15, dType, dItem, tempRect);			tempRect.right := tempRect.right - 15;			InsetRect(tempRect, -1, -1);			EraseRect(tempRect);			FrameRect(tempRect);			LUpdate(rcList^^.port^.visRgn, rcList);		end;	begin		done := false;		edr := -1;		md := GetNewDialog(1542, nil, pointer(-1));		SetPort(md);		td := DialogPeek(md);		tte := td^.textH;		HLock(handle(tte));		tte^^.txSize := 9;		tte^^.txFont := geneva;		tte^^.fontAscent := 9;		tte^^.lineHeight := 9 + 2 + 1;		HUnLock(handle(tte));		TextSize(9);		TextFont(geneva);		dr := sdr;		SetTextBox(md, 1, dr.name);		SetTextBox(md, 6, dr.bbsInit);		SetTextBox(md, 7, dr.termInit);		SetTextBox(md, 8, dr.hwOn);		SetTextBox(md, 9, dr.hwOff);		SetTextBox(md, 13, dr.lockOn);		SetTextBox(md, 14, dr.lockOff);		SetTextBox(md, 10, dr.ansModem);		GetDItem(md, 15, dType, dItem, tempRect);		tempRect.right := tempRect.right - 15;		InsetRect(tempRect, -1, -1);		FrameRect(tempRect);		InsetRect(tempRect, 1, 1);		SetRect(dataBounds, 0, 0, 1, 0);		tempCell.h := tempRect.Right - tempRect.Left;		tempCell.v := 12;		rcList := LNew(tempRect, dataBounds, tempCell, 0, md, TRUE, FALSE, FALSE, TRUE);		rcList^^.selFlags := lOnlyOne + lNoNilHilite;		ShowWindow(md);		ResetModemDriverList;		repeat			ModalDialog(@myMDFilter, a);			case a of				21, 22, 23, 24: 				begin					if edr <> -1 then					begin						GetResult;						dr.rs[edr] := inp;						ResetModemDriverList;					end;				end;				15: 				begin					if wasDouble then					begin						if (edr <> -1) then						begin							GetResult;							dr.rs[edr] := inp;							ResetModemDriverList;						end;						edr := selectThis.v;						inp := dr.rs[selectThis.v];						InResult;					end;				end;				25: 				begin					if (edr <> -1) then					begin						GetResult;						dr.rs[edr] := inp;						ResetModemDriverList;					end;					if dr.numResults < 50 then					begin						edr := dr.numResults;						dr.numResults := dr.numResults + 1;						inp.num := 1;						inp.portRate := 300;						inp.effRate := 300;						inp.desc := '300';						dr.rs[edr] := inp;						InResult;						selectNew := true;					end					else						ProblemRep('Sorry, no more than 50 result codes are allowed.');				end;				26: 				begin					tempCell.h := 0;					tempCell.v := 0;					if LGetSelect(true, tempCell, rcList) then					begin						if dr.numResults > tempCell.v + 1 then							for i := tempCell.v + 1 to dr.numResults do								dr.rs[i - 1] := dr.rs[i];						dr.numResults := dr.numResults - 1;						ResetModemDriverList;						edr := -1;					end;				end;				17: 				begin					if (edr <> -1) then					begin						GetResult;						dr.rs[edr] := inp;					end;					done := true;					dr.name := getTextBox(md, 1);					dr.bbsInit := getTextBox(md, 6);					dr.termInit := getTextBox(md, 7);					dr.hwOn := getTextBox(md, 8);					dr.hwOff := getTextBox(md, 9);					dr.lockOn := getTextBox(md, 13);					dr.lockOff := getTextBox(md, 14);					dr.ansModem := getTextBox(md, 10);					sdr := dr;					EditModemDriver := true;				end;				18: 				begin					done := true;					EditModemDriver := false;				end;				otherwise			end;		until done;		LDispose(rcList);		DisposDialog(md);	end;	function DirSelectModal (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			localPt: point;	begin		if theEvent.what = mouseDown then		begin			localPt := theEvent.where;			GlobalToLocal(localPt);			if LClick(localPt, theEvent.modifiers, SDList) then			begin				curglobs^.crossint := 8888;			end;		end;		DirSelectModal := false;	end;	function SelectDirectory (note: str255): integer;		var			SDDilog: dialogPtr;			DType, theRow, a, i: integer;			DItem: handle;			tempRect, dataBounds: rect;			cSize: cell;			sTemp: str255;	begin		curglobs^.crossint := 0;		SDDilog := GetNewDialog(1540, nil, pointer(-1));		SetPort(SDDilog);		ParamText(note, '', '', '');		GetDItem(SDDilog, 3, DType, DItem, tempRect);		tempRect.Right := tempRect.Right - 15;		InsetRect(tempRect, -1, -1);		FrameRect(tempRect);		InsetRect(tempRect, 1, 1);		SetRect(dataBounds, 0, 0, 1, 0);		cSize.h := tempRect.Right - tempRect.Left;		cSize.v := 15;		SDList := LNew(tempRect, dataBounds, cSize, 0, SDDilog, TRUE, FALSE, FALSE, TRUE);		SDLIst^^.selFlags := lOnlyOne + lNoNilHilite;		for i := 1 to intDLStuff^^.numDirs do		begin			cSize.h := 0;			theRow := LAddRow(1, 200, SDLIst);			cSize.v := theRow;			sTemp := intDLStuff^^.dr[i - 1].DirName;			LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, SDLIst);		end;		LDoDraw(TRUE, SDLIst);		ShowWindow(SDDilog);		LUpdate(SDDilog^.visRgn, SDLIst);		GetDItem(SDDilog, 3, DType, DItem, tempRect);		tempRect.Right := tempRect.Right - 15;		InsetRect(tempRect, -1, -1);		FrameRect(tempRect);		repeat			modalDialog(@dirSelectModal, a);		until (a = 1) or (a = 2) or (curglobs^.crossInt = 8888);		if (a = 1) or (curglobs^.crossint = 8888) then		begin			cSize.h := 0;			cSize.v := 0;			if LGetSelect(true, cSize, SDList) then			begin				SelectDirectory := cSize.v;			end			else				SelectDirectory := -1;		end		else			SelectDirectory := -1;		LDispose(SDLIst);		DisposDialog(SDDilog);	end;	function SysopAvailable: boolean;		var			tempLong: LongInt;			tempDate, tempDate2, tempDate3: DateTimeRec;			tempbool: boolean;	begin		tempBool := false;		GetTime(tempDate3);		Secs2Date(intSystRec.opStartHour, tempdate);		Secs2Date(intSystRec.opEndHour, tempdate2);		if not ((tempDate.hour = tempDate2.hour) and (tempDate.minute = tempDate2.minute)) then		begin			if (tempDate2.hour < tempDate.hour) then			begin				if (tempDate3.hour >= tempDate.hour) or (tempDate3.hour <= tempDate2.hour) then					tempBool := true;			end			else			begin				if (tempDate3.hour >= tempDate.hour) and (tempDate3.hour < tempDate2.hour) then					tempBool := true;			end;		end;		if SysopAvailC then			tempBool := not tempBool;		SysopAvailable := tempBool;	end;	procedure SaveTextWindow (accessWind: integer);		var			tempint, fileRef: integer;			name: str255;			myTEH: handle;			tempChars, myTChars: CharsHandle;			tempLong: longint;	begin		with textWinds[accessWind] do		begin			GetWTitle(w, name);			dirty := false;			if wasResource then			begin				UseResFile(RShared);				SetResLoad(false);				myTEH := GetNamedResource('HTxt', name);				SetResLoad(true);				RmveResource(myTEH);				DisposHandle(myTEH);				tempChars := TEGetText(t);				myTChars := CharsHandle(NewHandle(t^^.teLength));				if memerror = noErr then				begin					BlockMove(pointer(tempChars^), pointer(myTChars^), t^^.teLength);					AddResource(handle(myTChars), 'HTxt', UniqueID('HTxt'), name);					if resError <> noErr then						SysBeep(10);					WriteResource(handle(myTChars));					ReleaseResource(handle(myTChars));				end				else					SysBeep(10);				UseResFile(myResourceFile);			end			else			begin				result := FSDelete(concat(origPath, name), 0);				result := Create(concat(Origpath, name), 0, 'HRMS', 'TEXT');				if result = noErr then				begin					result := FSOpen(concat(Origpath, name), 0, fileRef);					if result = noErr then					begin						tempLong := t^^.teLength;						tempChars := TEGetText(t);						result := FSWrite(fileRef, tempLong, pointer(tempChars^));						result := FSClose(fileRef);					end					else						SysBeep(10);				end				else					SysBeep(10);			end;		end;	end;	procedure CloseTextWindow (accessWind: integer);		var			tempint: integer;			name: str255;	begin		with textWinds[accessWind] do		begin			if editable then			begin				getWTitle(w, name);				if dirty then				begin					tempInt := ModalQuestion(concat('Save changes to ''', name, '''?'), true, false);					if tempint = 1 then						SaveTextWindow(accessWind)					else if tempInt = 0 then						exit(closeTextWindow);				end;			end;			TEDispose(t);			DisposeControl(s);			DisposeWindow(w);			if (accessWind + 1) < numTextWinds then			begin				for tempint := accessWind to (numTextWinds - 1) do				begin					textWinds[tempint] := textWinds[tempint + 1];				end;			end;			numTextWinds := numTextWinds - 1;		end;	end;	function isMyTextWindow (theWind: windowPtr): integer;  {returns -1 if not}		var			i: integer;	begin		isMyTextWindow := -1;		if numTextWinds > 0 then		begin			for i := 1 to numTextWinds do				if textWinds[i - 1].w = theWind then					isMyTextWindow := i - 1;		end;	end;{$D-}	procedure AdjustTE (whichW: integer);{Scroll the TERec around to match up to the potentially updated scrollbar}{values. This is really useful when the window resizes such that the}{scrollbars become inactive and the TERec had been previously scrolled.}		var			value: INTEGER;	begin		with textWinds[whichW] do		begin			TEScroll(0, (t^^.viewRect.top - t^^.destRect.top) - (GetCtlValue(s) * t^^.lineHeight), t);		end;	end; {AdjustTE}	procedure AdjustHV (isVert: BOOLEAN; control: ControlHandle; docTE: TEHandle; canRedraw: BOOLEAN);{Calculate the new control maximum value and current value, whether it is the horizontal or}{vertical scrollbar. The vertical max is calculated by comparing the number of lines to the}{vertical size of the viewRect. The horizontal max is calculated by comparing the maximum document}{width to the width of the viewRect. The current values are set by comparing the offset between}{the view and destination rects. If necessary and we canRedraw, have the control be re-drawn by}{calling ShowControl.}		var			value, lines, max: INTEGER;			oldValue, oldMax: INTEGER;	begin		oldValue := GetCtlValue(control);		oldMax := GetCtlMax(control);		if isVert then		begin			lines := docTE^^.nLines;		{since nLines isn’t right if the last character is a return, check for that case}			if Ptr(ORD(docTE^^.hText^) + docTE^^.teLength - 1)^ = 13 then				lines := lines + 1;			max := lines - ((docTE^^.viewRect.bottom - docTE^^.viewRect.top) div docTE^^.lineHeight);		end		else			max := kMaxDocWidth - (docTE^^.viewRect.right - docTE^^.viewRect.left);		if max < 0 then			max := 0;			{check for negative values}		SetCtlMax(control, max);		if isVert then			value := (docTE^^.viewRect.top - docTE^^.destRect.top) div docTE^^.lineHeight		else			value := docTE^^.viewRect.left - docTE^^.destRect.left;		if value < 0 then			value := 0		else if value > max then			value := max;					{pin the value to within range}		SetCtlValue(control, value);		if canRedraw & ((max <> oldMax) | (value <> oldValue)) then			ShowControl(control);			{check to see if the control can be re-drawn}	end; {AdjustHV}	procedure AdjustScrollbars (whichw: integer; needsResize: BOOLEAN);{Turn off the controls by jamming a zero into their contrlVis fields (HideControl erases them}{and we don't want that). If the controls are to be resized as well, call the procedure to do that,}{then call the procedure to adjust the maximum and current values. Finally re-enable the controls}{by jamming a $FF in their contrlVis fields.}		var			oldMax, oldVal: INTEGER;	begin		with textWinds[whichW] do		begin			s^^.contrlVis := 0;{    if needsResize then								}{    AdjustScrollSizes(whichW);}			AdjustHV(TRUE, s, t, not needsResize);			if ((t^^.viewRect.bottom - t^^.viewRect.top) div 11) > t^^.nLines then				HiLiteControl(s, 255)			else				HiliteControl(s, 0);			s^^.contrlVis := $FF;		end;	end;	procedure MyCaretHook;	inline		$4FEF, $0004, $4E75;	procedure FakeTEHook;	begin		myCaretHook;	end;	procedure AdjustViewRect (docTE: TEHandle);{Update the TERec's view rect so that it is the greatest multiple of}{the lineHeight and still fits in the old viewRect.}	begin		with docTE^^ do		begin			viewRect.bottom := (((viewRect.bottom - viewRect.top) div lineHeight) * lineHeight) + viewRect.top;		end;	end; {AdjustViewRect}	procedure PascalClikLoop;{Gets called from our assembly language routine, AsmClikLoop, which is in}{ turn called by the TEClick toolbox routine. Saves the windows clip region,}{ sets it to the portRect, adjusts the scrollbar values to match the TE scroll}{ amount, then restores the clip region.}		var			window: WindowPtr;			region: RgnHandle;			i: integer;	begin		window := FrontWindow;		region := NewRgn;		GetClip(region);					{save the old clip}		ClipRect(window^.portRect);			{set the new clip}		i := isMyTextWindow(window);		AdjustHV(TRUE, textWinds[i].s, textWinds[i].t, true);		SetClip(region);					{restore the old clip}		DisposeRgn(region);	end; {PascalClikLoop}	procedure SaveRegisters;	inline		$48E7, $6040;                        {   MOVEM.L D1/D2/A1,-(A7)  ;Registers _FrontWindow}	procedure CallOldClikLoop (ProcAddr: ProcPtr); {Modified to work with THINK Pascal}	inline		$205F,              {   MOVEA.L (A7)+, A0       ;Get address of function}		$4CDF, $0206, {   MOVEA.L (A7)+,D1/D2/A1  ;Restore registers}		$4E5E,               {   UNLK A6                 ;Restore A6 register}		$4E90,              {   JSR     (A0)            ;Do function}		$4E56, $0000; {   LINK A6,#$0000          ;Restore stack frame}	procedure SetD0;	inline		$7001;                          {   MOVEQ   #1,D0                     ;Return 1 in D0}	function AsmClikLoop: BOOLEAN;	begin		SaveRegisters;		CallOldClikLoop(textWinds[0].docClik);		PascalClikLoop;		SetD0;	end; {AsmClikLoop}{$D+}	procedure OpenTextWindow (path, name: str255; isResource: boolean; canEdit: boolean);		label			500;		var			myRect, sbarRect, texRect: rect;			myTHand: handle;			tempLong: longint;			fileRef: integer;	begin		if numTextWinds < 10 then		begin			numTextWinds := numTextWinds + 1;			with textWinds[numTextWinds - 1] do			begin				wasResource := isResource;				editable := canEdit;				origPath := path;				dirty := false;				SetRect(myRect, 5, 40 + (20 * numTextWinds), 505, screenBits.bounds.bottom - 20);				w := NewWindow(nil, myRect, name, false, 0, pointer(-1), true, 0);				if w = nil then					goto 500;				SetPort(w);				SetRect(sBarRect, w^.portRect.right - 15, -1, w^.portRect.right + 1, w^.portRect.bottom - 14);				s := NewControl(w, sBarRect, '', true, 0, 0, 0, 16, 0);				if s = nil then					goto 500;				SetRect(texRect, 2, 2, w^.portRect.right - 18, w^.portRect.bottom - 18);				t := TENew(texRect, texRect);  {this is DestRect,viewrect}				if t = nil then					goto 500;				windowPeek(w)^.refCon := longint(t);				t^^.crOnly := 1;				t^^.txFont := 150;				t^^.txSize := 9;				t^^.lineHeight := 11;				t^^.fontAscent := 9;				docClik := t^^.clikLoop;				t^^.clikLoop := @AsmClikLoop;				if not editable then					t^^.caretHook := @FakeTEHook;				if isResource then				begin					UseResFile(RShared);					myTHand := GetNamedResource('HTxt', name);					if myTHand <> nil then					begin						HLock(handle(myTHand));						tempLong := SizeResource(myTHand);						TESetText(ptr(myTHand^), tempLong, t);						HUnlock(handle(myTHand));						ReleaseResource(myTHand);					end					else						SysBeep(10);					UseResFile(myResourceFile);				end				else				begin					result := FSOpen(concat(path, name), 0, fileRef);					if result = noErr then					begin						result := GetEOF(fileRef, templong);						if tempLong > 32000 then							tempLong := 32000;						myTHand := NewHandle(tempLong);						HLock(handle(myTHand));						result := FSRead(fileRef, tempLong, pointer(myTHand^));						TESetText(ptr(myTHand^), tempLong, t);						HUnlock(handle(myTHand));						DisposHandle(handle(myTHand));						result := FSClose(fileRef);					end					else						SysBeep(10);				end;				SetCtlMax(s, t^^.nLines - ((t^^.viewRect.bottom - t^^.viewRect.top) div 11));				if ((t^^.viewRect.bottom - t^^.viewRect.top) div 11) > t^^.nLines then					HiLiteControl(s, 255);				TEAutoView(true, t);				AdjustViewRect(t);				ShowWindow(w);				TEActivate(t);			end;		end		else			ProblemRep('Sorry, only ten text windows may be open at once.');		exit(OpenTextWindow);500:		ProblemRep('Memory is running low, please close some windows.');	end;	function copy1File (inputPath, outputPath: str255): OSErr;		label			5;		var			errorCode, ignore: OSErr;			inputFlInfo: FInfo;		function copyFork (inputFN: str255; outputFN: str255; forkType: char): OSErr;			label				5, 10, 15;			const				MaxBuff = 32000;			var				myParamBlk: paramBlockRec;				errorCode, holdErr: OSErr;				filesize: longint;				blocks: longint;				blkIndex: longint;				bytes: longint;				DataBuffer: ptr;				inRefNum, outRefNum: integer;		begin			with myParamBlk do			begin				ioCompletion := nil;			{ no follow-on routine				}				ioNamePtr := @inputFN;	{ pointer to path:file name	}				ioVRefNum := 0;					{ dummy volume number		}				ioVersNum := 0;					{ version always = 0				}				ioPermssn := fsRdPerm;	{ request read-only					}				ioMisc := nil;						{ use volume i/o buffer			}			end; {with}			case forkType of			{open input file, whichever fork we need}				'd': 					errorCode := PBOpen(@myParamBlk, false);		{ data fork }				'r': 					errorCode := PBOpenRF(@myParamBlk, false);	{ resource fork }			end;			if errorCode <> noErr then				goto 5		{ some problem opening the file, bail out now }			else				inRefNum := myParamBlk.ioRefNum;	{ success so far, remember the file's refNum }			{ set up a buffer for data transfer from the source to the destination }			dataBuffer := NewPtr(MaxBuff);			errorCode := MemError;			if errorCode <> noErr then				goto 10;			case forkType of			{open output file, whichever fork we need}				'd': 		{ data fork }					errorCode := FSOpen(outputFN, 0, outRefNum);				'r': 		{ resource fork }					errorCode := OpenRF(outputFN, 0, outRefNum);			end;			if errorCode <> noErr then				goto 15;			{ make sure we are pointing at the end of the file so as not to overwrite anything already here, }			{  ie. the other fork }			errorCode := SetFPos(outRefNum, fsFromStart, maxInt);			if (errorCode <> noErr) and (errorCode <> eofErr) then				goto 15;			{ find the size of the input file }			errorCode := GetEOF(inRefNum, filesize);			if (errorCode <> noErr) or (filesize <= 0) then				goto 15;			{ allocate as much disk space as we need for this fork }			errorCode := Allocate(outRefNum, fileSize);			if errorCode <> noErr then				goto 15;			{ now do the actual copy, one chunk at a time to keep our memory requirements down }			blocks := (fileSize + MaxBuff - 1) div MaxBuff;			bytes := MaxBuff;		{ our xfer buffer size }			for blkIndex := 1 to blocks do			begin				errorCode := FSRead(inRefNum, bytes, dataBuffer);		{ read a chunk… }				if (errorCode <> noErr) and (errorCode <> eofErr) then					goto 15;		{ fail with any error other than 'end of file' }				errorCode := FSWrite(outRefNum, bytes, dataBuffer);		{ and write it }				if errorCode <> noErr then					goto 15			end; { looping throught the input file }15:			holdErr := FSClose(outRefNum);	{ close the new file					}10:			disposPtr(dataBuffer);						{ throw out the xfer buffer	}5:			holdErr := FSClose(inRefNum);		{ close the source file				}			copyFork := errorCode;						{ report any errors 				}		end;	{copyFork}	begin	{copy1File}		errorCode := GetFInfo(inputPath, 0, inputFlInfo);		if errorCode <> noErr then			goto 5;		errorCode := Create(outputPath, 0, inputFlInfo.fdCreator, inputFlInfo.fdType);		if errorCode <> noErr then			goto 5;		inputFlInfo.fdLocation := Point($00000000);		inputFlInfo.fdFldr := 0;		inputFlInfo.fdFlags := BAND(inputFlInfo.fdFlags, $F8FE); {mask out desktop,inited,changed,busy}		errorCode := SetFInfo(outputPath, 0, inputFlInfo);		if errorCode <> noErr then			goto 5;		errorCode := copyFork(inputPath, outputPath, 'd');		if errorCode <> noErr then		begin			ignore := FSDelete(outputPath, 0);			goto 5;		end;		errorCode := copyFork(inputPath, outputPath, 'r');		if errorCode <> noErr then		begin			ignore := FSDelete(outputPath, 0);			goto 5;		end;5:		copy1File := errorCode;	end;		{copy1File}	procedure DoCapsName;		var			i: integer;			inWord: boolean;			key: char;			tempString: str255;	begin		tempString := doName;		inWord := false;		i := 0;		repeat			i := i + 1;			if (tempString[i] < 'A') or (tempString[i] > 'Z') then				inWord := false;			if inWord then			begin				key := tempString[i];				key := char(integer(key) + 32);				tempString[i] := key;			end;			if ((tempString[i] >= 'A') and (tempString[i] <= 'Z')) and not inWord then				inWord := true;		until (i >= length(tempString));		doName := tempString;	end;	function FidoNetAccount (toBeParsed: str255): boolean;		var			tempbool: boolean;			tempint: integer;			t1: str255;	begin		with curglobs^ do		begin			tempBool := false;			if IntSystRec.tabbyNet then			begin				tempint := pos(', ', toBeParsed);				if tempint > 2 then				begin					t1 := copy(toBeParsed, 1, tempint - 1);					delete(toBeParsed, 1, tempint + 1);					if (length(toBeParsed) >= 3) and (length(toBeParsed) < 16) then					begin						if pos('/', tobeParsed) > 1 then						begin							doCapsName(t1);							myFido.name := t1;							myFido.atNode := toBeParsed;							tempBool := true;						end;					end;				end;			end;		end;		fidoNetAccount := tempbool;	end;	procedure KillXFerRec;		var			i: integer;	begin		with curglobs^ do		begin			if extTrans <> nil then			begin				if extTrans^^.fileCount > 0 then				begin					for i := 1 to extTrans^^.fileCount do					begin						if extTrans^^.fPaths[i].fName <> nil then							DisposHandle(handle(extTrans^^.fPaths[i].fName));						if extTrans^^.fPaths[i].mbName <> nil then							DisposHandle(handle(extTrans^^.fPaths[i].mbName));					end;				end;				HUnlock(handle(extTrans));				HPurge(handle(extTrans));				DisposHandle(handle(extTrans));				extTrans := nil;			end;		end;	end;	procedure InitXFerRec;	begin		with curglobs^ do		begin			if extTrans <> nil then				KillXFERRec;			ExtTrans := XFERStuffHand(NewHandle(SizeOf(XFERStuff)));			MoveHHi(handle(extTrans));			HLock(handle(extTrans));			HNoPurge(handle(ExtTrans));			with extTrans^^ do			begin				if (nodeType = 2) then				begin					modemInput := dspDrvrRefNum;					modemOutput := nodeCCBRefNum;					flags[usingADSP] := true;				end				else				begin					modemInput := inputRef;					modemOutput := outputRef;					flags[usingADSP] := false				end;				procID := theProts^^.prots[activeProtocol].resID;				protocolData := nil;				errorReason := nil;				timeOut := intSystRec.ProtocolTime;				fileCount := 0;				filesDone := 0;				curBytesDone := 0;				CurBytesTotal := 0;				curStartTime := 0;				if (BoardMode = User) then					flags[transMode] := true				else					flags[transMode] := false;				flags[stoptrans] := false;				flags[carrierloss] := false;				flags[usemacbinary] := true;				flags[newMBName] := false;				flags[newError] := false;				flags[newfile] := false;				flags[recovering] := false;				fPaths[1].fName := nil;				fPaths[1].mbName := nil;			end;		end;	end;	function ConOpt2Num (key: char): integer;		const			theOptionKeys = '¡™£¢∞§¶•ªº';		var			i: integer;	begin		for i := 1 to 10 do			if (key = theOptionKeys[i]) then			begin				conopt2num := i;				exit(conopt2num);			end;		conopt2num := 0;	end;	procedure ConOpt2Con (var key: char);		const			theOptionKeys = 'å∫ç∂´ƒ©˙ˆ∆˚¬µ˜øπœ®ß†¨√∑≈¥Ω';			capsOptionKeys = 'ÅıÇÎ´Ï©ÓˆÔ˚ÒÂ˜Ø∏Œ®Í†¨√∑≈ÁΩ';		var			i: integer;	begin		i := length(theoptionkeys);		for i := 1 to 26 do			if (key = theOptionKeys[i]) or (key = capsOptionKeys[i]) then			begin				key := char(i);				exit(conopt2con);			end;		key := ' ';	end;	procedure AnalyzeProtocols;		var			i, curID, subCount, b, sfPos, c, index: integer;			pHand: handle;			SF: protocolo;			SFP: ProcSubPtr;			sCount: integer;			thePtr: Ptr;			flagPtr: IntPtrType;	begin		TheProts := ProtocolsHand(NewHandle(4));		HNoPurge(handle(theprots));		theProts^^.numProtocols := 0;		i := 0;		while (i < 10) do		begin			curID := i * 100 + 1000;			pHand := GetResource('PInf', curID);			if pHand <> nil then			begin				sfPos := 2;				BlockMove(pointer(pHand^), @subCount, 2);				for b := 1 to subCount do				begin					index := b;					theProts^^.numprotocols := theProts^^.numProtocols + 1;					SetHandleSize(handle(theProts), GetHandleSize(handle(theProts)) + SizeOf(protocolo));					SFP := @SF;					flagPtr := IntPtrType(@SFP^.pFlags);					flagPtr^ := 0;					SFP^.refCon := 0;					SFP^.protoName := '';					thePtr := pHand^;					sCount := IntPtrType(thePtr)^;					if (sCount > 0) and (sCount >= index) then					begin						thePtr := Ptr(ord4(thePtr) + 2);						while index <> 1 do						begin							thePtr := Ptr(ord4(thePtr) + 6);							thePtr := Ptr(ord4(thePtr) + thePtr^ + 2 - BAND(thePtr^, 1));							thePtr := Ptr(ord4(thePtr) + thePtr^ + 2 - BAND(thePtr^, 1));							index := index - 1;						end;						flagPtr^ := IntPtrType(thePtr)^;						thePtr := Ptr(ord4(thePtr) + 2);						SFP^.refCon := LongPtrType(thePtr)^;						thePtr := Ptr(ord4(thePtr) + 4);						SFP^.protoName := Str255PtrType(thePtr)^;						thePtr := Ptr(ord4(thePtr) + thePtr^ + 2 - BAND(thePtr^, 1));						SFP^.autoCom := Str255PtrType(thePtr)^;						SFP^.protHand := nil;						SFP^.protMode := 0;						SFP^.resID := curID;					end;					theProts^^.prots[theProts^^.numprotocols] := SF;				end;				ReleaseResource(handle(pHand));			end;			i := i + 1;		end;		MoveHHi(handle(theProts));	end;	procedure DrawDate (theDilg: dialogptr; theDate: dateTimeRec; selected: integer);		var			tempint: integer;			theHand: handle;			tempstring: str255;			myPic: picHandle;			temprect: rect;	begin		GetDItem(theDilg, 3, tempint, theHand, temprect);		Eraserect(temprect);		MoveTo(tempRect.left + 1, tempRect.bottom - 3);		NumToString(theDate.hour, tempstring);		if length(tempstring) = 1 then			tempstring := concat('0', tempstring);		DrawString(concat(tempstring, ':'));		bitclr(ptr(hilitemode), philitebit);		if selected = 3 then			InvertRect(temprect);		GetDItem(theDilg, 4, tempint, theHand, temprect);		Eraserect(temprect);		MoveTo(tempRect.left + 1, tempRect.bottom - 3);		NumToString(theDate.minute, tempstring);		if length(tempstring) = 1 then			tempstring := concat('0', tempstring);		DrawString(concat(tempstring, ':'));		bitclr(ptr(hilitemode), philitebit);		if selected = 4 then			InvertRect(temprect);		GetDItem(theDilg, 5, tempint, theHand, temprect);		Eraserect(temprect);		MoveTo(tempRect.left + 1, tempRect.bottom - 3);		NumToString(theDate.second, tempstring);		if length(tempstring) = 1 then			tempstring := concat('0', tempstring);		DrawString(tempstring);		bitclr(ptr(hilitemode), philitebit);		if selected = 5 then			InvertRect(temprect);	end;	function GetMyTime (initialTime: longint; askString: str255): longint;		var			timeDilg: dialogPtr;			myDate: dateTimeRec;			a: integer;			selected: integer;			tempLong: longint;	begin		TimeDilg := GetnewDialog(454, nil, pointer(-1));		SetPort(timeDilg);		ParamText(askString, '', '', '');		DrawDialog(timeDilg);		Secs2Date(initialTime, myDate);		DrawDate(timeDilg, myDate, 0);		selected := 0;		repeat			ModalDialog(nil, a);			if a = 3 then			begin				selected := 3;				DrawDate(timeDilg, myDate, selected);			end			else if a = 4 then			begin				selected := 4;				DrawDate(timeDilg, myDate, selected);			end			else if a = 5 then			begin				selected := 5;				DrawDate(timeDilg, myDate, selected);			end			else if (a = 6) and (selected > 0) then			begin				if selected = 5 then				begin					if myDate.second = 59 then						mydate.second := 0					else						myDate.second := mydate.second + 1;				end				else if selected = 4 then				begin					if mydate.minute = 59 then						mydate.minute := 0					else						myDate.minute := mydate.minute + 1;				end				else if selected = 3 then				begin					if mydate.hour = 23 then						mydate.hour := 0					else						myDate.hour := mydate.hour + 1;				end;				DrawDate(timeDilg, myDate, selected);			end			else if (a = 7) and (selected > 0) then			begin				if selected = 5 then				begin					if myDate.second = 0 then						mydate.second := 59					else						myDate.second := mydate.second - 1;				end				else if selected = 4 then				begin					if mydate.minute = 0 then						mydate.minute := 59					else						myDate.minute := mydate.minute - 1;				end				else if selected = 3 then				begin					if mydate.hour = 0 then						mydate.hour := 23					else						myDate.hour := mydate.hour - 1;				end;				DrawDate(timeDilg, myDate, selected);			end;		until (a = 1);		DisposDialog(timeDilg);		Date2Secs(myDate, templong);		GetMyTime := templong;	end;	procedure UpdateAutoValMenu;		var			sharedref: integer;	begin		DeleteMenu(58);		DisposeMenu(autoValMenu);		SharedRef := RShared;		autovalmenu := NewMenu(58, 'Auto Validates');		AddResMenu(autoValMenu, 'TUsr');		Appendmenu(autoValMenu, 'New...<I');		AppendMenu(autoValMenu, 'Remove...<I');		InsertMenu(autoValMenu, -1);		UseResFile(myResourceFile);	end;	procedure DrawFracc (theDilg: dialogptr);		var			temprect: rect;			ditem: handle;			dtype: integer;			i: integer;	begin		for i := 1 to 10 do		begin			GetDItem(thedilg, 10 + i, DType, DItem, tempRect);			EraseRect(tempRect);			if curTypUser.forumaccess[i] then				InvertRect(tempRect);			FrameRect(tempRect);		end;	end;	procedure DrawRestrics (theDilg: dialogptr);		var			temprect: rect;			ditem: handle;			dtype: integer;			i: integer;	begin		for i := 1 to 26 do		begin			GetDItem(thedilg, 23 + i, DType, DItem, tempRect);			EraseRect(tempRect);			if curTypUser.restrics[i] then				PaintRect(tempRect)			else				FrameRect(tempRect);		end;	end;	function AutoValAs (class: str255; pass: str255; passcounts: boolean): boolean;		var			sharedref: integer;			myTUser: TUserHand;			i: integer;	begin		with curglobs^ do		begin			AutoValAs := false;			UseResFile(RShared);			myTUser := TUserHand(GetNamedResource('TUsr', class));			if myTUser <> nil then			begin				if (not (length(myTUser^^.password) = 0) and (pass = myTUser^^.password)) or not passcounts then				begin					thisUser.secLevel := myTUser^^.sl;					thisUser.transferlevel := myTUser^^.dsl;					for i := 1 to 26 do						if myTUser^^.restrics[i] then							thisUser.restrics[i] := true						else							thisUser.restrics[i] := false;					for i := 1 to 10 do						if myTUser^^.forumaccess[i] then							thisUser.msgfrmaccess[i] := true						else							thisUser.msgFrmAccess[i] := false;					realSL := thisUser.secLevel;					myUsers^^[thisUser.userNum - 1].SL := thisUser.secLevel;					myUsers^^[thisUser.userNum - 1].DSL := thisUser.transferLevel;					AutoValAs := true;				end;				ReleaseResource(handle(myTUser));			end;			useResFile(myResourceFile);		end;	end;	procedure DoAutoValChoice (menuitem: integer);		var			i: integer;			thisedittext: tehandle;			thedialogptr: dialogpeek;			temprect: rect;			ditem: handle;			dtype: integer;			myTUHand: TUserhand;			templong: longint;			stemp: str255;			temphandle: handle;			userpickdilg: dialogptr;			cancelled: boolean;	begin		if menuitem < (countMItems(autoValMenu) - 1) then		begin			GetItem(autoValMenu, menuitem, stemp);			if curglobs^.thisUser.userNum > 1 then			begin				if not autoValAs(stemp, '', false) then					SysBeep(10);			end			else				SysBeep(10);		end		else		begin			if (menuitem = countMItems(autoValMenu)) then			begin				UserPickDilg := GetNewDialog(777, nil, pointer(-1));				SetPort(userPickDilg);				ParamText('Class to delete:', '', '', '');				DrawDialog(userPickDilg);				repeat					modalDialog(nil, i);				until (i = 1);				GetDItem(userpickdilg, 3, DType, DItem, tempRect);				GetIText(DItem, sTemp);				UseResFile(RShared);				tempHandle := GetNamedResource('TUsr', stemp);				if tempHandle <> nil then				begin					RmveResource(tempHandle);					DisposHandle(handle(temphandle));				end				else					SysBeep(10);				useResFile(myResourceFile);				DisposDialog(userPickDilg);			end			else if menuItem = countMItems(autoValMenu) - 1 then			begin				UserPickDilg := GetNewDialog(543, nil, pointer(-1));				SetPort(userPickDilg);				TheDialogPtr := DialogPeek(userpickdilg);				ThisEditText := TheDialogPtr^.textH;				HLock(Handle(ThisEditText));				ThisEditText^^.txSize := 9;				TextSize(9);				ThisEditText^^.txFont := monaco;				TextFont(monaco);				ThisEditText^^.txFont := 4;				ThisEditText^^.fontAscent := 9;				ThisEditText^^.lineHeight := 9 + 2 + 0;				HUnLock(Handle(ThisEditText));				curTypUser.className := '';				curTypUser.sl := 0;				curTypUser.dsl := 0;				for i := 1 to 26 do					curTypUser.restrics[i] := false;				for i := 1 to 30 do					curTypUser.forumaccess[i] := false;				curtypuser.password := '';				DrawRestrics(userpickDilg);				DrawFracc(userpickdilg);				cancelled := false;				repeat					ModalDialog(nil, i);					if (i > 23) and (i < 50) then					begin						if curTypUser.restrics[i - 23] then							curTypUser.restrics[i - 23] := false						else							curTypUser.restrics[i - 23] := true;						DrawRestrics(userPickDilg);					end					else if (i > 10) and (i < 21) then					begin						if curTypUser.forumaccess[i - 10] then							curTypUser.forumaccess[i - 10] := false						else							curTypUser.forumaccess[i - 10] := true;						DrawFracc(userpickdilg);					end					else if (i = 2) then						cancelled := true;				until (i = 1) or cancelled;				if not cancelled then				begin					GetDItem(userpickdilg, 7, DType, DItem, tempRect);					GetIText(DItem, sTemp);					curTypUser.classname := stemp;					GetDItem(userpickdilg, 8, DType, DItem, tempRect);					GetIText(DItem, sTemp);					StringToNum(sTemp, templong);					curTypUser.sl := templong;					GetDItem(userpickdilg, 9, DType, DItem, tempRect);					GetIText(DItem, sTemp);					StringToNum(sTemp, templong);					curTypUser.dsl := templong;					GetDItem(userpickdilg, 22, DType, DItem, tempRect);					GetIText(DItem, sTemp);					UprString(sTemp, true);					curTypUser.password := stemp;					if length(curTypUser.classname) > 0 then					begin						MyTUHand := TUserHand(NewHandle(SizeOf(typicaluser)));						HNoPurge(handle(myTUhand));						myTUHand^^ := curTypUser;						UseResFile(RShared);						AddResource(handle(myTUHand), 'TUsr', UniqueID('TUsr'), curTypUser.classname);						WriteResource(handle(myTUhand));						ReleaseResource(handle(myTUHand));						useResFile(myResourceFile);					end					else						Sysbeep(10);				end;				DisposDialog(userPickDilg);			end;		end;	end;{$D-}	function MyGetDirHook (item: integer; dPtr: DialogPtr): integer;		const			{ Equates for the items that I've added }			getDirButton = 11;			getDirNowButton = 12;			getDirMessage = 13;		var			messageTitle: str255;			h: Handle;			kind: integer;			r: rect;	begin		{ By default, return the item passed to us. }		MyGetDirHook := item;		case item of			-1: 			begin				GetDItem(dPtr, getDirMessage, kind, h, r);				SetIText(h, globalStr);				CurDirValid := FALSE;			end;			getDirButton: 			begin				if LONGINT(replySF.fType) <> 0 then				begin					MyCurDir := LONGINT(replySF.fType);					myGetDirHook := getCancel;					CurDirValid := TRUE;				end;			end;			getDirNowButton: 			begin				MyCurDir := CurDirStore^;				myGetDirHook := getCancel;				CurDirValid := TRUE;			end;		end;	end;	function FoldersOnly (p: ParmBlkPtr): BOOLEAN;	{ Normally, folders are ALWAYS shown, and aren't even passed to				}	{ this file filter for judgement. Under such circumstances, it is			}	{ only necessary to blindly return TRUE (allow no files whatsoever).	}	{ However, Standard File is not documented in such a manner, and			}	{ this feature may not be TRUE in the future. Therefore, we DO check	}	{ to see if the entry passed to us describes a file or a directory.		}	begin		FoldersOnly := TRUE;		if BTst(p^.ioFlAttrib, 4) then			FoldersOnly := FALSE;	end;{$D+}	function doGetDirectory: str255;		var			typeList: SFTypeList;	begin		SFPGetFile(Point($00400040), 'Space for Rent', @FoldersOnly, -1, typeList, @MyGetDirHook, replySF, 4002, nil);	{location}		if CurDirValid then		begin			doGetDirectory := PathnameFromDirID(MyCurDir, -(SFSaveDisk^));		end		else			doGetDirectory := '';	end;	procedure GetInOutNames (deviName: str255; var inName, outName: str255);		var			theCRM: CRMRecPtr;			theCRMRec: CRMRec;			TheErr: CRMErr;			therow: integer;			theSerial: CRMSerialPtr;			Old, i: integer;	begin		theErr := 0;		old := 0;		while (theErr = noErr) do		begin			with theCRMRec do			begin				crmDeviceType := crmSerialDevice;				crmDeviceID := old;			end;			theCRM := @theCRMrec;			theCRM := CRMRecPtr(CRMSearch(QElemPtr(theCRM)));			if theCRM <> nil then			begin				theSerial := CRMSerialPtr(theCRM^.crmAttributes);				old := theCRM^.crmdeviceID;				with theSerial^ do				begin					if name^^ = deviName then					begin						inName := inputDriverName^^;						Outname := outputDriverName^^;					end;				end;			end			else			begin				theErr := 1;			end;		end;	end;	procedure EraseBuffer (theBuf: scrnKeysPtr; numLines: integer);		var			i, b: integer;	begin		for i := 0 to (numLines - 1) do		begin			for b := 0 to 79 do				theBuf^[i][b] := char(32);		end;	end;	procedure CloseNodePrefs;		type			stuffLDEF = record					oldIC: array[0..31] of LONGINT;					oldMk: array[0..31] of LONGINT;					name: str255;				end;		var			tempString: str255;			tempCell: cell;			TempData: ptr;			TempLen: integer;			tempLong: longInt;			savePort: windowPtr;			tempRect: rect;			DType, i: Integer;			DItem: Handle;			CItem, CTempItem: controlhandle;			stuffer: stuffLDEF;	begin		if (nodeDilg <> nil) then		begin			with theNodes[visibleNode]^ do			begin				tempCell.h := 0;				tempCell.v := 0;				if LGetSelect(true, tempCell, modDrivList) then				begin					tempLen := 40;					LGetCell(@tempString[1], TempLen, tempCell, modDrivList);					tempString[0] := char(TempLen);					mDriverName := TempString;					theNodes[activeNode]^.modemID := tempCell.v;				end;				GetDItem(NodeDilg, 5, DType, DItem, tempRect);				CItem := Pointer(DItem);				MaxBaud := GetCtlValue(CItem);				GetDItem(NodeDilg, 8, DType, DItem, tempRect);				GetIText(DItem, tempstring);				StringToNum(tempstring, templong);				if templong > 999 then					tempLong := 999				else if templong < 1 then					tempLong := 1;				timeout := templong;				GetDItem(NodeDilg, 20, DType, DItem, tempRect);				GetIText(DItem, tempstring);				StringToNum(tempstring, templong);				if templong > 400 then					tempLong := 400				else if templong < 64 then					tempLong := 64;				if tempLong <> bufLns then				begin					DisposPtr(ptr(gBBSwindows[visibleNode]^.bigBuffer));					gBBSwindows[visibleNode]^.sNumLines := tempLong;					gBBSwindows[visibleNode]^.bigBuffer := scrnKeysPtr(NewPtr(SizeOf(aLine) * gBBSwindows[visibleNode]^.sNumLines));					if gBBSwindows[visibleNode]^.bigBuffer <> nil then						EraseBuffer(gBBSwindows[visibleNode]^.bigBuffer, gBBSwindows[visibleNode]^.sNumLines);					if gBBSwindows[visibleNode]^.ansiPort <> nil then					begin						SetCtlMax(gBBSwindows[visibleNode]^.ansiVScroll, gBBSwindows[visibleNode]^.sNumLines + gBBSwindows[visibleNode]^.scrnTop);						SetCtlValue(gBBSwindows[visibleNode]^.ansiVScroll, gBBSwindows[visibleNode]^.sNumLines + gBBSwindows[visibleNode]^.scrnTop);					end;				end;				bufLns := tempLong;				GetDItem(NodeDilg, 7, DType, DItem, tempRect);				CItem := Pointer(DItem);				MinBaud := GetCtlValue(CItem);				UseResFile(RShared);				NodeHnd := NodeHand(GetResource('Node', visibleNode - 1));				HNoPurge(handle(NodeHnd));				nodeHnd^^.DTRHangup := useDTR;				nodeHnd^^.BufferLines := bufLns;				NodeHnd^^.BaudMax := MaxBaud;				NodeHnd^^.BaudMin := MinBaud;				nodeHnd^^.timeoutIn := timeout;				nodeHnd^^.hardShake := HWHH;				NodeHnd^^.ModDrivName := MDriverName;				nodeHnd^^.carDet := carrierDetect;				nodeHnd^^.allowCrashmail := doCrashmail;				tempCell.h := 0;				tempCell.v := 0;				if LGetSelect(true, tempCell, ListPorts) then				begin					TempLen := 512;					LGetCell(@stuffer, tempLen, tempCell, ListPorts);					tempString := stuffer.name;					NodeHnd^^.myInPort := 'None';					NodeHnd^^.myOutPort := 'None';					if (tempString <> ADSPNAME) then					begin						GetInOutNames(tempString, NodeHnd^^.myinPort, NodeHnd^^.myoutPort);						theNodes[activeNode]^.inPortName := NodeHnd^^.myInPort;						theNodes[activeNode]^.outPortName := nodeHnd^^.myOutPort;					end					else					begin						theNodes[activeNode]^.inPortName := ADSPNAME;						NodeHnd^^.myinPort := ADSPNAME;						NodeHnd^^.myOutPort := ADSPNAME;					end;				end;				nodeHnd^^.localHook := goOffInLocal;				nodeHnd^^.matchSpeed := matchInterface;				nodehnd^^.uptime := uptime;				nodehnd^^.downtime := downtime;				ChangedResource(handle(NodeHnd));				WriteResource(handle(NodeHnd));				UseResFile(myResourceFile);				HPurge(handle(NodeHnd));				LDispose(listPorts);				LDispose(modDrivList);				DisposDialog(nodeDilg);				NodeDilg := nil;				GetPort(savePort);				CloseComPort;				OpenComPort;				if nodeType = 1 then					EnableItem(getMHandle(mSysop), 8)				else					DisableItem(getMHandle(mSysop), 8);				with curglobs^ do				begin					if (boardMode = Waiting) then						lastTry := lastTry - 80000;				end;				SetPort(savePort);			end;		end;	end;	function TimeToString (theDateTime: longint): str255;		var			myDate: dateTimeRec;			tempstring, ts2: str255;	begin		Secs2Date(theDateTime, myDate);		NumToString(myDate.hour, tempString);		if length(tempString) < 2 then			tempstring := concat('0', tempstring);		tempstring := concat(tempstring, ':');		NumToString(myDate.minute, ts2);		if length(ts2) < 2 then			ts2 := concat('0', ts2);		tempstring := concat(tempstring, ts2);		TimeToString := tempstring;	end;	procedure UpDateNodePrefs;		var			SavePort: WindowPtr;			sTemp: Str255;			tempHandle: handle;			tempRect: rect;			DType, i: Integer;			DItem: Handle;			CItem, CTempItem: controlhandle;	begin		if (nodeDilg <> nil) then		begin			GetPort(SavePort);			SetPort(nodeDilg);			DrawDialog(nodeDilg);			GetDItem(NodeDilg, 4, DType, DItem, tempRect);			FrameRect(tempRect);			PaintRect(temprect);			foreColor(whiteColor);			MoveTo(temprect.left + 2, temprect.bottom - 4);			DrawString(timeToString(theNodes[visibleNode]^.uptime));			foreColor(blackColor);			GetDItem(NodeDilg, 16, DType, DItem, tempRect);			FrameRect(tempRect);			PaintRect(temprect);			foreColor(whiteColor);			MoveTo(temprect.left + 2, temprect.bottom - 4);			DrawString(timeToString(theNodes[visibleNode]^.downtime));			foreColor(blackColor);					{Update a List, Connection Types }			GetDItem(NodeDilg, 11, DType, DItem, tempRect);			tempRect.Right := tempRect.Right - 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			if (modDrivList <> nil) then				LUpdate(nodeDilg^.visRgn, modDrivList);			GetDItem(NodeDilg, 3, DType, DItem, tempRect);			tempRect.Right := tempRect.Right - 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			if (ListPorts <> nil) then				LUpdate(nodeDilg^.visRgn, ListPorts);			SetPort(SavePort);		end;	end;	procedure AddListString (theString: Str255; theList: ListHandle);		var			theRow: integer;			sTemp: str255;	begin		if (theList <> nil) then		begin			cSize.h := 0;			theRow := LAddRow(1, 200, theList);			cSize.v := theRow;			sTemp := theString;			if sTemp = theNodes[activeNode]^.mDriverName then				selectThis := cSize;			LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);		end;	end;	procedure OpenNodePrefs;		var			Index, NumSTRRes, dyke, TempSndID: Integer;			dataBounds, tempRect: Rect;			cSize: Point;			STRname, sTemp: str255;			TempHand: handle;			WhicTyp: ResType;			thisEditText: TEHandle;			theDialogPtr: DialogPeek;			DType, i: Integer;			DItem: Handle;			CItem, CTempItem: controlhandle;			tempLong: longint;		procedure InsertSerialPorts;			type				stuffLDEF = record						oldIC: array[0..31] of LONGINT;						oldMk: array[0..31] of LONGINT;						name: str255;					end;			var				theCRM: CRMRecPtr;				theCRMRec: CRMRec;				TheErr: CRMErr;				therow: integer;				theSerial: CRMSerialPtr;				Old, i: integer;				stuffer: stuffLDEF;				myHandle: handle;		begin			theErr := 0;			old := 0;			while (theErr = noErr) do			begin				with theCRMRec do				begin					crmDeviceType := crmSerialDevice;					crmDeviceID := old;				end;				theCRM := @theCRMrec;				theCRM := CRMRecPtr(CRMSearch(QElemPtr(theCRM)));				if theCRM <> nil then				begin					theSerial := CRMSerialPtr(theCRM^.crmAttributes);					old := theCRM^.crmdeviceID;					with theSerial^ do					begin						stemp := name^^;						stuffer.name := sTemp;						BlockMove(pointer(deviceIcon^), @stuffer, 256);						cSize.h := 0;						theRow := LAddRow(1, 200, listports);						cSize.v := theRow;						if inputdrivername^^ = theNodes[activeNode]^.inportname then							SelectThis := cSize;						LSetCell(@stuffer, 257 + length(sTemp), cSize, listports);					end;				end				else				begin					theErr := 1;				end;			end;			if adspSupported then			begin				cSize.h := 0;				theRow := LAddRow(1, 200, listports);				cSize.v := theRow;				stemp := ADSPNAME;				if sTemp = theNodes[activeNode]^.inportname then					selectThis := cSize;				myHandle := GetResource('ICN#', 6003);				HLock(myHandle);				BlockMove(pointer(myHandle^), @stuffer, 256);				HUnlock(myHandle);				ReleaseResource(myHandle);				stuffer.name := sTemp;				LSetCell(pointer(@stuffer), 257 + length(sTemp), cSize, listports);			end;			cSize.h := 0;			theRow := LAddRow(1, 200, listports);			cSize.v := theRow;			stemp := 'None';			if sTemp = theNodes[activeNode]^.inportname then				selectThis := cSize;			myHandle := GetResource('ICN#', 6002);			HLock(myHandle);			BlockMove(pointer(myHandle^), @stuffer, 256);			HUnlock(myHandle);			ReleaseResource(myHandle);			stuffer.name := sTemp;			LSetCell(pointer(@stuffer), 261, cSize, listports);		end;	begin		if (nodeDilg = nil) then		begin			nodeDilg := GetNewDialog(745, nil, Pointer(-1));			SetPort(nodeDilg);			NumToString(visibleNode, strname);			SetWTitle(nodeDilg, concat('Node ', strname));			TheDialogPtr := DialogPeek(nodeDilg);			ThisEditText := TheDialogPtr^.textH;			HLock(Handle(ThisEditText));			ThisEditText^^.txSize := 9;			ThisEditText^^.txFont := geneva;			ThisEditText^^.fontAscent := 9;			ThisEditText^^.lineHeight := 9 + 2 + 0;			HUnLock(Handle(ThisEditText));			TextSize(9);			TextFont(geneva);			GetDItem(NodeDilg, 5, DType, DItem, tempRect);			CItem := Pointer(DItem);			SetCtlValue(citem, curglobs^.maxBaud);			GetDItem(NodeDilg, 7, DType, DItem, tempRect);			CItem := Pointer(DItem);			SetCtlValue(citem, curglobs^.minbaud);			GetDItem(NodeDilg, 11, DType, DItem, tempRect);			tempRect.Right := tempRect.Right - 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			InsetRect(tempRect, 1, 1);			SetRect(dataBounds, 0, 0, 1, 0);			cSize.h := tempRect.Right - tempRect.Left;			cSize.v := 12;			modDrivList := LNew(tempRect, dataBounds, cSize, 0, nodeDilg, false, FALSE, FALSE, TRUE);			modDrivList^^.selFlags := lOnlyOne + lNoNilHilite;			HLock(handle(modDrivList));			if numModemDrivers > 0 then				for i := 1 to numModemDrivers do					AddListString(modemDrivers^^[i - 1].name, modDrivList);			LSetSelect(true, selectThis, modDrivList);			LDoDraw(true, modDrivList);					{Make a List, Connection Types }			GetDItem(NodeDilg, 3, DType, DItem, tempRect);			tempRect.Right := tempRect.Right - 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			InsetRect(tempRect, 1, 1);			SetRect(dataBounds, 0, 0, 1, 0);			cSize.h := tempRect.Right - tempRect.Left;			cSize.v := 52;			ListPorts := LNew(tempRect, dataBounds, cSize, 10000, nodeDilg, TRUE, FALSE, FALSE, TRUE);			ListPorts^^.selFlags := lOnlyOne + lNoNilHilite;			HLock(handle(ListPorts));			cSize.h := 0;			cSize.v := 0;			InsertSerialPorts;			LSetSelect(TRUE, SelectThis, listports);			GetDItem(NodeDilg, 8, DType, DItem, tempRect);			NumToString(theNodes[visibleNode]^.timeout, strname);			SetIText(DITem, strname);			GetDItem(NodeDilg, 20, DType, DItem, tempRect);			NumToString(theNodes[visibleNode]^.bufLns, strname);			SetIText(DITem, strname);			GetDItem(NodeDilg, 2, DType, DItem, tempRect);			CItem := Pointer(DItem);			if theNodes[visibleNode]^.goOffinLocal then				SetCtlValue(CItem, 1);			GetDItem(NodeDilg, 26, DType, DItem, tempRect);			CItem := Pointer(DItem);			if theNodes[visibleNode]^.doCrashmail then				SetCtlValue(CItem, 1);			GetDItem(NodeDilg, 17, DType, DItem, tempRect);			CItem := Pointer(DItem);			if theNodes[visibleNode]^.useDTR then				SetCtlValue(CItem, 1);			case theNodes[visibleNode]^.carrierDetect of				CTS5: 					SetCheckBox(nodeDilg, 23, true);				DCDchip: 					SetCheckBox(nodeDilg, 24, true);				DCDdriver: 					SetCheckBox(nodeDilg, 25, true);				otherwise			end;			SetCheckBox(nodeDilg, 14, theNodes[visibleNode]^.matchInterface);			GetDItem(NodeDilg, 18, DType, DItem, tempRect);			CItem := Pointer(DItem);			if theNodes[visibleNode]^.HWHH then			begin				SetCtlValue(CItem, 1);				GetDItem(NodeDilg, 23, DType, DItem, tempRect);				HiLiteControl(controlHandle(DItem), 255);				GetDItem(NodeDilg, 17, DType, DItem, tempRect);				HiLiteControl(controlHandle(DItem), 255);			end;			if not hasGPi then			begin				GetDItem(NodeDilg, 24, DType, DItem, tempRect);				HiLiteControl(controlHandle(DItem), 255);			end;			if not intSystRec.tabbyNet then			begin				GetDItem(NodeDilg, 26, DType, DItem, tempRect);				HiLiteControl(controlHandle(DItem), 255);			end;			LAutoScroll(listPorts);			LAutoScroll(modDrivList);			ShowWindow(nodeDilg);			SelectWindow(NodeDilg);		end		else			SelectWindow(nodeDilg);	end;	procedure ClickInNodePrefs (theEvent: EventRecord; itemHit: integer);		var			RefCon: longint;			code, tempInt: integer;			theValue: integer;			whichWindow: WindowPtr;			myPt: Point;			MyErr: OSErr;			DoubleClick: boolean;			tempRect: rect;			DType, i: Integer;			newDriver: ModemDriverHand;			DItem: Handle;			CItem, CTempItem: controlhandle;			tempCell, tc2: cell;			t1: str255;			reply: SFReply;	begin		if (NodeDilg <> nil) and (frontWindow = NodeDilg) then		begin			setPort(nodeDilg);			myPt := theEvent.where;			GlobalToLocal(myPt);			case itemHit of				1: 					CloseNodePrefs;				4: 				begin					theNodes[visibleNode]^.uptime := GetMyTime(theNodes[visibleNode]^.uptime, 'Node start time:');					SetPort(nodedilg);					GetDItem(NodeDilg, 4, DType, DItem, tempRect);					InvalRect(temprect);				end;				16: 				begin					theNodes[visibleNode]^.downtime := GetMyTime(theNodes[visibleNode]^.downtime, 'Node down time:');					SetPort(nodedilg);					GetDItem(NodeDilg, 49, DType, DItem, tempRect);					InvalRect(temprect);				end;				5: 				begin					GetDItem(NodeDilg, 7, DType, DItem, tempRect);					CItem := Pointer(DItem);					tempInt := GetCtlValue(CItem);					GetDItem(NodeDilg, 5, DType, DItem, tempRect);					CItem := Pointer(DItem);					code := GetCtlValue(CItem);					if code < tempInt then					begin						SysBeep(10);						SetCtlValue(Citem, tempInt);					end;				end;				7: 				begin					GetDItem(NodeDilg, 5, DType, DItem, tempRect);					CItem := Pointer(DItem);					code := GetCtlValue(CItem);					GetDItem(NodeDilg, 7, DType, DItem, tempRect);					CItem := Pointer(DItem);					tempInt := GetCtlValue(CItem);					if tempInt > code then					begin						SysBeep(10);						SetCtlValue(Citem, code);					end;				end;				2: 				begin					GetDItem(NodeDilg, 2, DType, DItem, tempRect);					CItem := Pointer(DItem);					SetCtlValue(CItem, (GetCtlValue(CItem) + 1) mod 2);					theNodes[visibleNode]^.goOffinLocal := not theNodes[visibleNode]^.goOffinLocal;				end;				17: 				begin					GetDItem(NodeDilg, 17, DType, DItem, tempRect);					CItem := Pointer(DItem);					SetCtlValue(CItem, (GetCtlValue(CItem) + 1) mod 2);					theNodes[visibleNode]^.useDTR := not theNodes[visibleNode]^.useDTR;				end;				26: 				begin					GetDItem(NodeDilg, 26, DType, DItem, tempRect);					CItem := Pointer(DItem);					SetCtlValue(CItem, (GetCtlValue(CItem) + 1) mod 2);					theNodes[visibleNode]^.doCrashmail := not theNodes[visibleNode]^.doCrashmail;				end;				14: 				begin					GetDItem(NodeDilg, 14, DType, DItem, tempRect);					CItem := Pointer(DItem);					SetCtlValue(CItem, (GetCtlValue(CItem) + 1) mod 2);					theNodes[visibleNode]^.matchInterface := not theNodes[visibleNode]^.matchinterface;				end;				18: 				begin					GetDItem(NodeDilg, 18, DType, DItem, tempRect);					CItem := Pointer(DItem);					if not theNodes[visibleNode]^.HWHH then					begin						if theNodes[visibleNode]^.carrierDetect = CTS5 then							ProblemRep('This serial port does not permit using CTS for carrier detect with hardware handshaking.')						else						begin							if theNodes[visibleNode]^.useDTR then								ProblemRep('This serial port does not permit using DTR Hangup with hardware handshaking.')							else							begin								theNodes[visibleNode]^.HWHH := not theNodes[visibleNode]^.HWHH;								SetCtlValue(CItem, (GetCtlValue(CItem) + 1) mod 2);								GetDItem(NodeDilg, 23, DType, DItem, tempRect);								HiLiteControl(controlHandle(DItem), 255);								GetDItem(NodeDilg, 17, DType, DItem, tempRect);								HiLiteControl(controlHandle(DItem), 255);							end;						end;					end					else					begin						theNodes[visibleNode]^.HWHH := not theNodes[visibleNode]^.HWHH;						SetCtlValue(CItem, (GetCtlValue(CItem) + 1) mod 2);						GetDItem(NodeDilg, 23, DType, DItem, tempRect);						HiLiteControl(controlHandle(DItem), 0);						GetDItem(NodeDilg, 17, DType, DItem, tempRect);						HiLiteControl(controlHandle(DItem), 0);					end;				end;				29: 				begin					tempCell.h := 0;					tempCell.v := 0;					if LGetSelect(true, tempCell, modDrivList) then					begin						SetPt(myPt, 50, 50);						SFPutFile(myPt, 'Save modem driver as:', modemDrivers^^[tempCell.v].name, nil, reply);						if reply.good then						begin							result := Create(reply.fName, 0, 'HRMS', 'MODR');							CreateResFile(reply.fName);							tempInt := OpenResFile(reply.fName);							if (tempInt <> -1) then							begin								newDriver := ModemDriverHand(NewHandle(SizeOf(modemdriver)));								HLock(handle(newDriver));								newDriver^^ := modemDrivers^^[tempCell.v];								AddResource(handle(newDriver), 'MoDr', 1000, newDriver^^.name);								WriteResource(handle(newDriver));								DetachResource(handle(newDriver));								DisposHandle(handle(newDriver));								CloseResFile(tempInt);							end							else								SysBeep(10);						end;					end;				end;				27: 				begin					newDriver := ModemDriverHand(NewHandle(SizeOf(modemdriver)));					HLock(handle(newDriver));					newDriver^^.name := 'Name';					newDriver^^.bbsInit := 'ATS0=0Q0V0E0M0S2=1X1';					newDriver^^.termInit := 'ATV1E1S2=43M1S11=50';					newDriver^^.hwOn := '';					newDriver^^.hwOff := '';					newDriver^^.lockOn := '';					newDriver^^.lockOff := '';					newDriver^^.ansModem := 'ATA';					newDriver^^.numResults := 0;					if EditModemDriver(newDriver^^) then					begin						AddResource(handle(newDriver), 'MoDr', UniqueID('MoDr'), newDriver^^.name);						WriteResource(handle(newDriver));						DetachResource(handle(newDriver));						AddListString(newDriver^^.name, modDrivList);						SetHandleSize(handle(modemDrivers), GetHandleSize(handle(modemDrivers)) + SizeOf(modemDriver));						modemDrivers^^[numModemDrivers] := newDriver^^;						numModemDrivers := numModemDrivers + 1;					end;					HUnlock(handle(newDriver));					DisposHandle(handle(newDriver));				end;				28: 				begin					tempCell.h := 0;					tempCell.v := 0;					if LGetSelect(true, tempCell, modDrivList) then					begin						newDriver := ModemDriverHand(GetNamedResource('MoDr', modemDrivers^^[tempCell.v].name));						RmveResource(handle(newDriver));						if numModemDrivers > tempCell.v + 1 then							for i := tempCell.v + 1 to numModemDrivers do								modemDrivers^^[i - 1] := modemDrivers^^[i];						numModemDrivers := numModemDrivers - 1;						SetHandleSize(handle(modemDrivers), SizeOf(modemDriver) * numModemDrivers);						LDoDraw(false, modDrivList);						LDelRow(0, 0, modDrivList);						if numModemDrivers > 0 then							for i := 1 to numModemDrivers do								AddListString(modemDrivers^^[i - 1].name, modDrivList);						LSetSelect(true, selectThis, modDrivList);						LDoDraw(true, modDrivList);						GetDItem(NodeDilg, 11, DType, DItem, tempRect);						tempRect.Right := tempRect.Right - 15;						InsetRect(tempRect, -1, -1);						EraseRect(tempRect);						FrameRect(tempRect);						LUpdate(modDrivList^^.port^.visRgn, modDrivList);					end;				end;				3: 				begin					tempCell := cell($00000000);					if LGetSelect(true, tempCell, listPorts) then						;					DoubleClick := LClick(myPt, theEvent.modifiers, ListPorts);					tc2 := cell($00000000);					if not LGetSelect(true, tc2, listPorts) then						LSetSelect(true, tempCell, listPorts);				end;				23, 24, 25: 				begin					GetDItem(NodeDilg, 23, DType, DItem, tempRect);					SetCtlValue(controlhandle(DItem), 0);					GetDItem(NodeDilg, 24, DType, DItem, tempRect);					SetCtlValue(controlhandle(DItem), 0);					GetDItem(NodeDilg, 25, DType, DItem, tempRect);					SetCtlValue(controlhandle(DItem), 0);					GetDItem(NodeDilg, itemHit, DType, DItem, tempRect);					SetCtlValue(controlhandle(DItem), 1);					GetDItem(NodeDilg, 23, DType, DItem, tempRect);					if GetCtlValue(controlHandle(DItem)) = 1 then						theNodes[visibleNode]^.carrierDetect := CTS5;					GetDItem(NodeDilg, 24, DType, DItem, tempRect);					if GetCtlValue(controlHandle(DItem)) = 1 then						theNodes[visibleNode]^.carrierDetect := DCDchip;					GetDItem(NodeDilg, 25, DType, DItem, tempRect);					if GetCtlValue(controlHandle(DItem)) = 1 then						theNodes[visibleNode]^.carrierDetect := DCDdriver;				end;				11: 				begin					DoubleClick := LClick(myPt, theEvent.modifiers, modDrivList);					if doubleClick then					begin						tempCell.h := 0;						tempCell.v := 0;						if LGetSelect(true, tempCell, modDrivList) then						begin							t1 := modemDrivers^^[tempCell.v].name;							if EditModemDriver(modemDrivers^^[tempCell.v]) then							begin								newDriver := ModemDriverHand(GetNamedResource('MoDr', t1));								RmveResource(handle(newDriver));								DisposeHandle(handle(newDriver));								newDriver := ModemDriverHand(NewHandle(SizeOf(modemdriver)));								HLock(handle(newDriver));								newDriver^^ := modemDrivers^^[tempCell.v];								AddResource(handle(newDriver), 'MoDr', UniqueID('MoDr'), newDriver^^.name);								WriteResource(handle(newDriver));								DetachResource(handle(newDriver));								HUnlock(handle(newDriver));								DisposHandle(handle(newDriver));								SetPort(nodeDilg);								LDoDraw(false, modDrivList);								LDelRow(0, 0, modDrivList);								if numModemDrivers > 0 then									for i := 1 to numModemDrivers do										AddListString(modemDrivers^^[i - 1].name, modDrivList);								LSetSelect(true, tempCell, modDrivList);								LDoDraw(true, modDrivList);								GetDItem(NodeDilg, 11, DType, DItem, tempRect);								tempRect.Right := tempRect.Right - 15;								InsetRect(tempRect, -1, -1);								EraseRect(tempRect);								FrameRect(tempRect);								LUpdate(modDrivList^^.port^.visRgn, modDrivList);							end;						end;					end;				end;				otherwise			end;		end;	end;end.