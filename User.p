unit User;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, initial, Message_Editor, SystemPrefs, nodeprefs;	procedure EndUser;	function FindUser (SearchString: str255; var UserFound: UserRec): boolean;	procedure Init_User_Edit;	function UserOnSystem (name: str255): boolean;	procedure InitUserRec;	procedure ResetUserColors (var theUser: UserRec);	procedure ReadExtended (theFil: filEntryRec; whichDir: integer);	function SysopReadExtended (theFil: filEntryRec; whichDir: integer): CharsHandle;	procedure Update_User_Edit (theWindow: WindowPtr);	procedure Open_User_Edit;	procedure Do_User_Edit (theEvent: EventRecord; itemHit: integer);	procedure Close_User_Edit (theWindow: WindowPtr; Cancelled: boolean);	procedure WriteUser (theUser: UserRec);	procedure MakeUserList;	procedure DoTabbyImport;	function checkTitle (thetit: str255): boolean;	procedure LogThis (LogIt: str255; color: integer);	procedure SysopLog (toLog: str255; color: integer);	procedure WriteTempLog2Log;	procedure yearsOld (var theUser: userRec);	procedure GoHome;	function UserHungUp: boolean;	procedure InitAllVars;implementation	var		ExitDialog: Boolean;		tempRect: Rect;		DType: Integer;		Index: Integer;		DItem: Handle;		CItem, CTempItem: controlhandle;		sTemp: Str255;		itemHit: Integer;		temp: Integer;		multiUserList: ListHandle;	procedure ReadExtended (theFil: filEntryRec; whichDir: integer);		var			s1, tempstring: str255;			L1, i, tempLong: longint;			myRef: integer;			dataFile, endFile, curPtr: ptr;			myExtDesc: extDescRec;			gotOne: boolean;	begin		with curglobs^ do		begin			if curWriting <> nil then				DisposHandle(handle(curWriting));			curWriting := nil;			tempstring := concat(sharedPath, 'Data:', intDLStuff^^.dr[whichDir].dirName, '.EXT');			result := FSOpen(tempString, 0, myRef);			if result = noErr then			begin				i := 0;				result := GetEOF(myRef, L1);				dataFile := NewPtr(l1);				if (MemError = 0) then				begin					result := FSRead(myRef, l1, dataFile);					i := 0;					gotOne := false;					endFile := pointer(longint(dataFile) + l1);					curPtr := dataFile;					while not gotOne and (longint(curPtr) < longint(endFile)) do					begin						BlockMove(pointer(curPtr), @myExtDesc, SizeOf(extDescRec));						tempLong := myExtDesc.descLeng;						if myExtDesc.fName = theFil.flName then						begin							curWriting := TextHand(newHandle(myExtDesc.descLeng));							HLock(handle(curWriting));							HNoPurge(handle(curWriting));							BlockMove(pointer(longint(curPtr) + SizeOf(extDescRec)), pointer(curWriting^), tempLong);							HUnlock(handle(curWriting));							gotOne := true;						end;						curPtr := pointer(longint(curPtr) + SizeOf(extDescRec) + tempLong);					end;					DisposPtr(dataFile);				end				else					SysBeep(10);				result := FSClose(myRef);			end;		end;	end;	function SysopReadExtended (theFil: filEntryRec; whichDir: integer): CharsHandle;		var			s1, tempstring: str255;			L1, i, tempLong: longint;			myRef: integer;			curWriting: charsHandle;			curExtDesc: extDescrec;	begin		CurWriting := nil;		tempstring := concat(sharedPath, 'Data:', intDLStuff^^.dr[whichDir].dirName, '.EXT');		result := FSOpen(tempString, 0, myRef);		if result = noErr then		begin			i := 0;			result := GetEOF(myRef, L1);			while i < L1 do			begin				result := SetFPos(myRef, fsFromStart, i);				i := i + sizeOf(extDescRec);				tempLong := sizeOf(extDescRec);				result := FSRead(myRef, tempLong, @curExtDesc);				if curExtDesc.fName = theFil.flName then				begin					curWriting := charsHandle(newHandle(curExtDesc.descLeng));					HLock(handle(curWriting));					HNoPurge(handle(curWriting));					tempLong := curExtDesc.descLeng;					result := FSRead(myRef, tempLong, pointer(curWriting^));					HUnlock(handle(curWriting));					i := L1;				end				else					i := i + curExtDesc.descLeng;			end;			result := FSClose(myRef);		end;		SysopReadExtended := curWriting;	end;	procedure EndUser;		var			tempString, tempString2: str255;			tempLong, timehere: longint;			sharedRef: integer;	begin		with curglobs^ do		begin			if (thisUser.userNum > 1) then			begin				intSystRec.callsToday := intSystRec.callsToday + 1;			end;			if (thisUser.userNum >= 0) and validLogon then			begin				lastCurUser := thisUser.userName;				thisUser.illegalLogons := 0;				thisUser.secLevel := realSL;				if wasMadeTempSysop then					thisUser.coSysop := not thisUser.coSysop;				GetDateTime(tempLong);				thisUser.lastOn := tempLong;				myUsers^^[thisUser.userNum - 1].last := tempLong;				tempString := '      Read: ';				NumToString(mesRead, tempString2);				tempString := concat(tempString, tempString2);				tempString2 := tickToTime(tickCount - timeBegin);				sysopLog(concat(tempString, '    Time on: ', tempString2, char(13)), 2);				timeHere := ((tickCount - timeBegin) div 60 div 60) + 1;				if subtractOn > 0 then					subtractOn := subtractOn div 60 div 60;				thisUser.totalTimeOn := thisUser.totalTimeOn + timeHere;				thisUser.minOnToday := thisUser.minOnToday + timeHere - subtractOn;				intSystRec.minsToday := intSystRec.minsToday + timeHere - subtractOn;				WriteUser(thisUser);				thisUser.userNum := -1;				NumToString(activeNode, tempString);				if gBBSwindows[activeNode]^.ansiPort <> nil then					SetWTitle(gBBSwindows[activeNode]^.ansiPort, concat('Hermes ', tempstring));			end;			WriteTempLog2Log;			doSystRec(true);		end;	end;	procedure InitAllVars;		var			tempLong2, tempLong: longInt;			i: integer;	begin		with curglobs^ do		begin			SysopLogon := false;			prompting := false;			negateBCR := false;			spying := 0;			amSpying := false;			subtracton := 0;			thisUser.UserNum := 1;			OpenEmail;			numFeedbacks := 0;			for i := 1 to AvailEmails do				if (theEmail^^[i - 1].toUser = 1) and (theEmail^^[i - 1].mType = 1) then					numFeedbacks := numFeedbacks + 1;			CloseEmail;			if myEmailList <> nil then			begin				DisposHandle(handle(myEmailList));				myEmailList := nil;			end;			thisUser.UserNum := -1;			thisUser.PauseScreen := false;			thisUser.ScrnHght := 3000;			thisUser.canANSI := false;			thisUser.secLevel := 10;			thisUser.screenClears := true;			validLogon := false;			wasMadeTempSysop := false;			typeBuffer := '';			SetHandleSize(handle(sysopKeyBuffer), 0);			HelpNum := 0;			threadMode := false;			lastleft := -1;			hangingUp := -1;			countingdown := false;			ListingHelp := false;			useWorkspace := 0;			fromMsgScan := false;			inScroll := false;			saveInForum := 1;			FileTransit^^.numFiles := 0;			FileTransit^^.batchTime := 0;			FileTransit^^.batchKBytes := 0;			RealSL := -1;			triedChat := false;			newFeed := false;			goBackToLogon := false;			inForum := 1;			endQScan := false;			continuous := false;			fromQScan := false;			stopRemote := false;			gettingANSI := false;			readMsgs := false;			alerted := false;			shutdownsoon := false;			inNScan := false;			inZScan := false;			inTransfer := false;			inDir := 1;			mesRead := 0;			inSub := 1;			inforum := 1;			XFerAutoStart := 0;			timeFlagged := false;			BoardAction := none;			GoHome;			Prompting := false;			extraTime := 0;			TimeBegin := 0;			AnsInProgress := '';			LnsPause := 0;			quit := 0;			CloseBase;			HiLiteMenu(0);			if curOpenDir <> nil then			begin				HPurge(handle(curOpenDir));				DisposHandle(handle(curOpenDir));			end;			curOpenDir := nil;			dirOpenNum := -1;			clearInBuf;		end;	end;	procedure ResetUserColors (var theUser: UserRec);	begin		with theUser do		begin			foregrounds[0] := 7;			backgrounds[0] := 0;			bolds[0] := false;			underlines[0] := false;			foregrounds[1] := 6;			backgrounds[1] := 0;			bolds[1] := true;			underlines[1] := false;			foregrounds[2] := 3;			backgrounds[2] := 0;			bolds[2] := true;			underlines[2] := false;			foregrounds[3] := 5;			backgrounds[3] := 0;			bolds[3] := false;			underlines[3] := false;			foregrounds[4] := 7;			backgrounds[4] := 4;			bolds[4] := true;			underlines[4] := false;			foregrounds[5] := 2;			backgrounds[5] := 0;			bolds[5] := false;			underlines[5] := false;			foregrounds[6] := 1;			backgrounds[6] := 0;			bolds[6] := true;			underlines[6] := false;			foregrounds[7] := 7;			backgrounds[7] := 0;			bolds[7] := false;			underlines[7] := false;			foregrounds[8] := 5;			backgrounds[8] := 4;			bolds[8] := true;			underlines[8] := true;		end;	end;	procedure InitUserRec;		var			i, tempInt: integer;	begin		with curglobs^ do		begin			GetDateTime(thisUser.laston);			GetDateTime(thisUser.firstOn);			thisUser.deleting := false;			thisUser.mailbox := false;			thisUser.forwardedTo := -1;			thisUser.defaultProtocol := 0;			thisUser.PauseScreen := true;			thisUser.ScrnWdth := 80;			thisUser.ScrnHght := 24;			thisUser.canANSI := false;			thisUser.ANSIColor := false;			ResetUserColors(thisUser);			thisUser.Expert := false;			thisUser.sysopNote := '';			thisUser.MinOnToday := 0;			thisUser.SecLevel := IntSystRec.NewSL;			thisUser.TransferLevel := IntSystRec.NewDSL;			thisUser.illegalLogons := 0;			for i := 1 to 10 do			begin				if intSystRec.NewFrmAccess[i] then					thisUser.MsgFrmAccess[i] := true				else					thisUser.MsgFrmAccess[i] := false;			end;			for i := 1 to 26 do			begin				if intSystRec.NewStrics[i] then					thisUser.Restrics[i] := true				else					thisUser.Restrics[i] := false;			end;			thisUser.onToday := 0;			thisUser.lastVoted := 0;			thisUser.MessagesPosted := 0;			thisUser.EMailSent := 0;			thisUser.UserNum := -1;			thisUser.numUploaded := 0;			thisUser.numdownloaded := 0;			thisUser.uploadedK := 0;			thisUser.EMsentToday := 0;			thisUser.MPostedToday := 0;			thisUser.downloadedK := 0;			thisUser.birthDay := char(0);			thisUser.birthMonth := char(0);			thisUser.BirthYear := char(0);			thisUser.lastFileScan := 0;			thisUser.NTransAfterMess := false;			thisUser.computerType := '';			for i := 1 to 19 do				thisUser.votes[i] := 0;			thisUser.extendedLines := 10;			thisUser.totalLogons := 0;			thisUser.lastBaud := currentBaud;			for i := 0 to 22 do				thisUser.reserved[i] := char(0);			thisUser.coSysop := false;			thisUser.screenClears := true;			thisUser.notifyLogon := true;			thisUser.totalTimeOn := 0;			thisUser.alertOn := false;			GetDateTime(thisUser.lastPWChange);			for i := 1 to 10 do			begin				for tempInt := 1 to 30 do				begin					thisUser.LastMsgs[i, tempInt] := 0;					thisUser.WhatNScan[i, tempInt] := true;				end;			end;		end;	end;	function UserOnSystem (name: str255): boolean;		var			tempBool: boolean;			i: integer;	begin		tempBool := false;		for i := 1 to intSystRec.numNodes do		begin			if (theNodes[i]^.thisUser.userNum > 0) and (theNodes[i]^.thisUser.userName = name) and (theNodes[i]^.boardMode = user) then			begin				tempBool := true;			end;		end;		userOnSystem := tempBool;	end;	procedure yearsOld (var theUser: userRec);		var			tempDate2: dateTimeRec;	begin		getTime(tempdate2);		theUser.age := tempDate2.year - (byte(theUser.birthYear) + 1900);		if (tempDate2.month < integer(theUser.birthMonth)) or ((tempDate2.day < integer(theUser.birthDay)) and (tempDate2.month = integer(theUser.birthMonth))) then			theUser.age := theUser.age - 1;		if theUser.age < 0 then			theUser.age := 0;	end;	function UserHungUp: boolean;		var			TempStat: SerStaRec;			result: OSerr;			ffd: longInt;			slot, port, val: Integer;			scc, pleaseWait, waitAck: Ptr;			myPDCD: ParamBlockRec;			DCDhold: byte;	begin		with curGlobs^ do		begin			if (nodeType = 1) then			begin				case carrierDetect of					CTS5: 					begin						result := SerStatus(inputRef, TempStat);						if tempStat.ctsHold <> 0 then							UserHungUp := true						else							userHungUp := false;					end;					DCDchip: 					begin						if inputRef = ainRefNum then							UserHungUp := (Ptr(PtrToLong(SccRd)^ + aCtl)^ div 8 mod 2 = 0)						else if inputRef = binRefNum then							UserHungUp := (Ptr(PtrToLong(SccRd)^ + bCtl)^ div 8 mod 2 = 0)						else							UserHungUp := true;					end;					DCDdriver: 					begin						myPDCD.ioCompletion := nil;						myPDCD.ioRefNum := inputRef;						myPDCD.ioVRefNum := 0;						myPDCD.csCode := 256;						result := PBStatus(parmBlkPtr(StripAddress(@myPDCD)), false);						if result = noErr then						begin							DCDHold := ptr(ord4(@myPDCD.csParam) + 6)^;							if DCDhold <> 0 then								UserHungUp := false							else								UserHungUp := true;						end						else							UserHungUp := true;					end;					otherwise				end;			end			else			begin				with nodeCCBPtr^ do				begin					userHungUp := false;					if (BAND(userFlags, eClosed) <> 0) then						userHungUp := true;					if (BAND(userFlags, eTearDown) <> 0) then						userHungUp := true;					userFlags := 0;				end;			end;		end;	end;	procedure GoHome;		var			check: boolean;	begin		with curGlobs^ do		begin			check := false;			if (BoardSection = UEdit) then				check := true;			if (boardsection = Ext) and (maxLines = -981) then				boardSection := Upload			else			begin				BoardSection := MainMenu;				MainStage := MenuText;			end;			if check and (maxLines = -425) then				BoardSection := ReadMail			else if goBackToLogon then			begin				curPrompt := 'N';				goBackToLogon := false;				BoardSection := Logon;			end;		end;	end;	procedure ResetMyConts;		var			tempRect: rect;			i: integer;	begin		SetPort(getUSelection);		for i := 1 to 10 do		begin			GetDItem(GetUSelection, 61 + i, DType, DItem, tempRect);			EraseRect(tempRect);			if editingUser.msgFrmAccess[i] then			begin				MoveTo(tempRect.left, tempRect.top);				LineTo(tempRect.right - 1, tempRect.bottom - 1);				MoveTo(tempRect.right - 1, tempRect.top);				LineTo(tempRect.left, tempRect.bottom - 1);			end;			FrameRect(tempRect);		end;		for i := 1 to 26 do		begin			GetDItem(GetUSelection, 35 + i, DType, DItem, tempRect);			EraseRect(tempRect);			if editingUser.restrics[i] then				PaintRect(tempRect)			else				FrameRect(tempRect);		end;	end;	procedure Update_User_Edit;		var			SavedPort: GrafPtr;			tempRect: rect;			i: integer;	begin		if (GetUSelection <> nil) and (theWindow = GetUSelection) then		begin			GetPort(SavedPort);			SetPort(GetUSelection);			EraseRect(getUSelection^.portrect);			DrawDialog(GetUSelection);			ResetMyConts;			tempRect := multiUserList^^.rView;			if (tempRect.Right <= (tempRect.Left + 10)) then				tempRect.Right := tempRect.Left + 10;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			LUpdate(GetUSelection^.visRgn, multiUserList);			GetDItem(GetUSelection, 78, DType, DItem, tempRect);			FrameRect(temprect);			MoveTo(temprect.left + 7, temprect.bottom - 3);			DrawString('User#');			if namesdisplay = 1 then			begin				bitclr(ptr(hilitemode), philitebit);				InvertRect(temprect);			end;			GetDItem(GetUSelection, 79, DType, DItem, tempRect);			FrameRect(temprect);			MoveTo(temprect.left + 10, temprect.bottom - 3);			DrawString('A-Z');			if namesdisplay = 2 then			begin				bitclr(ptr(hilitemode), philitebit);				InvertRect(temprect);			end;			GetDItem(GetUSelection, 80, DType, DItem, tempRect);			FrameRect(temprect);			MoveTo(temprect.left + 4, temprect.bottom - 3);			DrawString('LastOn');			if namesdisplay = 3 then			begin				bitclr(ptr(hilitemode), philitebit);				InvertRect(temprect);			end;			SetPort(SavedPort);		end;	end;	procedure putNamesIn;		var			i: integer;			dType: integer;			dItem: handle;			tempRect: rect;			ds: str255;	begin		ds := ' ';		for i := 1 to (numUserRecs) do		begin			if (fullNames^^[i].del) then				ds[1] := '¥'			else				ds[1] := char($CA);			AddListString(concat(ds, fullNames^^[i].n), multiUserlist);		end;		GetDItem(GetUSelection, 83, DType, DItem, tempRect);		SetIText(DItem, concat('Found:', 'All'));	end;	procedure PutInUser;		var			tempString, tempString2, tempString3: str255;			tempDate: DateTimeRec;			bbc: longInt;			tempRect, tr2: Rect;			myC: Point;			DType, i: Integer;			DItem: Handle;			CItem, CTempItem: controlhandle;	begin		NumToString(editingUser.userNum, tempString);		GetDItem(GetUSelection, 18, DType, DItem, tempRect);		SetIText(DItem, concat('#', tempstring));		GetDItem(GetUSelection, 17, DType, DItem, tempRect);		SetIText(DItem, EditingUser.UserName);		GetDItem(GetUSelection, 19, DType, DItem, tempRect);		SetIText(DItem, editingUser.realName);		GetDItem(GetUSelection, 22, DType, DItem, tempRect);		SetIText(DItem, EditingUser.Password);		GetDItem(GetUSelection, 20, DType, DItem, tempRect);		SetIText(DItem, editingUser.phone);		GetDItem(GetUSelection, 33, DType, DItem, tempRect);		NumToString(editingUser.secLevel, tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 31, DType, DItem, tempRect);		NumToString(editingUser.DownloadedK, tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 35, DType, DItem, tempRect);		NumToString(editingUser.TransferLevel, tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 30, DType, DItem, tempRect);		NumToString(editingUser.UploadedK, tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 23, DType, DItem, tempRect);		SetIText(dItem, editingUser.computerType);		GetDItem(GetUSelection, 73, DType, DItem, tempRect);		SetIText(DItem, editingUser.sysopNote);		GetDItem(GetUSelection, 72, DType, DItem, tempRect);		NumToString(editingUser.lastBaud, tempString);		if tempString = '0' then			tempString := 'Keyboard';		SetIText(DItem, tempString);		GetDItem(GetUSelection, 25, DType, DItem, tempRect);		NumToString(editingUser.EMailSent, tempString);		NumToString(editingUser.messagesPosted, tempString2);		tempString := concat('P=', tempString2, '  E=', tempString);		SetIText(ditem, tempString);		GetDItem(GetUSelection, 32, DType, DItem, tempRect);		NumToString(editingUser.numDownloaded, tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 29, DType, DItem, tempRect);		NumToString(editingUser.numUploaded, tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 26, DType, DItem, tempRect);		NumToString(editingUser.TotalLogons, tempString);		numToString(editingUser.onToday, tempString2);		tempString := concat(tempString, '   ', tempString2, '   I=');		NumToString(editingUser.illegalLogons, tempstring2);		SetIText(DItem, concat(tempString, tempstring2));		GetDItem(GetUSelection, 21, DType, DItem, tempRect);		NumToString(integer(editingUser.birthMonth), tempString);		NumToString(integer(editingUser.birthDay), tempString2);		tempString := concat(tempString, '/', tempString2, '/');		NumToString(integer(editingUser.birthYear), tempString2);		tempString := concat(tempString, tempString2);		NumToString(editingUser.age, tempString2);		if editingUser.sex then			tempString := concat(tempString2, '  M   ', tempString)		else			tempString := concat(tempString2, '  F   ', tempString);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 24, DType, DItem, tempRect);		IUDateString(editingUser.lastOn, shortDate, tempstring2);		IUDateString(editingUser.firstOn, shortDate, tempstring);		tempstring := concat(tempstring2, '  ', tempstring);		SetIText(DItem, tempString);		GetDItem(GetUSelection, 76, DType, DItem, tempRect);		CItem := Pointer(DItem);		if editingUser.Deleting then			SetCtlValue(CItem, 1)		else			SetCtlValue(CItem, 0);		GetDItem(GetUSelection, 74, DType, DItem, tempRect);		CItem := Pointer(DItem);		if editingUser.coSysop then			SetCtlValue(CItem, 1)		else			SetCtlValue(CItem, 0);		GetDItem(GetUSelection, 81, DType, DItem, tempRect);		CItem := Pointer(DItem);		if editingUser.alertOn then			SetCtlValue(CItem, 1)		else			SetCtlValue(CItem, 0);	end;	procedure QuickSortUsers (Start, Finish: integer);		var			left, right: integer;			starterValue, temp: FullUNamesRec;	begin		with curglobs^ do		begin			left := start;			right := finish;			StarterValue := fullnames^^[(start + finish) div 2];			repeat				while (IUCompString(fullnames^^[left].n, starterValue.n) = -1) do					left := left + 1;				while (IUCompString(starterValue.n, fullnames^^[right].n) = -1) do					right := right - 1;				if left <= right then				begin					temp := fullnames^^[left];					fullnames^^[left] := fullnames^^[right];					fullnames^^[right] := temp;					left := left + 1;					right := right - 1;				end;			until right <= left;			if start < right then				QuickSortUsers(start, right);			if left < finish then				QuickSortUsers(left, finish);		end;	end;	procedure QuickSortUsersLO (Start, Finish: integer);		var			left, right: integer;			starterValue, temp: FullUNamesRec;	begin		with curglobs^ do		begin			left := start;			right := finish;			StarterValue := fullnames^^[(start + finish) div 2];			repeat				while fullnames^^[left].lo > starterValue.lo do					left := left + 1;				while starterValue.lo > fullnames^^[right].lo do					right := right - 1;				if left <= right then				begin					temp := fullnames^^[left];					fullnames^^[left] := fullnames^^[right];					fullnames^^[right] := temp;					left := left + 1;					right := right - 1;				end;			until right <= left;			if start < right then				QuickSortUsersLO(start, right);			if left < finish then				QuickSortUsersLO(left, finish);		end;	end;	procedure MakeFullNames (whichWay: integer);		var			i: integer;	begin		SetCursor(GetCursor(watchCursor)^^);		if FullNames <> nil then		begin			DisposHandle(handle(fullnames));			fullNames := nil;		end;		fullNames := FullNameHand(NewHandle(SizeOf(FullUNamesRec) * longint(numUserRecs)));		MoveHHi(handle(fullNames));		HNoPurge(handle(fullNames));		for i := 1 to numUserRecs do		begin			fullNames^^[i].n := myUsers^^[i - 1].UName;			fullnames^^[i].lo := myUsers^^[i - 1].last;			fullNames^^[i].del := myUsers^^[i - 1].dltd;		end;		case whichway of			2: 			begin				QuickSortUsers(1, numUserRecs);			end;			3: 			begin				QuickSortUsersLO(1, numUserRecs);			end;			otherwise		end;	end;	procedure Open_User_Edit;		var			ThisEditText: TEHandle;			TheDialogPtr: DialogPeek;			tempRect, tr2: Rect;			myC: Point;			DType, i: Integer;			DItem: Handle;	begin		if (GetUSelection = nil) then		begin			namesdisplay := 1;			makeFullNames(1);			GetUSelection := GetNewDialog(2, nil, Pointer(-1));			SetPort(GetUSelection);			TheDialogPtr := DialogPeek(GetUSelection);			ThisEditText := TheDialogPtr^.textH;			HLock(Handle(ThisEditText));			ThisEditText^^.txSize := 9;			TextSize(9);			ThisEditText^^.txFont := monaco;			TextFont(monaco);			ThisEditText^^.txFont := 4;			ThisEditText^^.fontAscent := 9;			ThisEditText^^.lineHeight := 9 + 2 + 0;			HUnLock(Handle(ThisEditText));			GetDItem(GetUSelection, 75, DType, DItem, tempRect);			TempRect.right := tempRect.right - 14;			SetRect(tr2, 0, 0, 1, 0);			SetPt(myC, tempRect.right - tempRect.left, 12);			multiUserList := LNew(tempRect, tr2, myC, 0, getUSelection, false, false, false, true);			PutNamesIn;			LDoDraw(true, multiUserList);			PutInUser;			ShowWindow(GetUSelection);			SelectWindow(GetUSelection);		end		else			SelectWindow(GetUSelection);	end;	procedure GetStuff;		var			tempString, tempString2, tempString3: str255;			tempDate: DateTimeRec;			i, tempLong: longInt;			tempRect: Rect;			DType, tempInt: Integer;			DItem: Handle;			CItem, CTempItem: controlhandle;	begin		GetDItem(GetUSelection, 17, DType, DItem, tempRect);		GetIText(DItem, tempString);		if (length(tempString) > 0) and ((tempstring[1] > char(57)) or (tempstring[1] < char(48))) and not (pos('*', tempString) > 0) then		begin			if not optionDown then				DoCapsName(tempstring);			EditingUser.UserName := tempString;		end		else		begin			SysBeep(10);			SetIText(Ditem, editingUser.userName);		end;		GetDItem(GetUSelection, 19, DType, DItem, tempRect);		GetIText(DItem, tempString);		EditingUser.RealName := tempString;		GetDItem(GetUSelection, 22, DType, DItem, tempRect);		GetIText(DItem, tempString);		UprString(tempString, true);		EditingUser.Password := tempString;		GetDItem(GetUSelection, 20, DType, DItem, tempRect);		GetIText(DItem, tempString);		EditingUser.Phone := tempString;		GetDItem(GetUSelection, 73, DType, DItem, tempRect);		GetIText(DItem, tempString);		EditingUser.SysopNote := tempString;		GetDItem(GetUSelection, 33, DType, DItem, tempRect);		GetIText(DItem, tempString);		StringToNum(tempString, i);		EditingUser.SecLevel := i;		GetDItem(GetUSelection, 31, DType, DItem, tempRect);		GetIText(DItem, tempString);		StringToNum(tempString, i);		EditingUser.DownloadedK := i;		GetDItem(GetUSelection, 32, DType, DItem, tempRect);		GetIText(DItem, tempString);		StringToNum(tempString, i);		EditingUser.numDownloaded := i;		GetDItem(GetUSelection, 29, DType, DItem, tempRect);		GetIText(DItem, tempString);		StringToNum(tempString, i);		EditingUser.numUploaded := i;		GetDItem(GetUSelection, 35, DType, DItem, tempRect);		GetIText(DItem, tempString);		StringToNum(tempString, i);		EditingUser.TransferLevel := i;		GetDItem(GetUSelection, 30, DType, DItem, tempRect);		GetIText(DItem, tempString);		StringToNum(tempString, i);		EditingUser.UploadedK := i;		GetDItem(GetUSelection, 76, DType, DItem, tempRect);		CItem := Pointer(DItem);		tempInt := GetCtlValue(CItem);		if tempInt = 1 then			EditingUser.Deleting := true		else			EditingUser.Deleting := false;		GetDItem(GetUSelection, 74, DType, DItem, tempRect);		CItem := Pointer(DItem);		tempInt := GetCtlValue(CItem);		if tempInt = 1 then			EditingUser.coSysop := true		else			EditingUser.coSysop := false;		GetDItem(GetUSelection, 81, DType, DItem, tempRect);		CItem := Pointer(DItem);		tempInt := GetCtlValue(CItem);		if tempInt = 1 then			EditingUser.alertOn := true		else			EditingUser.alertOn := false;		if EditingUser.UserNum = 1 then		begin			EditingUser.SecLevel := 255;			EditingUser.TransferLevel := 255;		end;		with theNodes[visibleNode]^ do		begin			if (thisUser.userNum = editingUser.userNum) then			begin				realSL := EditingUser.SecLevel;				thisUser := EditingUser;			end;		end;		WriteUser(EditingUser);		myUsers^^[editingUser.userNum - 1].UName := editingUser.userName;		myUsers^^[editingUser.userNum - 1].dltd := editingUser.deleting;		myUsers^^[editingUser.userNum - 1].real := editingUser.realName;		myUsers^^[editingUser.userNum - 1].SL := editingUser.secLevel;		myUsers^^[editingUser.userNum - 1].DSL := editingUser.transferLevel;	end;	procedure Close_User_Edit;	begin		if (theWindow = GetUSelection) and (GetUSelection <> nil) then		begin			if not Cancelled then			begin				GetStuff;			end;			LDispose(multiUserList);			DisposDialog(GetUSelection);			GetUSelection := nil;			if FullNames <> nil then			begin				DisposHandle(handle(fullnames));				fullNames := nil;			end;		end;	end;	function GetUserNum (var ttUser: UserRec; getNum: integer): boolean;		var			tempString: str255;			tempInt, SizeOfAUser, UserNum, HermesRef: integer;			tempLong, AllUsersSize: longInt;			result: OSerr;			tempProcResult: boolean;	begin		UserNum := getNum;		tempProcResult := false;		if UserNum > 0 then		begin			HermesRef := DShared;			result := GetEOF(HermesRef, AllUsersSize);			SizeOfAUser := SizeOf(UserRec);			if ((AllUsersSize div SizeOfaUser) >= UserNum) then			begin				result := SetFPos(HermesRef, fsFromStart, SizeOf(UserRec) * (longInt(UserNum - 1)));				tempLong := SizeOf(UserRec);				Result := FSRead(HermesRef, tempLong, @ttUser);				if ttUser.UserNum = UserNum then					tempProcResult := true				else					tempProcResult := false;			end			else				tempProcResult := false;		end;		GetUserNum := tempprocResult;	end;	function ComputerNumber (lookUp: str255): integer;		var			ts: str255;			i: integer;			gotIt: boolean;	begin		i := 0;		gotit := false;		GetIndString(ts, 15, i);		repeat			if (EqualString(ts, lookUp, false, false)) then				gotIt := true;			i := i + 1;			GetIndString(ts, 15, i);		until ((ts = '') or gotIt);		if gotIt then			ComputerNumber := i - 1		else			ComputerNumber := -1;	end;	procedure Do_User_Edit;		var			tempint, i, chCode, SLstat, DSLstat, theSL, theDSL, LOstat, firstStat, lastDays, count, firstDays: integer;			myPt: Point;			doubleClick, pass1, pass2, pass3, pass4, pass5: boolean;			temprect: rect;			tempCell: cell;			ttUser: userRec;			tempString, t1, t2, searchName: str255;			tempInt2, result, tempLong: longInt;			tempEMa: EMailRec;			askDilg: dialogPtr;			tempMenu: MenuHandle;	begin		ExitDialog := FALSE;		if (GetUSelection <> nil) then		begin			if (getUSelection = FrontWindow) then			begin				SetPort(GetUSelection);				myPt := theEvent.where;				GlobalToLocal(myPt);				GetDItem(GetUSelection, itemHit, DType, DItem, tempRect);				CItem := Pointer(DItem);				case itemHit of					78: 					begin						namesDisplay := 1;						temprect := multiUserList^^.rView;						temprect.top := temprect.bottom - 20;						OffsetRect(temprect, 0, 20);						InvalRect(temprect);						LDoDraw(false, multiUserList);						LDelRow(0, 0, multiUserList);						MakeFullNames(1);						PutNamesIn;						InvalRect(multiuserList^^.rView);						LDoDraw(true, multiUserList);						DrawDialog(getUSelection);					end;					79: 					begin						namesDisplay := 2;						LDoDraw(false, multiUserList);						LDelRow(0, 0, multiUserList);						MakeFullNames(2);						PutNamesIn;						temprect := multiuserList^^.rView;						temprect.bottom := temprect.bottom + 20;						InvalRect(temprect);						LDoDraw(true, multiUserList);						DrawDialog(getUSelection);					end;					80: 					begin						namesDisplay := 3;						LDoDraw(false, multiUserList);						LDelRow(0, 0, multiUserList);						MakeFullNames(3);						PutNamesIn;						temprect := multiuserList^^.rView;						temprect.bottom := temprect.bottom + 20;						InvalRect(temprect);						LDoDraw(true, multiUserList);						DrawDialog(getUSelection);					end;					23: 					begin						tempMenu := NewMenu(60, 'Computer Type');						if (tempMenu <> nil) then						begin							i := 1;							GetIndString(t1, 15, i);							repeat								i := i + 1;								if t1 <> '' then								begin									AppendMenu(tempMenu, ' ');									SetItem(tempMenu, countMItems(tempMenu), t1);									GetIndString(t1, 15, i);								end;							until (t1 = '');							InsertMenu(tempMenu, -1);							myPt.v := tempRect.top;							myPt.h := tempRect.left;							LocalToGlobal(myPt);							tempInt := ComputerNumber(editingUser.computerType);							CheckItem(tempMenu, tempInt, TRUE);							result := PopUpMenuSelect(tempMenu, myPt.v, myPt.h, tempInt);							if (tempInt <> LoWord(Result)) and (LoWord(Result) > 0) then							begin								tempInt := LoWord(Result);								GetIndString(tempString, 15, tempInt);								SetIText(DItem, tempString);								editingUser.computerType := tempString;							end;							DeleteMenu(60);							DisposeMenu(tempMenu)						end;					end;					74, 81: 					begin						temp := GetCtlValue(CItem);						SetCtlValue(CItem, (temp + 1) mod 2);					end;					76: 					begin						temp := GetCtlValue(CItem);						SetCtlValue(CItem, (temp + 1) mod 2);						if temp = 0 then						begin							IntSystRec.numUsers := IntSystRec.numUsers - 1;							doSystRec(true);							with curglobs^ do							begin								i := 0;								while (i < availEmails) do								begin									if theEmail^^[i].toUser = editingUser.userNum then										DeleteMail(i)									else										i := i + 1;								end;							end;						end						else						begin							IntSystRec.numUsers := IntSystRec.numUsers + 1;							doSystRec(true);						end;					end;					62, 63, 64, 65, 66, 67, 68, 69, 70, 71: 					begin						GetDItem(GetUSelection, itemHit, DType, DItem, tempRect);						EraseRect(tempRect);						if editingUser.msgFrmAccess[itemhit - 61] then							editingUser.msgFrmAccess[itemhit - 61] := false						else							editingUser.msgFrmAccess[itemhit - 61] := true;						if editingUser.msgFrmAccess[itemHit - 61] then						begin							MoveTo(tempRect.left, tempRect.top);							LineTo(tempRect.right - 1, tempRect.bottom - 1);							MoveTo(tempRect.right - 1, tempRect.top);							LineTo(tempRect.left, tempRect.bottom - 1);						end;						FrameRect(tempRect);					end;					77: 					begin						askDilg := GetNewDialog(3467, nil, pointer(-1));						SetPort(askDilg);						ShowWindow(askDilg);						GetDItem(askDilg, 1, DType, DItem, tempRect);						InsetRect(tempRect, -4, -4);						PenSize(3, 3);						FrameRoundRect(tempRect, 16, 16);						GetDItem(askDilg, 11, DType, DItem, tempRect);						SetCtlValue(controlHandle(DItem), 1);						GetDItem(askDilg, 14, DType, DItem, tempRect);						SetCtlValue(controlHandle(DItem), 1);						GetDItem(askDilg, 17, DType, DItem, tempRect);						SetCtlValue(controlHandle(DItem), 1);						GetDItem(askDilg, 22, DType, DItem, tempRect);						SetCtlValue(controlHandle(DItem), 1);						SLstat := 2;						DSLstat := 2;						LOstat := 1;						firstStat := 1;						repeat							ModalDialog(nil, i);							if (i >= 9) and (i <= 11) then							begin								for tempint := 1 to 3 do								begin									GetDItem(askDilg, 8 + tempint, DType, DItem, tempRect);									SetCtlValue(controlHandle(DItem), 0);								end;								SLstat := i - 9;								GetDItem(askDilg, i, DType, DItem, tempRect);								SetCtlValue(controlHandle(DItem), 1);							end;							if (i >= 12) and (i <= 14) then							begin								for tempint := 1 to 3 do								begin									GetDItem(askDilg, 11 + tempint, DType, DItem, tempRect);									SetCtlValue(controlHandle(DItem), 0);								end;								DSLstat := i - 12;								GetDItem(askDilg, i, DType, DItem, tempRect);								SetCtlValue(controlHandle(DItem), 1);							end;							if (i >= 16) and (i <= 17) then							begin								for tempint := 1 to 2 do								begin									GetDItem(askDilg, 15 + tempint, DType, DItem, tempRect);									SetCtlValue(controlHandle(DItem), 0);								end;								LOstat := i - 16;								GetDItem(askDilg, i, DType, DItem, tempRect);								SetCtlValue(controlHandle(DItem), 1);							end;							if (i >= 21) and (i <= 22) then							begin								for tempint := 1 to 2 do								begin									GetDItem(askDilg, 20 + tempint, DType, DItem, tempRect);									SetCtlValue(controlHandle(DItem), 0);								end;								firstStat := i - 21;								GetDItem(askDilg, i, DType, DItem, tempRect);								SetCtlValue(controlHandle(DItem), 1);							end;						until (i = 1);						GetDItem(askDilg, 3, DType, DItem, tempRect);						GetIText(DItem, searchName);						UprString(searchName, true);						GetDItem(askDilg, 7, DType, DItem, tempRect);						GetIText(DItem, tempstring);						StringToNum(tempstring, tempLong);						theSL := templong;						GetDItem(askDilg, 8, DType, DItem, tempRect);						GetIText(DItem, tempstring);						StringToNum(tempstring, tempLong);						theDSL := templong;						GetDItem(askDilg, 18, DType, DItem, tempRect);						GetIText(DItem, tempstring);						StringToNum(tempstring, tempLong);						lastDays := templong;						GetDItem(askDilg, 23, DType, DItem, tempRect);						GetIText(DItem, tempstring);						StringToNum(tempstring, tempLong);						firstDays := templong;						DisposDialog(askDilg);						SetPort(getUSelection);						count := 0;						if (length(searchname) > 0) and (searchName[1] > char(47)) and (searchName[1] < char(58)) then						begin							GetStuff;							if FindUser(searchName, ttUser) then							begin								editingUser := ttUser;								PutInUser;								DrawDialog(getUSelection);								ResetMyConts;							end;						end						else if (length(searchName) > 0) or (theSL > 0) or (theDSL > 0) or (lastDays > 0) or (firstDays > 0) then						begin							SetCursor(GetCursor(watchCursor)^^);							LDoDraw(false, multiUserList);							LDelRow(0, 0, multiUserList);							for i := 1 to numUserRecs do							begin								pass1 := false;								pass2 := false;								pass3 := false;								pass4 := false;								pass5 := false;								if length(searchname) > 0 then								begin									tempstring := myUsers^^[i - 1].UName;									UprString(tempstring, true);									if pos(searchName, tempstring) > 0 then										pass1 := true;								end								else									pass1 := true;								if theSL > 0 then								begin									case SLstat of										0: 											if myUsers^^[i - 1].SL > theSL then												pass2 := true;										1: 											if myUsers^^[i - 1].SL < theSL then												pass2 := true;										2: 											if myUsers^^[i - 1].SL = theSL then												pass2 := true;										otherwise									end;								end								else									pass2 := true;								if theDSL > 0 then								begin									case DSLstat of										0: 											if myUsers^^[i - 1].DSL > theDSL then												pass3 := true;										1: 											if myUsers^^[i - 1].DSL < theDSL then												pass3 := true;										2: 											if myUsers^^[i - 1].DSL = theDSL then												pass3 := true;										otherwise									end;								end								else									pass3 := true;								if lastDays > 0 then								begin									GetDateTime(tempLong);									case LOstat of										0: 											if (tempLong - myUsers^^[i - 1].last) > (lastDays * 86400) then												pass4 := true;										1: 											if (tempLong - myUsers^^[i - 1].last) < (lastDays * 86400) then												pass4 := true;										otherwise									end;								end								else									pass4 := true;								if firstDays > 0 then								begin									GetDateTime(tempLong);									case FirstStat of										0: 											if (tempLong - myUsers^^[i - 1].first) > (firstDays * 86400) then												pass5 := true;										1: 											if (tempLong - myUsers^^[i - 1].first) < (firstDays * 86400) then												pass5 := true;										otherwise									end;								end								else									pass5 := true;								if pass1 and pass2 and pass3 and pass4 and pass5 then								begin									t1 := ' ';									if (myUsers^^[i - 1].dltd) then										t1[1] := '¥'									else										t1[1] := char($CA);									AddListString(concat(t1, myUsers^^[i - 1].uName), multiUserlist);									count := count + 1;								end;							end;							NumToString(count, tempString);							GetDItem(GetUSelection, 83, DType, DItem, tempRect);							SetIText(DItem, concat('Found:', tempstring));							tempRect := multiuserList^^.rView;							tempRect.right := tempRect.right + 16;							InvalRect(tempRect);							LDoDraw(true, multiUserList);							DrawDialog(getUSelection);						end;					end;					75: 					begin						DoubleClick := LClick(myPt, theEvent.modifiers, multiUserList);						tempCell.h := 0;						tempCell.v := 0;						if LGetSelect(true, tempCell, multiUserList) then						begin							tempint := 50;							LGetCell(@tempString[1], tempint, tempCell, multiUserList);							tempString[0] := char(tempint);							if tempstring <> editingUser.userName then							begin								GetStuff;								delete(tempString, 1, 1);								if FindUser(tempString, ttUser) then								begin									editingUser := ttUser;									PutInUser;									DrawDialog(getUSelection);									ResetMyConts;								end;							end;						end;					end;					otherwise					begin						if (itemHit >= 36) and (itemHit <= 61) then						begin							GetDItem(GetUSelection, itemHit, DType, DItem, tempRect);							EraseRect(tempRect);							if editingUser.restrics[itemHit - 35] then								editingUser.restrics[itemHit - 35] := false							else								editingUser.restrics[itemHit - 35] := true;							if editingUser.restrics[itemhit - 35] then								PaintRect(tempRect)							else								FrameRect(tempRect);						end;					end;				end;			end			else				SelectWindow(getUSelection);		end;	end;	procedure WriteUser;		var			tempstring: str255;			HermesRef: integer;			result: OSerr;			SizeofAUser: LongInt;	begin		HermesRef := DShared;		SizeOfaUser := SizeOf(UserRec);		result := SetFPos(HermesRef, fsFromStart, (SizeOfaUser * longint(theUser.UserNum - 1)));		Result := FSWrite(HermesRef, SizeofAUser, @theUser);	end;	procedure MakeUserList;		type			UserArrPtr = ^UserArrRec;			UserArrRec = array[0..31] of UserRec;		var			tempString, tempString2: str255;			tempInt, SizeOfAUser, UserNum, HermesRef, ListRef, i, c: integer;			tempLong, AllUsersSize, b: longInt;			result: OSerr;			myUserArr: UserArrPtr;	begin		doSystRec(false);		if myUsers <> nil then		begin			HPurge(handle(myUsers));			DisposHandle(handle(myUsers));			myUsers := nil;		end;		HermesRef := DShared;		IntSystRec.numUsers := 0;		numUserRecs := 0;		result := GetEOF(HermesRef, AllUsersSize);		SizeofAUser := SizeOf(UserRec);		if AllUsersSize >= SizeOfAUser then		begin			numUserRecs := AllusersSize div SizeOf(userRec);			myUsers := UListHand(NewHandle((AllUsersSize div SizeOf(userRec)) * SizeOf(ULR)));			MoveHHi(handle(myUsers));			HNoPurge(handle(myUsers));			SizeOfAUser := SizeOf(UserRec);			myUserArr := UserArrPtr(NewPtr(SizeOf(UserArrRec)));			result := SetFPos(HermesRef, fsFromStart, 0);			i := 0;			while (i < (allusersSize div SizeOfAUser)) do			begin				tempLong := SizeOf(UserRec) * longint(32);				result := FSRead(hermesRef, tempLong, pointer(myUserArr));				b := tempLong div SizeOf(UserRec);				if b > 0 then				begin					for c := 1 to b do					begin						i := i + 1;						myUsers^^[i - 1].UName := myUserArr^[c - 1].userName;						myUsers^^[i - 1].dltd := myUserArr^[c - 1].deleting;						myUsers^^[i - 1].last := myUserArr^[c - 1].lastOn;						myUsers^^[i - 1].first := myUserArr^[c - 1].firstOn;						myUsers^^[i - 1].SL := myUserArr^[c - 1].secLevel;						myUsers^^[i - 1].DSL := myUserArr^[c - 1].transferLevel;						myUsers^^[i - 1].real := myUserArr^[c - 1].realName;						if not myUserArr^[c - 1].deleting then							IntSystRec.numUsers := IntSystRec.numUsers + 1;					end;				end;			end;			DisposPtr(ptr(myUserArr));		end;		doSystRec(true);	end;	function FindUser (searchString: str255; var userFound: UserRec): boolean;		var			tempString, tempString2: str255;			tempInt, SizeOfAUser, UserNum, HermesRef, i: integer;			tempLong, AllUsersSize: longInt;			myHParmer: HParmBlkPtr;			myParmer: ParmBlkPtr;			result: OSerr;			tempProcResult, foundit, WILD: boolean;			ListRefHand: TextHand;			myUserHand: UserHand;	begin		tempProcResult := false;		if (length(SearchString) > 0) then		begin			if (SearchString[1] > char(47)) and (SearchString[1] < char(58)) then			begin				tempString := SearchString;				StringToNum(tempString, tempLong);				UserNum := tempLong;				if GetUserNum(UserFound, UserNum) then					tempProcResult := true;			end			else			begin				WILD := false;				FOUNDIT := FALSE;				if (searchString[length(searchString)] = '*') then				begin					WILD := true;					SearchString[0] := char(length(searchString) - 1);				end;				if (numUserRecs > 0) then				begin					i := 0;					repeat						tempString := myUsers^^[i].UName;						if WILD and (length(tempString) >= length(searchString)) then							tempString[0] := char(length(SearchString));						if EqualString(tempString, searchString, false, false) then							foundIt := true;						i := i + 1;					until (i >= numUserRecs) or foundIt;				end;				if foundIt then				begin					if GetUserNum(UserFound, i) then						tempProcResult := true;				end;			end;		end;		FindUser := tempProcResult;	end;	procedure SysopLog (toLog: str255; color: integer);	begin		if (curglobs^.thisUser.userNum > 1) or not curglobs^.sysopLogon then			LogThis(toLog, color);	end;	procedure LogThis;		var			tempString: str255;			LogRef, i, tempUserNum: integer;			AllUsersSize, SizeofAUser: longInt;			result, myOSerr: OSerr;			myUserHand: UserHand;	begin		if writeDirectToLog then			tempString := concat(sharedPath, 'Today Log')		else		begin			NumToString(activeNode, tempString);			tempString := concat(sharedPath, 'Temp Log', tempString);		end;		result := FSOpen(tempString, 0, LogRef);		if result <> noErr then		begin			result := FSDelete(tempString, 0);			result := Create(tempString, 0, 'HRMS', 'TEXT');			result := FSOpen(tempString, 0, LogRef);		end;		if result = noErr then		begin			logit := concat(logit, char(13));			result := GetEOF(LogRef, AllUsersSize);			result := SetFPos(LogRef, fsFromStart, allUsersSize);			sizeOfAUser := length(LogIt);			result := FSWrite(LogRef, SizeOfAUser, @LogIt[1]);			result := FSClose(LogRef);		end;	end;	procedure WriteTempLog2Log;		var			tempString: str255;			LogRef, i, tempUserNum: integer;			AllUsersSize, SizeofAUser, ss2: longInt;			result, myOSerr: OSerr;			myUserHand: UserHand;	begin		with curglobs^ do		begin			NumToString(activeNode, tempString);			tempString := concat(sharedPath, 'Temp Log', tempString);			result := FSOpen(tempString, 0, LogRef);			if result = noErr then			begin				result := GetEOF(LogRef, AllUsersSize);				result := SetFPos(LogRef, fsFromStart, 0);				SizeOfAUser := AllUsersSize;				TextHnd := TextHand(NewHandle(SizeOfAUser));				MoveHHi(handle(textHnd));				HLock(handle(TextHnd));				ss2 := AllUsersSize;				result := FSRead(LogRef, SizeOfAUser, pointer(TextHnd^));				result := FSClose(LogRef);				result := FSDelete(tempstring, 0);				tempString := concat(SharedPath, 'Today Log');				result := FSOpen(tempString, 0, LogRef);				if result <> noErr then				begin					result := Create(tempString, 0, 'HRMS', 'TEXT');					result := FSOpen(tempString, 0, LogRef);				end;				if result = noErr then				begin					result := GetEOF(LogRef, AllUsersSize);					result := SetFPos(LogRef, fsFromStart, AllUsersSize);					result := FSWrite(LogRef, ss2, @TextHnd^^[0]);					result := FSClose(LogRef);				end;				HUnlock(handle(textHnd));				DisposHandle(handle(textHnd));				TextHnd := nil;			end;		end;	end;	function checktitle (thetit: str255): boolean;		var			i: integer;	begin		with curglobs^ do		begin			i := 1;			while (i < curNumMess) and (curBase^^[i - 1].title <> thetit) do				i := i + 1;			if curbase^^[i - 1].title = theTit then				checktitle := true			else				checktitle := false;		end;	end;	procedure doTabbyImport;		type			TabbyHeader2 = packed array[1..26] of char;{with trailing return}		var			tabRef, dm, i, messageLen, realLen: integer;			impTab: tabbyHeader2;			waitDilg: dialogPtr;			place, total, templong, tl2, counter, toRead, curPlace, mImported: longint;			tempchar: char;			noEnd: boolean;			t1, fromS, tos, t9: str255;			nextTime: packed array[1..4] of char;			nextTimeFull: dateTimeRec;			GenericImport: charsHandle;	begin		if IntSystRec.tabbyNet then		begin			tabbyPath := '';			result := FSOpen('Generic', 0, tabRef);			if result = noErr then			begin				result := GetEOF(tabRef, place);				for i := 1 to place do					tabbyPath := concat(' ', tabbyPath);				result := FSRead(tabRef, place, @tabbyPath[1]);				delete(tabbyPath, length(tabbyPath), 1);				result := FSClose(tabRef);			end;			result := FSOpen('Next Event', 0, tabref);			if result = noErr then			begin				templong := 4;				result := FSRead(tabRef, templong, @nextTime);				GetDateTime(templong);				tl2 := templong;				Secs2Date(tl2, nextTimeFull);				t1 := copy(nextTime, 1, 2);				StringToNum(t1, tl2);				nextTimeFull.hour := tl2;				t1 := copy(nextTime, 3, 2);				StringToNum(t1, tl2);				nextTimeFull.minute := tl2;				Date2Secs(nextTimeFull, tl2);				if tl2 < templong then					tl2 := tl2 + 86400;				dailyTabbyTime := tl2;				result := FSClose(tabRef);			end			else				dailyTabbyTime := 0;			result := FSDelete(concat(tabbyPath, 'Old GenImport'), 0);			curglobs^.curWriting := nil;			GenericImport := nil;			counter := 0;			place := 0;			mImported := 0;			total := 0;			result := FSOpen(concat(tabbypath, 'Generic Import'), 0, tabRef);			if (result = noErr) then			begin				for i := 1 to intSystRec.numNodes do				begin					if theNodes[i]^.goOffInlocal then					begin						curGlobs := theNodes[i];						activeNode := i;						TellModem('ATH1');					end;				end;				activeNode := 1;				curGlobs := thenodes[1];				with curglobs^ do				begin					waitDilg := GetNewDialog(200, nil, pointer(-1));					ParamText('Importing network messages: 0', '', '', '');					DrawDialog(waitDilg);					GenericImport := charsHandle(newHandle(30000));					if memError = noErr then					begin						HNoPurge(handle(genericImport));						result := GetEOF(tabRef, total);						if TOTAL > 20 then						begin							repeat								toRead := 30000;								toRead := toRead - counter;								if toRead + place > total then									toRead := total - place;								result := FSRead(tabRef, toRead, @GenericImport^^[counter]);								counter := toRead;								place := place + toRead;								noEnd := false;								repeat									curPlace := 0;									repeat										curPlace := curPlace + 1;									until (curPlace >= counter) or (GenericImport^^[curPlace - 1] = char(0));									if (genericImport^^[curPlace - 1] = char(0)) then									begin										messageLen := curPlace - 26;										curWriting := TextHand(newHandle(messageLen + 10));										HNoPurge(handle(curWriting));										BlockMove(@GenericImport^^[0], @impTab[1], 26);										BlockMove(@GenericImport^^[26], pointer(curWriting^), messageLen);										realLen := 0;										i := 0;										dm := 0;										while (i <= messageLen) do										begin											if (curWriting^^[i] = char(0)) then											begin												realLen := i;												i := messageLen;											end											else											begin												if (curWriting^^[i] = char(1)) then												begin													dm := i;													repeat														i := i + 1;													until (curWriting^^[i] = char(13)) or (curWriting^^[i] = char(0));													BlockMove(pointer(@curWriting^^[i + 1]), pointer(@curWriting^^[dm]), messageLen - (i + 1));													i := dm;													dm := 0;													i := i - 1;												end;												if (curWriting^^[i] <> char(13)) then													dm := dm + 1												else													dm := 0;												if (dm = 79) then												begin													while (curWriting^^[i] <> ' ') and (dm > 40) do													begin														i := i - 1;														dm := dm - 1;													end;													dm := 0;													if (curWriting^^[i] = ' ') then														curWriting^^[i] := char(13);												end;											end;											i := i + 1;										end;										curWriting^^[realLen] := char(26);										SetHandleSize(handle(curWriting), realLen + 1);										if (impTab[2] = 'M') and (impTab[1] <> 'D') then										begin											t1 := TakeMsgTop;											froms := TakeMsgTop;											fromS := concat(froms, ', ', t1);											tos := TakeMsgTop;											t1 := takeMsgTop;											if curWriting^^[0] = char(1) then												t9 := takeMsgTop;											with curEmailRec do											begin												anonyFrom := false;												anonyTo := false;												fromUser := TABBYTOID;												if FindUser(tos, tempUser) then													toUser := tempuser.userNum												else													toUser := 1;												title := t1;												GetDateTime(dateSent);												MType := 1;												multiMail := false;												AddLine('');												AddLine(froms);												if SaveMessAsEmail then													mImported := mImported + 1												else													LogThis('IMPORT ERROR: EMAIL DATABASE IS FULL', 6);											end;										end										else if (impTab[2] = 'E') and (impTab[1] <> 'D') then										begin											t1 := copy(impTab, 5, 3);											StringToNum(t1, templong);											inForum := templong div 30 + 1;											inSub := templong - ((inforum - 1) * 30);											t1 := takeMsgTop;											froms := TakeMsgTop;											if length(t1) > 0 then												fromS := concat(fromS, ', ', t1);											tos := TakeMsgTop;											if curWriting^^[0] = char(1) then												t9 := takeMsgTop;											t1 := takeMsgTop;											if curWriting^^[0] = char(1) then												t9 := takeMsgTop;											if curWriting^^[0] = char(1) then												t9 := takeMsgTop;											if (intMessStuff^^.boards[inforum, inSub].echoConf) and (inForum <= intMessStuff^^.numForums) and (inSub <= intMessstuff^^.numBoards[inforum]) then											begin												curMesgRec.title := t1;												if (pos('RE: ', t1) = 1) then													curMesgRec.title := concat(char(0), curMesgRec.title);												curMesgRec.AnonyFrom := false;												curMesgRec.anonyTo := false;												curMesgRec.fromUserNum := TABBYTOID;												curMesgRec.fromUserName := fromS;												if FindUser(tos, editingUser) then													curMesgRec.toUserNum := editingUser.userNum												else													curMesgRec.toUserNum := TABBYTOID;												curMesgRec.touserName := tos;												curMesgRec.deletable := true;												curMesgRec.storageType := intMessStuff^^.boards[inforum, insub].storetype;												GetDateTime(tempLong);												curMesgRec.daten := templong;												curMesgRec.qScnPtr := intSystRec.qscanpointer + 1;												for i := 0 to 9 do													curMesgRec.reserved[i] := char(0);												t1 := copy(impTab, 9, 17);												t1[9] := ' ';												AddLine('');												AddLine(t1);												if SavePost(inforum, inSub) then													mImported := mImported + 1												else												begin													NumToString(inForum, t1);													NumToString(inSub, t9);													LogThis(concat('IMPORT ERROR: FORUM ', t1, ', SUB ', t9, ' IS FULL.'), 6);												end;												intSystRec.qScanPointer := intSystRec.qScanPointer + 1;												intSystRec.mPostedToday := intSystRec.mPostedToday + 1;												OpenBase(inForum, inSub, false);												if curNumMess > intMessStuff^^.boards[inForum, inSub].maxMessages then												begin													dm := 0;													i := 1;													while (dm = 0) and (i <= curNumMess) do													begin														if curBase^^[i - 1].deletable then															dm := i;														i := i + 1;													end;													if dm = 0 then														dm := 1;													CloseBase;													DeletePost(inForum, inSub, dm, true);												end;											end;										end;										HUnlock(handle(curWriting));										HPurge(handle(curWriting));										DisposHandle(handle(curWriting));										curWriting := nil;										CURPLACE := CURPLACE + 1;										if counter - curPlace > 0 then											BlockMove(@GenericImport^^[curPlace], @GenericImport^^[0], counter - curPlace);										counter := counter - curPlace;										NumToString(mImported, t1);									end									else										NoEnd := true;									ParamText(concat('Importing network messages: ', t1), '', '', '');									DrawDialog(waitDilg);								until (noEnd);							until (place >= total);						end;						HPurge(handle(GenericImport));						DisposHandle(handle(GenericImport));					end;					result := FSClose(tabRef);					result := Rename(concat(tabbyPath, 'Generic Import'), 0, concat(tabbyPath, 'Old GenImport'));					NumToString(mImported, t1);					LogThis(concat('Imported ', t1, ' network messages.'), 6);					inForum := 1;					inSub := 1;					doSystRec(true);					DisposDialog(waitDilg);				end;			end;			for i := 1 to intSystRec.numNodes do			begin				if theNodes[i]^.goOffInlocal then				begin					curGlobs := theNodes[i];					activeNode := i;					TellModem('ATH0');				end;			end;			activeNode := 1;			curGlobs := thenodes[1];		end;	end;end.