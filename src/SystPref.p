unit SystemPrefs;interface	uses		AppleTalk, ADSP, Serial, Types, AppleTalk, SANE, sound, Initial, nodePrefs, CTBUtilities;	procedure OpenSystemConfig (whichExternal: integer);	procedure CloseSystemConfig;	procedure DoGFileRec (Save: boolean);	procedure CallSysopExternal (message, item: integer; var theEvent: eventRecord);	procedure ClickSystemConfig (theEvent: EventRecord; itemHit: integer);	procedure UpdateSysConfig (event: eventRecord);	procedure DLratioStr (var loadStr: str255; whichNode: integer);	function mySDGetBuf (var returned: longint): OSerr;	procedure DoSystRec (Save: boolean);	function inDownTime: boolean;	function PrepModem: boolean;	function TickToTime (whichTicks: longint): str255;	function ticksLeft (whichNode: integer): longint;	function NextDownTicks: longint;	function AsyncMWrite (myRefNum: integer; lengWrite: longint; WhatWrite: ptr): OSerr;	function mySyncRead (modemRef: integer; lengWrite: longint; myBufPtr: ptr): OSerr;	procedure Flowie (YesFlow: boolean);	procedure NumToBaud (num: integer; var tempint: longint);	procedure DoBaudReset (baudWanted: longint);	procedure OpenAboutBox;	procedure CloseAboutBox;	procedure FlashyAboutBox;	procedure StartMySound (soundName: str255; async: boolean);	function FExist (FNmPth: str255): boolean;	function FreeK (pathOn: str255): longint;	procedure GoodRatioStr (var loadStr: str255);	procedure TerminateRun;	procedure OpenCapture;	procedure CloseCapture;	procedure ClearInBuf;	procedure TellModem (what: str255);	procedure WhatDay (myDate: DateTimeRec; var myDayString: str255);	procedure Write2Zlog;	procedure RestrictString (var THEUSER: USERREC; var te1: str255);	function IsUsingColor: boolean;	function SexToTime (whichTicks: longint): str255;	function InTrash (trashedName: str255): boolean;	procedure MakeExtList;	procedure OpenStatWindow;	procedure CloseStatWindow;	procedure UpdateStatWindow;	function GetStatLine: str255;	procedure DoDialDialog;	procedure DoTextSearch (textWindNum: integer);	procedure mySearchTE (textWindNum: integer; startAtEndSel: boolean);implementation	procedure SetFontVars;	external;	procedure OpenANSIWindow (num: integer);	external;	procedure CloseANSIWindow (num: integer);	external;	procedure mySearchTE (textWindNum: integer; startAtEndSel: boolean);		label			100;		var			sLen: integer;			tend: longint;			cmp: str255;			myT: CharsHandle;			c1, c2: char;	begin		sLen := length(textSearch);		myT := charshandle(textWinds[textWindNum].t^^.hText);		if startAtEndSel then			i := textWinds[textWindNum].t^^.selEnd + 1		else			i := 0;		tend := GetHandleSize(handle(myT));		cmp[0] := char(sLen);100:		c1 := textSearch[1];		if ((c1 >= 'a') and (c1 <= 'z')) then			c1 := char(byte(c1) - (byte('a') - byte('A')));		repeat			c2 := myT^^[i];			if ((c2 >= 'a') and (c2 <= 'z')) then				c2 := char(byte(c2) - (byte('a') - byte('A')));			i := i + 1;		until (c2 = c1) or (i >= tend);		if (i < tend) then		begin			i := i - 1;			BlockMove(@myT^^[i], @cmp[1], sLen);			if (EqualString(textSearch, cmp, false, false)) then			begin				TESetSelect(i, i + sLen, textWinds[textWindNum].t);				TESelView(textWinds[textWindNum].t);				AdjustScrollbars(textWindNum, false);			end			else			begin				i := i + 1;				goto 100;			end;		end		else			SysBeep(10);	end;	procedure DoTextSearch (textWindNum: integer);		var			searchDilg: DialogPtr;			i, kind, sLen: integer;			tend: longint;			h: handle;			r: rect;			cmp: str255;			myT: CharsHandle;	begin		searchDilg := GetNewDialog(3468, nil, pointer(-1));		SetPort(searchDilg);		if textSearch <> '' then		begin			GetDItem(searchDilg, 4, kind, h, r);			SetIText(h, textSearch);		end;		TESetSelect(0, 32767, DialogPeek(searchDilg)^.textH);		ShowWindow(searchDilg);		GetDItem(searchDilg, 1, kind, h, r);		InsetRect(r, -4, -4);		PenSize(3, 3);		FrameRoundRect(r, 16, 16);		repeat			ModalDialog(nil, i);		until (i = 1) or (i = 2);		if (i = 1) then		begin			GetDItem(searchDilg, 4, kind, h, r);			GetIText(h, textSearch);			if length(textSearch) > 0 then				mySearchTE(textWindNum, false);		end;		DisposDialog(searchDilg);	end;	procedure EndMySound;	begin		if myChannel <> nil then		begin			result := SndDisposeChannel(myChannel, true);			DisposPtr(ptr(myChannel));			myChannel := nil;			if mySound <> nil then				HPurge(mySound);			mySound := nil;		end;	end;{$D-}	procedure mySndCallBack (theChan: SndChannelPtr; theCmd: SndCommand);		var			myA5: longint;	begin		if theCmd.param1 = 1 then		begin			myA5 := SetA5(theCmd.param2);			gSndCalledBack := true;			myA5 := SetA5(myA5);		end;	end;{$D+}	procedure StartMySound (soundName: str255; async: boolean);		var			mySndCmd: SndCommand;	begin		myChannel := SndChannelPtr(NewPtrClear(SizeOf(SndChannel)));		myChannel^.qLength := stdQLength;		mySound := GetNamedResource('snd ', soundName);		if (mySound <> nil) then		begin			if SndNewChannel(myChannel, 0, initMono, nil) <> noErr then			begin				ReleaseResource(mySound);				mySound := nil;				DisposPtr(ptr(myChannel));				myChannel := nil;			end			else			begin				gSndCalledBack := false;				if async then					myChannel^.callBack := @mySndCallBack;				result := SndPlay(myChannel, mySound, async);				if async then				begin					mySndCmd.cmd := callBackCmd;					mySndCmd.param1 := 1;					mySndCmd.param2 := SetCurrentA5;					result := SndDoCommand(myChannel, mySndCmd, TRUE);				end				else					EndMySound;			end;		end;	end;	procedure DoDialDialog;		var			dialDialog: DialogPtr;			i, a: integer;			kind: integer;			h: handle;			r: rect;			ts: str255;	begin		with curGlobs^ do		begin			dialDialog := GetNewDialog(2111, nil, pointer(-1));			UseResFile(RShared);			theDials := DialerHand(GetResource('BBsy', 256));			if theDials = nil then			begin				theDials := DialerHand(NewHandle(SizeOf(DialerRec)));				AddResource(handle(theDials), 'BBsy', 256, 'Dialer Info');				for i := 0 to 9 do				begin					theDials^^.numbers[i] := '';					theDials^^.dialIt[i] := false;				end;			end;			UseResFile(myResourceFile);			HNoPurge(handle(theDials));			for i := 2 to 11 do			begin				GetDItem(dialDialog, i, kind, h, r);				SetIText(h, theDials^^.numbers[i - 2]);			end;			for i := 12 to 21 do			begin				GetDItem(dialDialog, i, kind, h, r);				if theDials^^.dialIt[i - 12] then					SetCtlValue(controlHandle(h), 1)				else					SetCtlValue(controlHandle(h), 0);			end;			for i := 0 to 9 do				theDials^^.dialed[i] := false;			ShowWIndow(dialDialog);			repeat				ModalDialog(nil, a);				if (a >= 12) and (a <= 21) then				begin					GetDItem(dialDialog, a, kind, h, r);					SetCtlValue(controlHandle(h), (GetCtlValue(controlHandle(h)) + 1) mod 2);				end;			until (a = 1) or (a = 22);			if a = 1 then			begin				for i := 0 to 9 do				begin					GetDItem(dialDialog, i + 2, kind, h, r);					GetIText(h, ts);					theDials^^.numbers[i] := ts;					GetDItem(dialDialog, i + 12, kind, h, r);					if GetCtlValue(controlHandle(h)) = 1 then						theDials^^.dialIt[i] := true					else						theDials^^.dialIt[i] := false;				end;				dialing := true;			end			else				dialing := false;			DisposDialog(dialDialog);		end;	end;	procedure OpenStatWindow;		var			defRect, tRect, t2: rect;	begin		if statWindow = nil then		begin			SetRect(defRect, 5, screenBits.bounds.bottom - 55, 505, screenBits.bounds.bottom - 5);			SetRect(t2, 0, 0, 0, 0);			tRect := thewindPos^^.wStatus;			if (EqualRect(tRect, t2)) or not SectRect(tRect, screenBits.bounds, t2) then				tRect := defRect;			theWindPos^^.wIsOpen[0] := true;			statWindow := NewWindow(nil, tRect, 'Status', true, 0, pointer(-1), true, 0);		end		else			SelectWindow(statwindow);	end;	procedure CloseStatWindow;		var			i: integer;	begin		if statWindow <> nil then		begin			SetPort(statWindow);			theWindPos^^.wStatus := statWindow^.portRect;			if quit = 0 then				theWindPos^^.wIsOpen[0] := false;			LocalToGlobal(theWindPos^^.wStatus.topLeft);			LocalToGlobal(theWindPos^^.wStatus.botRight);			DisposeWindow(statWindow);			statWindow := nil;		end;	end;	function InTrash (trashedName: str255): boolean;		var			trashRef, i, lastI: integer;			lengTrash: longint;			trashStuff: CharsHandle;			checkStr: str255;	begin		inTrash := false;		UprString(trashedName, true);		result := FSOpen(concat(sharedPath, 'Trash Users'), 0, trashRef);		if result = noErr then		begin			result := GetEOF(trashRef, lengTrash);			if lengTrash > 0 then			begin				trashStuff := CharsHandle(NewHandle(lengTrash));				if memError = noErr then				begin					result := FSRead(trashref, lengTrash, pointer(trashStuff^));					i := 0;					lastI := 0;					while (i <= lengTrash) do					begin						if (trashStuff^^[i] = char(13)) then						begin							checkStr[0] := char(i - lastI);							BlockMove(pointer(ord4(@trashStuff^^[lastI])), pointer(ord4(@checkStr[1])), i - lastI);							if pos(checkStr, trashedName) > 0 then								inTrash := true;							lastI := i + 1;						end;						i := i + 1;					end;					DisposHandle(handle(trashStuff));				end;			end;			result := FSClose(trashRef);		end;	end;	function mySyncRead (modemRef: integer; lengWrite: longint; myBufPtr: ptr): OSerr;		var			myParamB: ParamBlockRec;	begin		myParamB.ioCompletion := nil;		myParamB.ioRefNum := modemRef;		myParamB.ioBuffer := StripAddress(myBufPtr);		myParamB.ioReqCount := lengWrite;		myParamB.ioPosMode := fsAtMark;		myParamB.ioPosOffset := 0;		mySyncRead := PBRead(parmBlkPtr(StripAddress(@myParamB)), false);	end;	function IsUsingColor: boolean;		var			tempGD: GDHandle;	begin		isUsingColor := false;		if gMac.hasColorQD then		begin			if TestDeviceAttribute(getMainDevice, gdDevType) then			begin				tempGD := GetMaxDevice(screenBits.bounds);				if tempGD^^.gdPMap^^.pixelSize > 1 then					isUsingColor := true;			end;		end;	end;	function mySDGetBuf (var returned: longint): OSerr;		var			i: integer;			t1: longint;			myParmBlk: ParamBlockRec;	begin		with myParmBlk do		begin			ioCompletion := nil;			ioVRefNum := 0;			ioRefNum := curglobs^.inputRef;			csCode := 2;			for i := 1 to 10 do				csParam[i] := 0;		end;		result := PBStatus(parmBlkPtr(StripAddress(@myParmBlk)), false);		BlockMove(@myParmBlk.csParam, @t1, 4);		returned := t1;	end;	function FExist (FNmPth: str255): boolean;		var			result: OSerr;			tempRef: integer;			myHParmer: HParamBlockRec;			myParmer: ParamBlockRec;	begin		with myHParmer do		begin			ioCompletion := nil;			ioNamePtr := @FNmPth;			ioVRefNum := 0;			ioDirID := 0;			ioFDirIndex := -1;		end;		result := PBHGetFInfo(@myHParmer, false);		if result = noErr then			FExist := true		else			FExist := false;	end;	function AsyncMWrite (myRefNum: integer; lengWrite: longint; whatWrite: ptr): OSerr;		var			myTems: longint;			IHatePascal: boolean;	begin		with curglobs^ do		begin			result := noErr;			if lengWrite > 0 then			begin				if toBeSent = nil then				begin					toBeSent := NewHandle(lengWrite);					HNoPurge(handle(toBesent));					BlockMove(whatWrite, pointer(toBeSent^), lengWrite);				end				else				begin					myTems := GetHandleSize(toBeSent);					SetHandleSize(toBeSent, myTems + lengWrite);					BlockMove(whatWrite, pointer(ord4(toBeSent^) + myTems), lengWrite);				end;			end;			if (toBeSent <> nil) then			begin				IHatePascal := false;				if (nodeType = 2) then					if (nodeDSPWritePtr^.ioResult <> 1) then						IHatePascal := true;				if ((myBlocker.ioResult <> 1) and (nodeType = 1)) or IHatePascal then				begin					myTems := GetHandleSize(toBeSent);					if myTems > SENDNOWBUFSIZE then					begin						myTems := SENDNOWBUFSIZE;						BlockMove(pointer(toBeSent^), sendingNow, myTems);						BlockMove(pointer(ord4(toBeSent^) + longInt(SENDNOWBUFSIZE)), pointer(toBeSent^), GetHandleSize(toBeSent) - SENDNOWBUFSIZE);						SetHandleSize(toBeSent, GetHandleSize(toBeSent) - SENDNOWBUFSIZE);					end					else					begin						BlockMove(pointer(toBeSent^), sendingNow, myTems);						DisposHandle(toBeSent);						toBeSent := nil;					end;					if (nodeType = 1) then					begin						with myBlocker do						begin							ioCompletion := nil;							ioRefNum := myRefNum;							ioBuffer := sendingNow;							ioReqCount := myTems;						end;						result := PBWrite(parmBlkPtr(stripAddress(@myBlocker)), true);					end					else					begin						with nodeDSPWritePtr^ do						begin							csCode := dspWrite;							ioCompletion := nil;							ioCRefNum := dspDrvrRefNum;							ccbRefNum := nodeCCBRefNum;							reqCount := myTems;							dataPtr := sendingNow;							eom := 0;							flush := 1;						end;						result := PBControl(ParmBlkPtr(nodeDSPWritePtr), true);					end;				end;			end;			AsyncMWrite := result;		end;	end;	procedure RestrictString (var theUser: UserRec; var te1: str255);		var			i: integer;	begin		te1 := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';		for I := 1 to 26 do			if not theUser.restrics[i] then				te1[i] := ' ';	end;	procedure ErrorRep (identity: str255; theResult: OSerr);		var			t1: str255;	begin		if theResult <> noErr then		begin			NumToString(theResult, t1);			t1 := concat('Error: ', identity, ' (', t1, ')');			ProblemRep(t1);		end;	end;	procedure TerminateRun;		var			bbc: oserr;			tempFileName: str255;			tempLong, count: longInt;			SharedRef: integer;			InitSystHand: SystHand;	begin		with curglobs^ do		begin			if capturing then				closeCapture;			capturing := false;			CloseComPort;			if intMessStuff <> nil then			begin				HPurge(handle(intMessStuff));				DisposHandle(handle(intMessStuff));				intMessStuff := nil;			end;			if intGFileHand <> nil then			begin				HPurge(handle(intGFileHand));				DisposHandle(handle(intGFileHand));				intGFileHand := nil;			end;			if curOpenDir <> nil then			begin				HPurge(handle(curOpenDir));				DisposHandle(handle(curOpenDir));				curopenDir := nil;			end;		end;	end;	procedure RestartSound;	begin		if gSndCalledback then		begin			EndMySound;			StartMySound('Bart!!', true);		end;	end;	procedure SlideTextIn (theText: str255; vert, size: integer; useColor: boolean);		var			isOdd: boolean;			scrPos: array[1..80] of integer;			rightChar, leftChar, baseCPos, i, whichPair, numPairs, curRH, curLH: integer;	begin		TextSize(size);		baseCPos := screenBits.bounds.right div 2 - (StringWidth(theText) div 2);		i := 1;		scrPos[i] := baseCPos;		while (i < length(theText)) do		begin			i := i + 1;			scrPos[i] := scrPos[i - 1] + CharWidth(thetext[i - 1]);		end;		if (length(theText) mod 2) > 0 then			isOdd := true		else			isOdd := false;		if isOdd then		begin			curRH := screenBits.bounds.right;			rightChar := length(theText) div 2 + 1;			repeat				if curRH > scrPos[rightChar] then				begin					ForeColor(blackColor);					MoveTo(curRH, vert);					DrawChar(theText[rightChar]);					curRH := curRH - 25;					if curRH < scrPos[rightChar] then						curRH := scrPos[rightChar];					if useColor then						ForeColor(yellowColor)					else						ForeColor(whiteColor);					MoveTo(curRH, vert);					DrawChar(theText[rightChar]);				end;			until (curRH = scrPos[rightChar]);			for i := (rightChar + 1) to length(theText) do				scrPos[i - 1] := scrPos[i];			delete(theText, rightChar, 1);		end;		numPairs := length(theText) div 2;		whichPair := 1;		repeat			rightChar := length(theText) div 2 + 1;			leftChar := length(theText) div 2;			rightChar := rightChar + whichPair - 1;			leftChar := leftChar - whichPair + 1;			curRH := screenBits.bounds.right;			curLH := 0;			repeat				if curRH > scrPos[rightChar] then				begin					ForeColor(blackColor);					MoveTo(curRH, vert);					DrawChar(theText[rightChar]);					if size < 18 then						curRH := curRH - 40					else						curRH := curRH - 25;					if curRH < scrPos[rightChar] then						curRH := scrPos[rightChar];					if useColor then						ForeColor(yellowColor)					else						ForeColor(whiteColor);					MoveTo(curRH, vert);					DrawChar(theText[rightChar]);				end;				if curLH < scrPos[leftChar] then				begin					ForeColor(blackColor);					MoveTo(curLH, vert);					DrawChar(theText[leftChar]);					if size < 18 then						curLH := curLH + 40					else						curLH := curLH + 25;					if curLH > scrPos[leftChar] then						curLH := scrPos[leftChar];					if useColor then						ForeColor(yellowColor)					else						ForeColor(whiteColor);					MoveTo(curLH, vert);					DrawChar(theText[leftChar]);				end;{RestartSound;}			until (curRH = scrPos[rightChar]) and (curLH = scrPos[leftChar]);			whichPair := whichPair + 1;		until (whichPair > numPairs);	end;	procedure FlashyAboutBox;		var			myFree, mySN: str255;			myGRWindow: windowPtr;			savePort: GrafPtr;			i, b: integer;			q: longint;			useColor: boolean;	begin		GetPort(savePort);		myGRwindow := NewWindow(nil, screenBits.bounds, '', true, 2, pointer(-1), false, 0);		SetPort(myGRwindow);		useColor := isUsingColor;		if useColor then			ForeColor(yellowColor)		else			ForeColor(whiteColor);		BackColor(blackColor);		EraseRect(myGRwindow^.portRect);		TextFont(Times);		TextMode(srcOr);		b := 0;{    StartMySound('Bart!!', true);}		SlideTextIn('Hermes', 100, 36, useColor);		SlideTextIn('Bulletin Board System', 126, 24, useColor);		SlideTextIn(concat('Version ', HERMES_VERSION), 152, 18, useColor);		SlideTextIn('©1989-1992 AOC Software, Inc.', 172, 18, useColor);		SlideTextIn('by Frank Price', 192, 18, useColor);		SlideTextIn('To register, send $75.00(US) to:', 224, 12, useColor);		SlideTextIn('AOC Software, Inc.', 238, 12, useColor);		SlideTextIn('P.O. Box 1235', 252, 12, useColor);		SlideTextIn('Beverly Hills, CA  90213', 266, 12, useColor);		SlideTextIn('Questions?  Call the support BBS at (310)275-6975.', 290, 12, useColor);		SlideTextIn('Online credit card registration available.', 304, 12, useColor);		SlideTextIn('Thanks to John Raymonds and Mark Weaver', 318, 12, useColor);		NumToString(FreeMem, myFree);		if length(intSystRec.realSerial) > 0 then			mySN := copy(intSystRec.realSerial, 1, 8)		else		begin			mySN := 'Unregistered';			SlideTextIn('This program will not function after 30 days unless registered.', 210, 12, useColor);		end;		SlideTextIn(concat('Free memory: ', myFree, '      Serial #', mySN), 336, 12, useColor);		repeat		until button;		DisposeWindow(myGRwindow);{    EndMySound;}		SetPort(savePort);	end;	procedure OpenAboutBox;		var			freeMemStr: str255;			tempEv: eventRecord;			i: integer;			tl: longint;	begin		if AboutDilg = nil then		begin			AboutDilg := GetNewDialog(1539, nil, pointer(-1));			MoveWindow(AboutDilg, (screenbits.bounds.right - (AboutDilg^.portRect.right - AboutDilg^.portRect.left)) div 2, 25, true);			ShowWindow(aboutDilg);			SelectWindow(aboutDilg);			for i := 1 to 2 do			begin				if GetNextEvent(activateEvt + UpdateEvt, tempEv) then					;			end;			DrawDialog(aboutDilg);			SetPort(aboutDilg);			TextFont(times);			TextSize(10);			tl := MaxMem(tl);			NumToString(FreeMem, freeMemStr);			MoveTo(115, 93);			DrawString(HERMES_VERSION);			MoveTo(115, 105);			DrawString(freeMemStr);		end;	end;	procedure CloseAboutBox;	begin		if AboutDilg <> nil then		begin			DisposDialog(ABoutDilg);			AboutDilg := nil;			FlushEvents(mouseDown + mouseUp, 0);		end;	end;	procedure TellModem (what: str255);		var			count: longInt;	begin		if curglobs^.nodeType = 1 then		begin			count := length(what) + 1;			what := concat(what, char(13));			result := AsyncMWrite(curglobs^.outputRef, count, ptr(ord4(@what) + 1));			Delay(60, count);			result := mySDGetBuf(count);			while count > 0 do			begin				if count > 255 then				begin					result := mySyncRead(curglobs^.inputRef, 255, ptr(ord4(@what) + 1));					count := count - 255;				end				else				begin					result := mySyncRead(curglobs^.inputRef, count, ptr(ord4(@what) + 1));					count := 0;				end;			end;		end;	end;	procedure clearInBuf;		var			result: OSerr;	begin		with curGlobs^ do		begin			if nodeType = 1 then			begin				result := Control(inputRef, 23, nil);				result := Control(inputRef, 22, nil);				result := KillIO(inputRef);				result := KillIO(outputRef);				typeBuffer := '';				if toBeSent <> nil then				begin					HPurge(handle(toBeSent));					DisposHandle(toBeSent);				end;				toBeSent := nil;			end			else if (nodeType = 2) then			begin			end;		end;	end;	procedure OpenCapture;		var			tems: str255;			tI: integer;			result: OSerr;			capRep: SFReply;			tp: point;	begin		with curglobs^ do		begin			capturing := false;			SetPt(tp, 50, 50);			SFPutFile(tp, 'Save captured text as:', 'Capture', nil, capRep);			if capRep.good then			begin				result := Create(caprep.fName, capRep.vRefNum, 'HRMS', 'TEXT');				result := FSOpen(capRep.fName, capRep.vRefNum, captureRef);				if result = noErr then				begin					result := SetFPos(captureRef, fsFromStart, 0);					capturing := true;				end				else					SysBeep(10);			end;		end;	end;	procedure CloseCapture;	begin		with curglobs^ do		begin			result := FSClose(captureref);			capturing := false;			if visibleNode = activeNode then				CheckItem(getMHandle(mFile), 8, false);		end;	end;	procedure NumToBaud (num: integer; var tempint: longint);	begin		case num of			1: 				tempint := 50;			2: 				tempint := 75;			3: 				tempint := 110;			4: 				tempint := 150;			5: 				tempint := 200;			6: 				tempint := 300;			7: 				tempint := 450;			8: 				tempint := 600;			9: 				tempint := 1200;			10: 				tempint := 1800;			11: 				tempint := 2000;			12: 				tempint := 2400;			13: 				tempint := 3600;			14: 				tempint := 4800;			15: 				tempint := 7200;			16: 				tempint := 9600;			17: 				tempint := 19200;			18: 				tempint := 38400;			19: 				tempint := 57600;			otherwise		end;	end;	procedure DoBaudReset (baudWanted: longint);		var			tempInt: integer;			tl: longint;			myPB: paramBlockRec;	begin		if baudWanted < 20 then		begin			NumToBaud(baudWanted, tl);			baudWanted := tl;		end;		tempInt := baudWanted;		if baudWanted = 38400 then			tempInt := $9600		else if baudWanted = 57600 then			tempInt := $E100;		with myPB do		begin			csCode := 13;			ioCompletion := nil;			ioVRefNum := 0;			ioRefNum := curglobs^.inputRef;		end;		BlockMove(@tempint, @myPB.csParam, 2);		result := PBControl(@myPB, false);	end;	procedure WhatDay;	begin		case myDate.dayOfWeek of			1: 				myDayString := 'Sun, ';			2: 				myDayString := 'Mon, ';			3: 				myDayString := 'Tue, ';			4: 				myDayString := 'Wed, ';			5: 				myDayString := 'Thu, ';			6: 				myDayString := 'Fri, ';			7: 				myDayString := 'Sat, ';			otherwise		end;	end;	procedure Write2ZLog;		var			tempString, tempString2, ts3, ts4, ts5: str255;			result: OSerr;			count, count2: longint;			ZLogRef, i: integer;			bisho: handle;			tempReal, tr2: real;			myDate: DateTimeRec;	begin		tempString2 := concat('  Date    Day  Calls  Active  EMail  Posts  Uplds  %Act  T/User', char(13), '--------  ---  -----  ------  -----  -----  -----  ----  ------', char(13));		count := length(tempString2);		tempString := concat(sharedpath, 'Usage Record');		result := FSOpen(tempString, 0, ZlogRef);		if result <> noErr then		begin			result := FSDelete(tempString, 0);			result := Create(tempString, 0, 'HRMS', 'TEXT');			result := FSOpen(tempString, 0, ZLogRef);			result := SetEOF(ZLogRef, count);			result := SetFPos(ZLogRef, fsFromStart, 0);			count2 := count;			result := FSWrite(ZLogRef, count2, @tempString2[1]);		end;		result := GetEOF(ZLogRef, count2);		NumToString(intSystRec.lastmaint.month, tempString);		if length(tempString) = 1 then			tempString := concat('0', tempString);		NumToString(intSystRec.lastMaint.day, tempString2);		if length(tempString2) = 1 then			tempString2 := concat('0', tempString2);		tempString := concat(tempString, '/', tempString2);		NumToString(intSystRec.lastMaint.year, tempString2);		tempString2[1] := tempString2[3];		tempString2[2] := tempString2[4];		tempString2[0] := char(2);		tempString := concat(tempString, '/', tempString2, '  ');		whatDay(intSystRec.lastmaint, tempString2);		tempString2[0] := char(3);		tempString := concat(tempString, tempString2, '  ');		NumToString(intSystRec.callsToday, tempString2);		for i := (length(tempString2) + 1) to 5 do			tempString2 := concat(tempString2, ' ');		tempString := concat(tempString, tempString2, '  ');		NumToString(intSystRec.minsToday, tempString2);		for i := (length(tempString2) + 1) to 6 do			tempString2 := concat(tempString2, ' ');		tempString := concat(tempString, tempString2, '  ');		NumToString(intSystRec.eMailToday, tempString2);		for i := (length(tempString2) + 1) to 5 do			tempString2 := concat(tempString2, ' ');		tempString := concat(tempString, tempString2, '  ');		NumToString(intSystRec.mPostedToday, tempString2);		for i := (length(tempString2) + 1) to 5 do			tempString2 := concat(tempString2, ' ');		tempString := concat(tempString, tempString2, '  ');		NumToString(intSystRec.uploadsToday, tempString2);		for i := (length(tempString2) + 1) to 5 do			tempString2 := concat(tempString2, ' ');		tempString := concat(tempString, tempString2, '  ');		if intSystRec.minsToday > 14 then			tempReal := ((intSystRec.minsToday / 1440) * 100)		else			tempReal := 0;		i := trunc(tempReal);		NumToString(i, tempString2);		tempString2 := concat(tempString2, '%');		for i := (length(tempString2) + 1) to 4 do			tempString2 := concat(tempString2, ' ');		tempString := concat(tempString, tempString2, '  ');		if intSystRec.callsToday > 0 then			i := intSystRec.minsToday div intSystRec.callsToday		else			i := 0;		NumToString(i, tempString2);		tempString := concat(tempString, tempString2, char(13));		if count2 > count then		begin			result := SetFPos(ZLogRef, fsFromStart, count);			count2 := count2 - count;			bisho := newHandle(count2);			result := FSRead(ZLogRef, count2, pointer(bisho^));			result := SetEOF(ZlogRef, count + count2 + length(tempString));			result := SetFPos(Zlogref, fsFromStart, count + length(tempString));			result := FSWrite(ZLogRef, count2, pointer(bisho^));			DisposHandle(bisho);		end		else			result := SetEOF(ZlogRef, count + length(tempString));		result := SetFPos(Zlogref, fsFromStart, count);		count := length(tempString);		result := FSWrite(ZLogref, count, @tempString[1]);		result := GetEOF(ZLogRef, count2);		count := 10000;		if count2 > count then			result := SetEOF(ZLogRef, count);		result := FSClose(ZlogRef);	end;	function FreeK (pathOn: str255): longint;		var			tempString: str255;			tempLong: longint;			myHParmer: HParmBlkPtr;			result: OSerr;	begin		tempString := pathOn;		myHParmer := HParmBlkPtr(NewPtr(SizeOf(HParamBlockRec)));		myHParmer^.ioCompletion := nil;		myHParmer^.ioNamePtr := @tempString;		myHParmer^.ioVRefNum := 0;		myHParmer^.ioVolIndex := -1;		result := PBHGetVInfo(myHParmer, false);		if result = noErr then		begin			tempLong := longInt(myHParmer^.ioVAlBlkSiz) * longInt(BAnd(myHParmer^.ioVFrBlk, $0000FFFF));			FreeK := tempLong;		end		else			FreeK := 0;		DisposPtr(pointer(myHParmer));	end;	procedure DLRatioStr;		var			myR: real;			f: DecForm;			s: DecStr;			tempString2: str255;	begin		with theNodes[whichNode]^ do		begin			if (thisUser.DownloadedK <> 0) then			begin				myR := thisUser.uploadedK / thisUser.downloadedK;				F.style := FixedDecimal;				F.digits := 3;				if myR > 99.998 then					myR := 99.999;				Num2Str(f, myR, s);				tempString2 := s;			end			else			begin				if thisUser.uploadedK > 0 then					tempString2 := '99.999'				else					tempString2 := '0.000';			end;			loadStr := tempString2;		end;	end;	procedure GoodRatioStr (var loadStr: str255);		var			myR: real;			f: DecForm;			s: DecStr;			tempString2: str255;	begin		myR := 1 / (intSystRec.secLevels[curglobs^.thisUser.SecLevel].DLRatioOneTo);		F.style := FixedDecimal;		F.digits := 3;		if myR > 99.998 then			myR := 99.999;		Num2Str(f, myR, s);		tempString2 := s;		loadStr := tempString2;	end;	function GetStatLine: str255;		var			t1, t2, t3, t4, t5, t6: str255;	begin		NumToString(intSystRec.callsToday, t1);		NumToString(intSystRec.minsToday, t2);		NumToString(intSystRec.mPostedToday, t3);		NumToString(intSystRec.uploadsToday, t4);		NumToString(FreeK(sharedpath) div 1024, t5);		NumToString(numFeedbacks, t6);		GetStatLine := concat('CT: ', t1, ' ¥ AT: ', t2, ' ¥ PT: ', t3, ' ¥ UT: ', t4, ' ¥ DF: ', t5, 'k', ' ¥ FB: ', t6, ' ¥ LU: ', lastCurUser);	end;	procedure UpdateStatWindow;		var			tsr, t1, t2, t3, t4, t5: str255;			i, curShow: integer;			myP: point;	begin		if statWindow <> nil then		begin			SetPort(statWindow);			ForeColor(blackColor);			BackColor(whiteColor);			EraseRect(statWindow^.portRect);			TextSize(9);			TextFont(geneva);			TextFace([]);			MoveTo(3, 10);			tsr := GetStatLine;			DrawString(tsr);			GetPen(myP);			myP.v := myP.v + 3;			if myP.v > 5 then			begin				myP.h := 0;				MoveTo(myP.h, myP.v);				myP.h := statWindow^.portRect.right;				LineTo(myP.h, myP.v);			end;			curShow := visibleNode;			repeat				with theNodes[curshow]^ do				begin					if (BoardMode = User) and (thisUser.userNum > 0) then					begin						GetPen(myP);						myP.v := myP.v + 11;						MoveTo(3, myP.v);						NumToString(thisUser.userNum, tsr);						NumToString(thisUser.onToday, t2);						NumToString(thisUser.secLevel, t1);						NumToString(thisUser.transferLevel, t3);						NumToString(thisUser.age, t4);						if thisUser.sex then							t4 := concat(t4, '/M')						else							t4 := concat(t4, '/F');						tsr := concat(thisUser.userName, ' #', tsr, ' ¥ ', thisUser.realname, ' (', t4, ') ¥ ', thisUser.phone, ' ¥ S:', t1, '/D:', t3, '  (', t2, ')');						DrawString(tsr);						if triedChat then						begin							GetPen(myP);							myP.h := myP.h + 12;							MoveTo(myP.h, myP.v);							ForeColor(redColor);							DrawString('CHAT');							ForeColor(blackColor);						end;						GetPen(myP);						myP.v := myP.v + 11;						MoveTo(3, myP.v);						t1 := '';						if (thisUser.restrics[3]) then						begin							DLRatioStr(t1, curShow);							t1 := concat('Ratio:', t1, '  ¥  ');						end;						t2 := '';						for i := 1 to 26 do							if thisUser.restrics[i] then								t2 := concat(t2, char(64 + i));						if length(t2) = 0 then							t2 := 'None';						t3 := 'XXXXXXXXXX';						for i := 1 to 10 do							if not thisUser.msgFrmAccess[i] then								t3[i] := '-';						if currentBaud = 0 then							t4 := 'KB'						else							t4 := curBaudNote;						NumToString(ticksLeft(curShow) div longint(60) div longint(60), tsr);						if (boardSection <> Logon) and (boardSection <> NewUser) then							DrawString(concat(t1, 'RX:', t2, ' ¥ FR:', t3, ' ¥ ', t4, ' ¥ TL:', tsr))						else							DrawString(concat(t1, 'RX:', t2, ' ¥ FR:', t3, ' ¥ ', t4));						GetPen(myP);						myP.v := myP.v + 3;						if myP.v > 5 then						begin							myP.h := 0;							MoveTo(myP.h, myP.v);							myP.h := statWindow^.portRect.right;							LineTo(myP.h, myP.v);						end;					end					else if (BoardMode = Terminal) then					begin						GetPen(myP);						myP.v := myP.v + 11;						MoveTo(3, myP.v);						NumToString(currentBaud, tsr);						TSR := concat(tsr, '-N-8-1');						if inhalfDuplex then							TSR := concat(tsr, '-HALF')						else							TSR := concat(tsr, '-FULL');						if ansiTerm then							TSR := concat(tsr, '-ANSI')						else							TSR := concat(tsr, '-TTY');						DrawString(tsr);						GetPen(myP);						myP.v := myP.v + 3;						if myP.v > 5 then						begin							myP.h := 0;							MoveTo(myP.h, myP.v);							myP.h := statWindow^.portRect.right;							LineTo(myP.h, myP.v);						end;					end;				end;				if curShow = visibleNode then				begin					if visibleNode <> 1 then						curShow := 1					else						curShow := 2;				end				else if curShow + 1 <> visibleNode then					curShow := curShow + 1				else					curShow := curShow + 2;			until curShow > intSystRec.numNodes;		end;	end;	function SexToTime (whichTicks: longint): str255;		var			ts, ts2, ts3: str255;			l1, l2, l3: longint;	begin		l1 := whichTicks;{seconds}		l2 := l1 div 60;{minutes}		l1 := l1 - (l2 * 60);		l3 := l2 div 60;  {hours}		l2 := l2 - (l3 * 60);		NumToString(l1, ts);		NumToString(l2, ts2);		NumToString(l3, ts3);		if length(ts) < 2 then			ts := concat('0', ts);		if length(ts2) < 2 then			ts2 := concat('0', ts2);		if length(ts3) < 2 then			ts3 := concat('0', ts3);		SexToTime := concat(ts3, ':', ts2, ':', ts);	end;	function TickToTime (whichTicks: longint): str255;		var			ts, ts2, ts3: str255;			l1, l2, l3: longint;	begin		l1 := whichTicks div 60;{seconds}		l2 := l1 div 60;{minutes}		l1 := l1 - (l2 * 60);		l3 := l2 div 60;  {hours}		l2 := l2 - (l3 * 60);		NumToString(l1, ts);		NumToString(l2, ts2);		NumToString(l3, ts3);		if length(ts) < 2 then			ts := concat('0', ts);		if length(ts2) < 2 then			ts2 := concat('0', ts2);		if length(ts3) < 2 then			ts3 := concat('0', ts3);		tickToTime := concat(ts3, ':', ts2, ':', ts);	end;	function NextDownTicks: longint;		var			tempdate, tempdate2, tempdate3: dateTimerec;			timeNow: longint;			tempLong, templong2, nextTabby, tempresult: longint;	begin		with curglobs^ do		begin			if IntSystRec.tabbyNet then			begin				if dailyTabbyTime = 0 then					nextTabby := -1				else				begin					GetDateTime(templong);					nextTabby := (dailyTabbyTime - templong) * 60;				end;			end;			GetTime(tempdate3);			Secs2Date(downTime, tempdate);			tempdate.year := tempdate3.year;			tempdate.month := tempdate3.month;			tempdate.day := tempdate3.day;			tempdate.dayofWeek := tempdate3.dayofweek;			Date2Secs(tempdate, downTime);			Secs2Date(UPTime, tempdate);			tempdate.year := tempdate3.year;			tempdate.month := tempdate3.month;			tempdate.day := tempdate3.day;			tempdate.dayofWeek := tempdate3.dayofweek;			Date2Secs(tempdate, UPTime);			if upTime <> downtime then			begin				GetDateTime(timeNow);				templong := downTime - timeNow;				if tempLong < 0 then				begin					templong := downtime;					templong := templong + 86400;					tempLong := templong - timeNow;					tempresult := templong * 60;				end				else					tempresult := templong * 60;			end			else				tempresult := -1;			if (nextTabby <> 0) and (IntSystRec.tabbyNet) then			begin				if (tempResult > nextTabby) or (tempResult = -1) then					tempresult := nextTabby;			end;			NextDownTicks := tempresult;		end;	end;	function inDownTime: boolean;		var			TEMPDATE3, tempdate: dateTimerec;			templong: longint;	begin		with curglobs^ do		begin			GetTime(tempdate3);			Secs2Date(downTime, tempdate);			tempdate.year := tempdate3.year;			tempdate.month := tempdate3.month;			tempdate.day := tempdate3.day;			tempdate.dayofWeek := tempdate3.dayofweek;			Date2Secs(tempdate, downTime);			Secs2Date(UPTime, tempdate);			tempdate.year := tempdate3.year;			tempdate.month := tempdate3.month;			tempdate.day := tempdate3.day;			tempdate.dayofWeek := tempdate3.dayofweek;			Date2Secs(tempdate, UPTime);			GetDateTime(templong);			if upTime <> downtime then			begin				if (templong < uptime) and (templong > downtime) then					indowntime := true				else if (templong < upTime) and (templong < downtime) and not (UPTIME > downtime) then					inDownTime := true				else if (uptime < downtime) then				begin					uptime := uptime + 86400;					if (templong < uptime) and (templong > downtime) then						indowntime := true					else						inDowntime := false;				end				else					inDowntime := false;			end			else				indowntime := false;		end;	end;	function ticksLeft (whichNode: integer): longint;		var			l1, l2, templong: longint;	begin		with theNodes[whichNode]^ do		begin			if intSystRec.secLevels[thisUser.secLevel].useDayorCall then				l1 := (longint(intSystRec.secLevels[thisUser.secLevel].timeAllowed - thisUser.minOnToday)) * 60 * 60			else				l1 := (longint(intSystRec.secLevels[thisUser.secLevel].timeAllowed) * 60 * 60);			l1 := l1 + extratime;			l2 := tickCount - timebegin;			templong := l1 - l2;			if (templong > nextDownticks) and (nextDownTicks > 0) then			begin				templong := nextdownticks;				countingdown := true;				lastleft := templong;			end;			if countingdown and (templong > lastleft) then				templong := -1;			ticksLeft := templong;		end;	end;	procedure Flowie (YesFlow: boolean);		var			handshake: SerShk;			myPB: ParamBlockRec;	begin		handshake.errs := 0;  {$70 was what it was}		handshake.evts := 0;   {$08 for DCD, 32 for CTS^^^^}		handshake.fInX := 0;		handshake.fXOn := 0;		handshake.fCTS := 0;		handshake.fDTR := 0;		if curglobs^.HWHH then		begin			handshake.fCTS := 1;			handshake.fDTR := 1;		end		else		begin			if yesFlow then			begin				handshake.fInX := 1;  {receive flow control}				handshake.fXOn := 1;			end			else			begin				handshake.fInX := 0;				handshake.fXOn := 0;			end;		end;		handshake.xOn := chr($11);		handshake.xOff := chr($13);		with myPB do		begin			csCode := 14;			iocompletion := nil;			ioVRefNum := 0;			ioRefNum := curglobs^.inputRef;		end;		BlockMove(@handshake, @myPB.csParam, SizeOf(SerShk));		result := PBControl(@myPB, false);	end;	function Get1ComPort: char;		var			strleng: longint;	begin		with curglobs^ do		begin			result := mySDGetBuf(strLeng);			if strLeng > 0 then			begin				strLeng := 1;				result := mySyncRead(inputRef, strLeng, StripAddress(pointer(@incoming)));				Get1ComPort := incoming[0];			end			else				Get1ComPort := char(0);		end;	end;	function ComPeriod: boolean;		var			KBNunc: keymap;			tempbool, tempbool2: boolean;	begin		GetKeys(KBnunc);		charnum := 47 div 8;		bitnum := 7 - (47 mod 8);		if (BitTst(@KBNunc, 8 * charnum + bitnum)) then			tempbool := true		else			tempbool := false;		charnum := 55 div 8;		bitnum := 7 - (55 mod 8);		if (BitTst(@KBNunc, 8 * charnum + bitnum)) then			tempbool2 := true		else			tempbool2 := false;		if tempBool and tempBool2 then			ComPeriod := true		else			comPeriod := false;	end;	function PrepModem: boolean;		var			q, l1, myTimer: longint;			done: boolean;			t1: str255;			gotCh: char;			i, b: integer;	begin		with curglobs^ do		begin			if nodeType = 1 then			begin				DoBaudReset(MaxBaud);				Flowie(true);				if HWHH then					t1 := modemDrivers^^[modemID].hwOn				else					t1 := modemDrivers^^[modemID].hwOff;				if matchInterface then					t1 := concat(t1, modemDrivers^^[modemID].lockOff)				else					t1 := concat(t1, modemDrivers^^[modemID].lockOn);				t1 := concat(modemDrivers^^[modemID].bbsInit, t1, char(13));				l1 := length(t1);				done := false;				i := 0;				ClearInBuf;				while not done do				begin					result := AsyncMWrite(outputRef, l1, ptr(ord4(@t1) + 1));					myTimer := tickCount;					gotCh := char(0);					while ((myTimer + 300) > tickCount) and not ComPeriod and (gotCh <> char(13)) do						gotCh := get1ComPort;					i := i + 1;					if (i > 4) or (gotCh = char(13)) or ComPeriod then						done := true;				end;			end			else				gotCh := char(13);			if gotCh = char(13) then				PrepModem := true			else				PrepModem := false;		end;	end;	procedure DoGFileRec (Save: boolean);		var			tempFileName: str255;			sharedRef: integer;			initGFileHand: GFileSecHand;	begin		UseResFile(RShared);		handle(initGFileHand) := Get1Resource('MesD', 2);		HNoPurge(handle(initGFileHand));		if reserror <> noErr then			sysbeep(10);		if save then			initGFileHand^^ := intGFileHand^^		else			intGFileHand^^ := initGFileHand^^;		if save then		begin			ChangedResource(handle(initGFileHand));			WriteResource(handle(initGFileHand));		end;		HPurge(handle(initGFileHand));		useResFile(myResourceFile);	end;	procedure DoSystRec (Save: boolean);		var			tempFileName: str255;			sharedRef: integer;	begin		UseResFile(RShared);		handle(InitSystHand) := Get1Resource('BBsy', 0);		HNoPurge(handle(InitSystHand));		if reserror <> noErr then			sysbeep(10);		if save then			InitSystHand^^ := intSystRec		else			intSystRec := InitSystHand^^;		if save then		begin			ChangedResource(handle(InitSystHand));			WriteResource(handle(InitSystHand));		end;		HPurge(handle(InitSystHand));		useResFile(myResourceFile);	end;	procedure MakeExtList;		var			myCPB: CInfoPBRec;			myHPB: HParamBlockRec;			fName: str255;			index, fileRef: integer;			theDirID: longint;			TempEx: HermesExDef;			exInfo: eInfoHand;	begin		if myExternals <> nil then		begin			HPurge(handle(myExternals));			DisposHandle(handle(myExternals));		end;		myExternals := nil;		numExternals := 0;		fName := concat(sharedPath, 'Externals:');		myHPB.ioCompletion := nil;		myHPB.ioNamePtr := @fName;		myHPB.ioVRefNum := 0;		myHPB.ioVolIndex := -1;		ErrorRep('PBHGetVInfo', PBHGetVInfo(@myHPB, false));		fName := concat(sharedPath, 'Externals:');		myCPB.ioCompletion := nil;		myCPB.ioNamePtr := @fname;		myCPB.ioVRefNum := myHPB.ioVRefNum;		myCPB.ioFDirIndex := 0;		result := PBGetCatInfo(@myCPB, false);		myCPB.iovRefNum := myHPB.ioVRefNum;		myCPB.ioNamePtr := @fName;		theDirID := myCPB.ioDrDirID;		myExternals := ExternListHand(NewHandle(0));		HNoPurge(handle(myExternals));		index := 1;		repeat			fName := '';			myCPB.ioNamePtr := @fname;			myCPB.ioFDirIndex := index;			myCPB.ioDrDirID := theDirID;			myCPB.ioVrefNum := myHPB.ioVRefNum;			result := PBGetCatInfo(@myCPB, FALSE);			if result = noErr then				if not (BitTst(@myCPB.ioFlAttrib, 3)) then				begin {we have a file}					if myCPB.ioFlFndrInfo.fdType = 'XHRM' then					begin						fileRef := OpenResFile(concat(sharedPath, 'Externals:', fName));						if fileRef <> -1 then						begin							UseResFile(fileRef);							numExternals := numExternals + 1;							SetHandleSize(handle(myExternals), GetHandleSize(handle(myExternals)) + SizeOf(HermesExDef));							myExternals^^[numExternals].name := fName;							myExternals^^[numExternals].allTheTime := false;							myExternals^^[numExternals].minSLForMenu := 1;							myExternals^^[numExternals].RestrictionMenu := char(0);							myExternals^^[numExternals].codeHandle := nil;							myExternals^^[numExternals].UResoFile := 0;							myExternals^^[numExternals].userExternal := false;							SetResLoad(false);							if (Get1Resource('HRMS', 100) <> nil) then							begin								SetResLoad(true);								exInfo := eInfoHand(Get1Resource('HRMS', 100));								if exInfo <> nil then								begin									HLock(handle(exInfo));									myExternals^^[numExternals].userExternal := true;									myExternals^^[numExternals].allTheTime := exInfo^^.allTime;									myExternals^^[numExternals].minSLForMenu := exInfo^^.minSLforMenu;									myExternals^^[numExternals].RestrictionMenu := exInfo^^.restriction;									HUnlock(handle(exInfo));									ReleaseResource(handle(exInfo));									myExternals^^[numExternals].codeHandle := Get1Resource('XHRM', 10001);									if myExternals^^[numExternals].codeHandle = nil then										myExternals^^[numExternals].codeHandle := Get1Resource('XHRM', 63);									MoveHHi(myExternals^^[numExternals].codeHandle);									HLock(myExternals^^[numExternals].codeHandle);								end;								myExternals^^[numExternals].UResoFile := fileRef;								myExternals^^[numExternals].privatesNum := 0;								SetResLoad(false);							end;							if (Get1Resource('XHRM', 10000) <> nil) then								myExternals^^[numExternals].sysopExternal := true							else								myExternals^^[numExternals].sysopExternal := false;							SetResLoad(true);							myExternals^^[numExternals].IconHandle := Get1Resource('ICN#', 10000);							if resError = noErr then							begin								DetachResource(myExternals^^[numExternals].iconHandle);								HNoPurge(myExternals^^[numExternals].iconHandle);							end;							UseResFile(myResourceFile);							if not myExternals^^[numExternals].userExternal then								CloseResFile(fileRef);						end;					end;				end; {else}			index := index + 1;		until (result <> noErr);		UseResFile(myResourceFile);		MoveHHi(handle(myExternals));		if numexternals > 0 then		begin			for index := 1 to numExternals do			begin				if (myExternals^^[index].name = 'Options') then				begin					tempEx := myExternals^^[1];					myExternals^^[1] := myExternals^^[index];					myExternals^^[index] := tempex;				end;			end;		end		else		begin			DisposHandle(handle(myExternals));			myExternals := nil;		end;	end;	procedure DrawExternalsList (theWindow: WindowPtr; item: integer);		var			kind: integer;			h: handle;			r: rect;	begin		if item = 1 then		begin			SetPort(theWindow);			GetDItem(theWindow, 1, kind, h, r);			LUpdate(theWindow^.visRgn, ExtList);		end;	end;	procedure SysopExternal (message, item: integer; var theEvent: EventRecord; myHerm: HermDataPtr; var XHRMrefcon: longint; ConfigDialog: DialogPtr; PP: procptr);	inline		$205f,  	{   movea.l (a7)+,a0  }		$4e90;	{	jsr(a0)			   }	procedure CallSysopExternal (message, item: integer; var theEvent: eventRecord);		var			myHerm: HermDataRec;			temp: str255;	begin		temp := sharedPath;		myHerm.HSystPtr := @intSystRec;		myHerm.HMDescPtr := pointer(intMessStuff^);		myHerm.HDirDataPtr := pointer(intDLStuff^);		myHerm.HGFilePtr := pointer(intGFileHand^);		myHerm.sharedPath := @temp;		myHerm.reserved1 := 0;		myHerm.reserved2 := 0;		SetPort(sysConfig);		UseResFile(myOpenEx.resourceFile);		SysopExternal(message, item, theEvent, @myHerm, myOpenEx.exRefcon, SysConfig, pointer(myOpenEx.codeHandle^));		UseResFile(myResourceFile);	end;	procedure CloseSysopExternal;		var			theEvent: EventRecord;			tempInt: integer;			exInfo: eInfoHand;	begin		CallSysopExternal(closeDev, 0, theEvent);		HUnlock(myOpenEx.codeHandle);		ReleaseResource(myOpenEx.codeHandle);		ShortenDITL(sysConfig, myOpenEx.numAddedItems);		if not myExternals^^[myOpenEx.numExt].userExternal then			CloseResFile(myOpenEx.resourceFile)		else		begin			UseResFile(myOpenEx.resourceFile);			exInfo := eInfoHand(Get1Resource('HRMS', 100));			if exInfo <> nil then			begin				HLock(handle(exInfo));				myExternals^^[myOpenEx.numExt].allTheTime := exInfo^^.allTime;				myExternals^^[myOpenEx.numExt].minSLForMenu := exInfo^^.minSLforMenu;				myExternals^^[myOpenEx.numExt].RestrictionMenu := exInfo^^.restriction;				HUnlock(handle(exInfo));				ReleaseResource(handle(exInfo));			end;		end;		UseResFile(myResourceFile);		SizeWindow(SysConfig, 356, 230, false);	end;	procedure UpdateSysConfig (event: eventRecord);	begin		DrawDialog(sysConfig);		CallSysopExternal(updateDev, -1, event);	end;	procedure OpenSysopExternal (num: integer);		var			DITLhandle: handle;			sizeMinusNum, numItems: integer;			theEvent: eventRecord;	begin		myOpenEx.numExt := num;		myOpenEx.number := num;		myOpenEx.exRefCon := 0;		if myExternals^^[num].userExternal then			myOpenEx.resourceFile := myExternals^^[num].UResoFile		else			myOpenEx.resourceFile := OpenResFile(concat(sharedPath, 'Externals:', myExternals^^[num].name));		if myOpenEx.resourceFile <> -1 then		begin			UseResFile(myOpenEx.resourceFile);			myOpenEx.codeHandle := Get1Resource('XHRM', 10000);			MoveHHi(myOpenEx.codeHandle);			HLock(myOpenEx.codeHandle);			DITLHandle := Get1Resource('DITL', 10000);			AppendDITL(sysConfig, DITLHandle, overlayDITL);			ReleaseResource(DITLHandle);			myOpenEx.numAddedItems := CountDITL(sysConfig) - 1;			CallSysopExternal(initDev, 0, theEvent);			SetPort(sysConfig);			InvalRect(sysConfig^.portRect);		end;		UseResFile(myResourceFile);	end;	procedure OpenSystemConfig (whichExternal: integer);		type			stuffLDEF = record					oldIC: array[0..31] of LONGINT;					oldMk: array[0..31] of LONGINT;					name: str255;				end;		var			Dtype, i, therow: integer;			DItem: handle;			tempRect, dataBounds, tr2: rect;			cSize: cell;			stuffer: stuffLDEF;			theDialogPtr: dialogPeek;			thisEditText: TEHandle;	begin		if SysConfig = nil then		begin			if numExternals > 0 then			begin				SetDAFont(geneva);				SysConfig := GetNewDialog(1541, nil, pointer(-1));				SetPort(sysConfig);				SetDAFont(0);				TheDialogPtr := DialogPeek(SysConfig);				ThisEditText := TheDialogPtr^.textH;				HLock(Handle(ThisEditText));				ThisEditText^^.txSize := 9;				TextSize(9);				ThisEditText^^.txFont := geneva;				TextFont(geneva);				ThisEditText^^.fontAscent := 9;				ThisEditText^^.lineHeight := 9 + 2 + 0;				HUnLock(Handle(ThisEditText));				GetDItem(SysConfig, 1, DType, DItem, tempRect);				tr2 := temprect;				tempRect.right := tempRect.right - 15;				SetRect(dataBounds, 0, 0, 1, 0);				cSize.h := tempRect.right - tempRect.left;				cSize.v := 57;				ExtList := LNew(tempRect, dataBounds, cSize, 10000, SysConfig, FALSE, FALSE, FALSE, TRUE);				ExtList^^.selFlags := lOnlyOne + lNoNilHiLite;				SetDItem(SysConfig, 1, DType, @DrawExternalsList, tr2);				for i := 1 to numExternals do				begin					if myExternals^^[i].sysopExternal then					begin						theRow := LAddRow(1, 200, ExtList);						cSize.v := theRow;						cSize.h := 0;						stuffer.name := myExternals^^[i].name;						if myExternals^^[i].iconHandle <> nil then							BlockMove(pointer(myExternals^^[i].iconHandle^), @stuffer, 256)						else						begin							DItem := GetResource('ICN#', 6002);							HLock(DItem);							BlockMove(pointer(DItem^), @stuffer, 256);							HUnlock(DItem);							ReleaseResource(DItem);						end;						LSetCell(@stuffer, 257 + length(stuffer.name), cSize, ExtList);					end;				end;				ShowWindow(SysConfig);				cSize := Cell($00000000);				cSize.v := whichExternal - 1;				LSetSelect(TRUE, cSize, ExtList);				LDoDraw(true, extList);				OpenSysopExternal(whichExternal);			end			else			begin				ProblemRep('There are no external modules installed!');			end;		end		else			SelectWindow(sysConfig);	end;	procedure ClickSystemConfig (theEvent: EventRecord; itemHit: integer);		var			myPt: point;			tempCell: cell;			dType, i: integer;			DItem: handle;			tempRect: rect;			got: boolean;	begin		setPort(SysConfig);		myPt := theEvent.where;		GlobalToLocal(myPt);		if itemHit = 1 then		begin			if LClick(myPt, theEvent.modifiers, ExtList) then				;			tempCell.h := 0;			tempCell.v := 0;			if LGetSelect(true, tempCell, ExtList) then			begin				tempCell.v := tempCell.v + 1;				dType := 0;				i := 0;				repeat					i := i + 1;					if myExternals^^[i].sysopExternal then						DType := dType + 1;				until (dType = tempCell.v);				tempCell.v := i - 1;				if (tempCell.v + 1) <> myOpenEx.number then				begin					CloseSysopExternal;					SetPort(sysConfig);					GetDItem(SysConfig, 1, DType, DItem, tempRect);					tempRect.left := tempRect.right;					tempRect.right := sysConfig^.portRect.right;					EraseRect(tempRect);					OpenSysopExternal(tempCell.v + 1);				end;			end			else			begin				i := 0;				dType := 0;				repeat					i := i + 1;					if myExternals^^[i].sysopExternal then						dType := dType + 1;				until (i = myOpenEx.number);				tempCell.v := dType - 1;				tempCell.h := 0;				LSetSelect(true, tempCell, ExtList);			end;		end		else		begin			CallSysopExternal(hitDev, itemHit, theEvent);		end;	end;	procedure CloseSystemConfig;		var			i: integer;	begin		if sysConfig <> nil then		begin			CloseSysopExternal;			LDispose(ExtList);			doSystRec(true);			doGFileRec(true);			DisposDialog(SysConfig);			SysConfig := nil;			if intSystRec.defaFore < 8 then			begin				defaultStyle.fcol := intSystRec.defaFore;				defaultStyle.bcol := intSystrec.defaBack;			end			else			begin				defaultstyle.fcol := 7;				defaultstyle.bcol := 0;			end;			if (((hermesFontSize = 9) and not intSystRec.ninePoint) or ((hermesFontSize = 12) and intSystRec.ninePoint)) then			begin				SetFontVars;				for i := 1 to 10 do				begin					CloseANSIWindow(i);					SetRect(theWindPos^^.wNodesStd[i], 0, 0, 0, 0);					SetRect(theWindPos^^.wNodesUser[i], 0, 0, 0, 0);					theWindPos^^.wIsOpen[i] := true;				end;				for i := 1 to intSystRec.numNodes do					OpenANSIWindow(i);			end;		end;	end;end.