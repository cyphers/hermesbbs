unit HermesUtils;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, inpOut2, InpOut, User, Message_Editor, NodePrefs, SystemPrefs, FileTrans2, FileTrans;	procedure DoEMail;	procedure DoMailCommand (Pres: str255);	procedure DoPosting;	procedure DoQScan;	procedure NScanCalc;	procedure DoRemove;	procedure DoNewUser;implementation	procedure GetTitle (mess: integer; var tit: str255; var poser: integer);	begin		with curglobs^ do		begin			if mess <= curNumMess then			begin				tit := curBase^^[mess - 1].title;				poser := curBase^^[mess - 1].fromUserNum;			end			else				tit := '';		end;	end;	function GoodForum (whichFor: integer): boolean;		var			a: boolean;			i: integer;	begin		with curglobs^ do		begin			a := false;			goodForum := false;			if (thisUser.msgFrmAccess[whichFor]) and (intMessStuff^^.numForums >= whichFor) then			begin				for i := 1 to intMessStuff^^.numBoards[whichFor] do					if (thisUser.whatNScan[whichFor, i]) and (intMessStuff^^.boards[whichFor, i].SLtoRead <= thisUser.secLevel) then						a := true;				if a then					GoodForum := true;			end;		end;	end;	procedure NScanCalc;		var			tempint, tt2: integer;			ttt1: str255;			got1, tb2: boolean;	begin		with curglobs^ do		begin			tempInt := -1;			tt2 := inSub;			repeat				tt2 := tt2 + 1;				tb2 := true;				if intMessStuff^^.boards[inforum, tt2].restrict <> char(0) then					if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, tt2].restrict) - byte(64))] then						tb2 := true					else						tb2 := false;				if tb2 and (thisUser.whatNScan[inForum, tt2]) and (intMessStuff^^.numBoards[inForum] >= tt2) and (intMessStuff^^.boards[inForum, tt2].SLtoRead <= thisUser.secLevel) and (thisUser.age >= intMessStuff^^.boards[inforum, TT2].minage) then					tempInt := tt2				else if (intMessStuff^^.numBoards[inForum] < tt2) then				begin					if inForum < (intMessStuff^^.numForums) then					begin						got1 := false;						repeat							inForum := inForum + 1;							if GoodForum(inForum) then								got1 := true;						until got1 or (inForum >= intMessSTuff^^.numForums);						if got1 then						begin							OutLine(concat('<< Advancing to ', intMessStuff^^.forums[inForum], ' >>'), true, 3);							bCR;							tt2 := 0;						end						else						begin							OutLine(retinstr(17, 61), true, 3);							inNScan := false;							inZScan := false;							inForum := saveInForum;							inSub := saveInSub;							fromQScan := false;							GoHome;							tempint := 50;							if (thisUser.NTransAfterMess) and not (intSystRec.closedTransfers) then							begin								ListDo := ListFive;								BoardSection := ListFiles;								bCR;								IUDateString(lastFScan, shortDate, ttt1);								bCR;								OutLine(concat(retinstr(17, 60), ttt1, '.'), true, 1);								curPrompt := 'Y';							end;						end;					end					else					begin						OutLine(retinstr(17, 61), true, 3);						inNScan := false;						inZScan := false;						inForum := saveInForum;						inSub := saveInSub;						GoHome;						fromQScan := false;						tempint := 50;						if thisUser.NTransAfterMess and not (intSystRec.closedTransfers) then						begin							ListDo := ListFive;							BoardSection := ListFiles;							bCR;							IUDateString(lastFScan, shortDate, ttt1);							bCR;							OutLine(concat(retinstr(17, 60), ttt1, '.'), true, 1);							curPrompt := 'Y';						end;					end;				end;			until tempint <> -1;			if tempInt < 50 then			begin				inSub := tt2;				BoardSection := QScan;				QDo := QOne;			end;		end;	end;	procedure DoQScan;		var			tempString, tempString2, s1, s2: str255;			tempLong: longint;			temppt: point;			repo: sfreply;			aborteds: boolean;			tempInt, i, hiMs, hold2, numreply, dm: integer;	begin		with curglobs^ do		begin			case QDo of				Qone: 				begin					if (inNScan) and (inSub = 0) then						NScanCalc;					if inSub > 0 then					begin						OpenBase(inForum, inSub, false);						NumToString(curNumMess, s1);						NumToString(inSub, s2);						i := 1;						inMessage := 1;						if curNumMess > 0 then						begin							while (i <= curNumMess) and (curBase^^[i - 1].qScnPtr <= thisUser.lastMsgs[inforum, inSub]) do								i := i + 1;							if (i <= curNumMess) and (curBase^^[i - 1].qScnPtr > thisUser.lastMsgs[inforum, insub]) then								inmessage := i							else								inMessage := curnummess + 1;						end;						if (inMessage > curNumMess) then						begin							OutLine(concat(retinstr(17, 62), intMessStuff^^.boards[inForum, inSub].Name, ' #', s2, ' >'), true, 1);							bCR;							GoHome;						end						else						begin							OutLine(concat('< Q-scan ', intMessStuff^^.boards[inForum, inSub].Name, ' #', s2, ' - ', s1, ' msgs >'), true, 1);							PrintCurMessage(true);							Qdo := QTwo;						end;					end					else						GoHome;				end;				QTwo: 				begin					if not inZScan then					begin						if curNumMess > 0 then						begin							HelpNum := 16;							curMesgRec := curBase^^[inMessage - 1];							NumToString(curNumMess, s1);							NumToString(inMessage, s2);							if not intMessStuff^^.boards[inForum, inSub].threading then							begin								OutLine('[', true, 3);								OutLine(intMessStuff^^.boards[inForum, inSub].Name, false, 4);								OutLine('] ', false, 3);								NumbersPrompt(concat('Read:(1-', s1, ',^', s2, '),? :'), 'A+-<>RBC=TQDNMVEU?', curnumMess, 1);							end							else							begin								bufferIt(' Sub', true, 4);								bufferIt(': ', false, 0);								bufferIt(concat(intMessStuff^^.boards[inforum, insub].name, '   '), false, 3);								if threadmode then									bufferIt('THREAD', false, 6);								if thisUser.canANSI then									OutLine('', false, 0);								bufferIt('Read', true, 4);								bufferIt(': ', false, 0);								bufferIt(concat('(1-', s1, ')'), false, 5);								bufferIt(', ', false, 0);								bufferIt(concat('Message#', s2), false, 2);								if threadmode then								begin									bufferIt(', ', false, 0);									bufferIt('[F]orward, [L]ast, [Q]uit', false, 5);									bufferIt(', ', false, 0);									bufferIt('?', false, 1);									bufferIt('', false, 0);									ReleaseBuffer;									NumbersPrompt(' :', 'A+-<>RBC=TQFLDNMVEU?', curnumMess, 1);								end								else								begin									hold2 := inmessage;									numreply := 0;									tempstring := curBase^^[inmessage - 1].title;									if pos('RE: ', tempstring) <> 2 then										tempstring := concat(char(0), 'RE: ', tempstring);									while (hold2 < curNumMess) do									begin										hold2 := hold2 + 1;										if tempstring = curBase^^[hold2 - 1].title then											numReply := numreply + 1;									end;									NumToString(numreply, s1);									bufferIt(', ', false, 0);									bufferIt(concat('Replies=', s1), false, 1);									bufferIt(', ', false, 0);									bufferIt('[C/R]=Next Msg', false, 2);									bufferIt(', ', false, 0);									bufferIt('?', false, 1);									bufferIt('', false, 0);									ReleaseBuffer;									NumbersPrompt(' :', 'A+-<>RBC=TQFLDNMVEU?', curnumMess, 1);								end;							end;							Qdo := QThree;						end						else						begin							OutLine('No messages here.', true, 0);							bCR;							endQScan := true;							GoHome;						end;					end					else					begin						curPrompt := '';						continuous := true;						QDo := Qthree;					end;				end;				QThree: 				begin					if (length(curprompt) >= 1) and (curprompt[1] = ' ') then						delete(curprompt, 1, 1);					if (curPrompt = '') or (CurPrompt = '+') or (curprompt = '>') then					begin						if curNumMess > inMessage then						begin							inMessage := inMessage + 1;							if continuous then							begin								bCR;								bCR;								bCR;							end;							PrintCurMessage(true);							if not continuous then								QDo := QTwo;						end						else						begin							continuous := false;							QDo := QFour;							bCR;							threadMode := false;							if not thisUser.restrics[1] and (thisUser.secLevel >= intMessStuff^^.boards[inForum, inSub].SLtoPost) and not inZScan then							begin								YesNoQuestion(concat('Post on ', intmessStuff^^.boards[inForum, inSub].name, '? '), false);							end							else								curPrompt := 'N';						end;					end					else if (curPrompt = 'C') then					begin						curPrompt := '';						continuous := true;						QDo := Qthree;						if inMessage < curNumMess then						begin							inMessage := inMessage + 1;						end;						PrintCurMessage(true);					end					else if (curPrompt[1] > '0') and (curPrompt[1] <= '9') then					begin						StringToNum(curprompt, tempLong);						if (templong <= curNumMess) and (templong > 0) then						begin							inMessage := templong;						end;						QDo := QTwo;						PrintCurMessage(true);					end					else if (CurPrompt = 'Q') then					begin						if not threadMode then						begin							Outline(concat('< ', intmessStuff^^.boards[inForum, inSub].name, ' Q-Scan Done >'), true, 1);							bCR;							GoHome;							if inNScan then							begin								OutLine(retinstr(17, 61), true, 3);								inForum := saveInForum;								InSub := saveInSub;								inNScan := false;								inZScan := false;							end;						end						else						begin							OutLine('Thread mode deactivated.', true, 2);							bCR;							bCR;							threadMode := false;							inMessage := headMessage;							PrintCurMessage(true);							QDo := QTwo;						end;					end					else if (CurPrompt = '-') or (curprompt = '<') then					begin						if inMessage > 1 then							inMessage := inMessage - 1;						PrintCurMessage(true);						QDo := QTwo;					end					else if (curprompt = 'E') then					begin						if thisUser.cosysop then						begin							if sysopLogon then							begin								SetPt(tempPt, 40, 40);								SFPutFile(tempPt, 'Please name extract file:', 'Text File', nil, repo);								if repo.good then								begin									if curWriting <> nil then									begin										DisposHandle(handle(curWriting));										curWriting := nil;									end;									curWriting := ReadMessage(curBase^^[inMessage - 1].storageType, curbase^^[inMessage - 1].storedAs, inforum, insub);									result := FSDelete(repo.fName, repo.vrefNum);									result := Create(repo.fname, repo.vrefnum, 'HRMS', 'TEXT');									result := FSOpen(repo.fname, repo.vrefnum, tempint);									templong := gethandleSize(handle(curWriting));									result := FSWrite(tempint, templong, pointer(curWriting^));									result := FSClose(tempint);								end;							end							else								OutLine('Cannot extract remotely.', true, 0);						end;						QDo := QTwo;					end					else if (curPrompt = '=') then					begin						PrintCurMessage(true);						QDo := QTwo;					end					else if (curPrompt = 'U') then					begin						if thisUser.cosysop then						begin							OpenBase(inforum, inSub, false);							if curBase^^[inMessage - 1].anonyFrom then								curBase^^[inMessage - 1].anonyFrom := false;							OutLine('Message is not anonymous now.', true, 0);							SaveBase(inForum, inSub);						end;						QDo := QTwo;					end					else if (curPrompt = 'N') then					begin						if thisUser.cosysop then						begin							OpenBase(inforum, inSub, false);							curBase^^[inMessage - 1].deletable := not curBase^^[inMessage - 1].deletable;							if curBase^^[inMessage - 1].deletable then								OutLine('Message CAN now be auto-purged.', true, 2)							else								OutLine('Message will NOT be auto-purged.', true, 2);							SaveBase(inForum, inSub);						end;						QDo := QTwo;					end					else if (CurPrompt = 'D') then					begin						if thisUser.coSysop then						begin							DeletePost(inForum, inSub, inMessage, true);							if inMessage > curNumMess then								inMessage := inMessage - 1;							curMesgRec := curBase^^[inMessage - 1];						end;						Qdo := QTwo;					end					else if (curprompt = 'L') then					begin						if intMessStuff^^.boards[inforum, insub].threading then						begin							if not threadMode then							begin								threadMode := true;								headMessage := inMessage;							end;							hold2 := inMessage;							if inMessage <= 1 then							begin								OutLine('There are no messages before this one.', true, 2);								bCR;								bCR;								QDo := QTwo;								Exit(doQScan);							end;							numreply := 0;							tempstring := curBase^^[inmessage - 1].title;							if tempstring[1] <> char(0) then								tempstring := concat(char(0), 'RE: ', tempstring);							aborteds := false;							while not aborteds do							begin								inMessage := inMessage - 1;								if (inMessage < 1) then								begin									OutLine('That was the first message available in this thread.', true, 2);									BCR;									BCR;									inMessage := hold2;									PrintCurMessage(true);									QDo := QTwo;									exit(doQScan);								end;								tempstring2 := curBase^^[inMessage - 1].title;								if tempstring2[1] <> char(0) then									tempstring2 := concat(char(0), 'RE: ', tempstring2);								if tempstring2 = tempstring then								begin									aborteds := true;									PrintCurMessage(true);									QDo := QTwo;								end;							end;						end						else							QDo := QTwo;					end					else if (curprompt = 'F') then					begin						if intMessStuff^^.boards[inforum, insub].threading then						begin							if not threadmode then							begin								headMessage := inMessage;								threadmode := true;							end;							hold2 := inMessage;							if inMessage >= curNumMess then							begin								OutLine('That was the last message in this sub.', true, 2);								bCR;								bCR;								QDo := QTwo;								Exit(doQScan);							end;							numreply := 0;							tempstring := curBase^^[inmessage - 1].title;							if tempstring[1] <> char(0) then								tempstring := concat(char(0), 'RE: ', tempstring);							aborteds := false;							while not aborteds do							begin								inMessage := inMessage + 1;								if (inMessage > curNumMess) then								begin									OutLine('There are no more messages available in this thread.', true, 2);									BCR;									BCR;									inMessage := hold2;									PrintCurMessage(true);									QDo := QTwo;									exit(doQScan);								end;								if curBase^^[inMessage - 1].title = tempstring then								begin									aborteds := true;									PrintCurMessage(true);									QDo := QTwo;								end;							end;						end						else							QDo := QTwo;					end					else if (curPrompt = 'B') then					begin						if not threadMode then						begin							endQScan := true;							GoHome;						end						else							QDo := QTwo;					end					else if (curPrompt = 'T') then					begin						getTitle(inMessage + 1, tempString, tempint);						if tempString <> '' then						begin							i := 1;							repeat								NumToString(inmessage + i, s1);								tempstring2 := curBase^^[inMessage + i - 1].fromUserName;								if curBase^^[inMessage + i - 1].anonyFrom then									tempString2 := '>>UNKNOWN<<';								if tempInt <> thisUser.UserNum then								begin									if curBase^^[inMessage + i - 1].qScnPtr <= thisUser.lastMsgs[inForum, inSub] then										bufferIt(concat('  (', s1, ') ', tempString, '  / ', tempstring2), false, 0)									else										bufferIt(concat('* (', s1, ') ', tempString, '  / ', tempstring2), false, 0);								end								else								begin									if curBase^^[inMessage + i - 1].qScnPtr <= thisUser.lastMsgs[inForum, inSub] then										bufferIt(concat('  [', s1, '] ', tempString, '  / ', tempstring2), false, 0)									else										bufferIt(concat('* [', s1, '] ', tempString, '  / ', tempstring2), false, 0);								end;								bufferbCR;								i := i + 1;								GetTitle(inMessage + i, tempString, tempInt);							until (tempString = '') or (i = 11);							inMessage := inMessage + i - 1;						end;						if inMessage = 0 then							inMessage := 1;						if (curBase^^[inMessage - 1].QscnPtr > thisuser.lastMsgs[inforum, insub]) then							thisuser.lastmsgs[inforum, insub] := curBase^^[inMessage - 1].QscnPtr;						ReleaseBuffer;						QDo := QTwo;					end					else if (CurPrompt = 'R') then					begin						if intMessStuff^^.boards[inforum, inSub].SLtoPost <= thisUser.SecLevel then						begin							fromQScan := true;							PostDo := postOne;							BoardSection := post;							reply := true;							replyToStr := curBase^^[inMessage - 1].fromuserName;							replyToNum := curBase^^[inMessage - 1].fromUserNum;							if curBase^^[inMessage - 1].anonyFrom then								replyToAnon := true							else								replyToAnon := false;							if intMessStuff^^.boards[inforum, inSub].threading then							begin								if (curBase^^[inMessage - 1].title[1] <> char(0)) then									replyStr := concat(char(0), 'RE: ', curBase^^[inMessage - 1].title)								else									replyStr := curBase^^[inMessage - 1].title;							end							else								replyStr := concat('RE: ', curBase^^[inMessage - 1].title);						end						else						begin							OutLine('You can''t post on this sub.', true, 0);							bCR;							QDo := QTwo;						end;					end					else if (curPrompt = 'A') then					begin						if not intMessStuff^^.boards[inforum, insub].echoConf then						begin							BoardSection := EMail;							EmailDo := EmailOne;							NumToString(curMesgRec.fromUserNum, curprompt);							if curMesgRec.anonyFrom then								sentanon := true							else								sentAnon := false;							callFMail := false;							fromQScan := true;						end						else						begin							OutLine('That feature not available in an echo conference.', true, 0);							bCR;							QDo := QTwo;						end;					end					else if (curprompt = 'M') then					begin						if (thisUser.coSysop) then						begin							QDo := QMove;							if intMessStuff^^.numForums > 1 then								NumbersPrompt('Move to which forum? ', '?', 9, 0)							else								curprompt := '1';						end						else							QDo := QTwo;					end					else if (CurPrompt = '?') then					begin						if (thisUser.coSysop) then						begin							OutLine('SYSOP Commands:', true, 2);							OutLine('D:elete Message        M:ove Message', true, 1);							OutLine('N: Permanent Message   U:Make not anonymous', true, 1);							OutLine('E:xtract Message to text file', true, 1);						end;						if LoadSpecialText(helpFile, 37) then						begin							if thisUser.canANSI then								doM(0);							BoardAction := ListText;							bCR;						end;						QDo := QTwo;					end					else					begin						Qdo := QTwo;					end;				end;				QMove: 				begin					if length(curprompt) > 0 then					begin						if curPrompt = '?' then						begin							PrintForumList;							QDo := QThree;							Curprompt := 'M';						end						else						begin							StringToNum(curprompt, tempLong);							if (tempLong <= intMessStuff^^.numForums) then							begin								if tempLong = 0 then									crossInt := 10								else									crossInt := tempLong;								QDo := QMove2;								NumbersPrompt('Which sub? ', '?', intMessStuff^^.Numboards[tempLong], 1);							end							else								QDo := QTwo;						end;					end					else						QDo := QTwo;				end;				QMove2: 				begin					if length(curprompt) > 0 then					begin						if CurPrompt = '?' then						begin							PrintSubList(crossInt);							QDo := QMove;							numToString(crossInt, curprompt);							bCR;						end						else						begin							StringToNum(curprompt, tempLong);							if (tempLong > 0) and (tempLong <= intMessStuff^^.numBoards[crossInt]) and ((tempLong <> inSub) or (crossInt <> inForum)) then							begin								bCR;								curMesgRec := curBase^^[inMessage - 1];								if curWriting <> nil then									DisposHandle(handle(curWriting));								curWriting := nil;								curWriting := ReadMessage(curMesgRec.storageType, curMesgRec.storedAs, inForum, inSub);								RemoveMessage(curMesgRec.storageType, curMesgRec.storedAs, inForum, inSub);								SetHandleSize(handle(curWriting), GetHandleSize(handle(curWriting)) + 1);								curWriting^^[getHandleSize(handle(curWriting)) - 1] := char(26);								curMesgRec.storedAs := SaveMessage(curMesgRec.storageType, curWriting, crossInt, tempLong);								if (curMesgRec.storedAs <> -1) then								begin									OpenBase(crossInt, tempLong, true);									i := 0;									if curNumMess > 0 then									begin										repeat											i := i + 1;										until (i = curNumMess) or (curBase^^[i - 1].daten > curMesgRec.daten);										if not (curBase^^[i - 1].daten > curMesgRec.daten) then											CurBase^^[i] := curMesgRec										else										begin											for hiMs := curNumMess downto i do												CurBase^^[hiMs] := curBase^^[hiMs - 1];											CurBase^^[i - 1] := curMesgRec;										end;									end									else									begin										i := 1;										curBase^^[i - 1] := curMesgRec;									end;									curNumMess := curNumMess + 1;									SaveBase(crossInt, tempLong);									if curNumMess > intMessStuff^^.boards[crossInt, tempLong].maxMessages then									begin										dm := 0;										i := 1;										while (dm = 0) and (i <= curNumMess) do										begin											if curBase^^[i - 1].deletable then												dm := i;											i := i + 1;										end;										if dm = 0 then											dm := 1;										CloseBase;										DeletePost(crossInt, tempLong, dm, true);									end;									DeletePost(inForum, inSub, inMessage, false);									OpenBase(inForum, inSub, false);									if inMessage > curNumMess then										inMessage := curNumMess;									OutLine('Message moved.', true, 0);									bCR;								end								else								begin									OutLine('Error; the sub you are moving to is full.', true, 0);									bCR;								end;								QDo := QTwo;							end							else								QDo := QTwo;						end;					end					else						QDO := QTwo;				end;				QFour: 				begin					if curprompt = 'N' then					begin						EndQScan := true;						GoHome;					end					else					begin						EndQScan := true;						reply := false;						replyToStr := 'All';						BoardSection := Post;						PostDo := PostOne;					end;				end;				QFive: 				begin					OpenBase(inForum, inSub, false);					tempint := curNumMess;					if (tempint > 0) and (thisUser.msgFrmAccess[inForum]) and (intMessStuff^^.boards[inForum, inSub].SLtoRead <= thisUser.secLevel) then					begin						NumToString(tempint, tempString);						tempString := concat(tempString, ' msgs. on ', intMessStuff^^.boards[inForum, inSub].name, '.');						OutLine(tempString, false, 2);						bCR;						NumbersPrompt('Start listing at? ', '', curNumMess, 1);						QDo := QSix;					end					else					begin						OutLine('No messages here.', true, 0);						GoHome;					end;				end;				QSix: 				begin					StringToNum(curPrompt, templong);					if (templong <= curNumMess) and (tempLong > 0) then					begin						inMessage := tempLong - 1;						curprompt := 'T';						QDo := QThree;					end					else						GoHome;				end;				otherwise			end;		end;	end;	procedure DoPosting;		var			tempString, tempString2: str255;			tempLong: longint;			tempint, i, dm: integer;			bleep, BLEEP2: boolean;	begin		with curglobs^ do		begin			case PostDo of				PostOne: 				begin					bCR;					if (intSystRec.SecLevels[thisUser.secLevel].mesgDay >= thisUser.MPostedToday) then					begin						if (FreeK(IntSystRec.msgsPath) > 100) then						begin							bleep := thisUser.restrics[1];							bleep2 := (thisUser.age >= intMessStuff^^.boards[inforum, inSub].minage);							if bleep2 and (intMessStuff^^.numBoards[inForum] >= inSub) and (thisUser.msgFrmAccess[inForum]) and (intMessStuff^^.boards[inForum, inSub].SLtoPost <= thisUser.SecLevel) and not bleep then							begin								curprompt := '';								if intMessStuff^^.boards[inForum, inSub].threading and not reply then								begin									LettersPrompt('To (<CR> for all) : ', '', 31, false, false, false, char(0));									myprompt.wrapsOnCR := false;								end;								PostDo := PostTwo;							end							else							begin								OutLine(retinstr(17, 63), false, 0);								GoHome;							end;						end						else						begin							OutLine(retinstr(17, 64), false, 0);							GoHome;						end;					end					else					begin						OutLine(retinstr(17, 65), false, 0);						GoHome;					end;				end;				PostTwo: 				begin					curMesgRec.toUserNum := 0;					curMesgrec.toUserName := 'All';					if intMessStuff^^.boards[inForum, inSub].threading and not reply then					begin						NumToString(gBBSwindows[activeNode]^.cursor.h, tempstring);						if FindUser(curPrompt, tempuser) and not tempuser.deleting then						begin							curMesgRec.touserNum := tempuser.userNum;							curMesgRec.toUserName := tempUser.userName;							NumToString(tempuser.UserNum, tempstring2);							if thisUser.canANSI then							begin								OutLine(concat(char(27), '[', tempstring, 'D', char(27), '[K'), false, -1);								OutLine('To   ', false, 4);								OutLine(concat(': ', tempUser.userName, ' #', tempString2), false, 0);							end;						end						else						begin							if intMessStuff^^.boards[inForum, inSub].echoConf then							begin								if length(curPrompt) = 0 then									curPrompt := 'All';								curMesgRec.toUserName := curprompt;								curMesgRec.touserNum := TABBYTOID;							end;							if thisUser.canANSI then							begin								OutLine(concat(char(27), '[', tempstring, 'D', char(27), '[K'), false, -1);								OutLine('To   ', false, 4);								if curMesgRec.toUserNum = TABBYTOID then									OutLine(concat(': ', curPrompt), false, 0)								else									OutLine(': All', false, 0);							end;						end;					end;					if not intMessStuff^^.boards[inforum, insub].threading or not reply then					begin						if not thisUser.canANSI and not thisUser.ANSIcolor then							OutLine('       (---=----=----=----=----=----=----=----=--)', true, 0);						bCR;						LettersPrompt('Title: ', '', 43, false, false, false, char(0));						ANSIPrompter(43);						PostDo := PostThree;					end					else					begin						tempstring := replystr;						delete(tempstring, 1, 1);						OutLine('Title: ', true, 2);						OutLine(tempstring, false, 4);						if thisUser.canANSI then							doM(0);						bCR;						PostDo := PostThree;						curprompt := replyStr;					end;				end;				PostThree: 				begin					if thisUser.canANSI then						doM(0);					if length(CurPrompt) > 0 then					begin						if intMessStuff^^.boards[inforum, inSub].threading and not reply then						begin							OpenBase(inForum, inSub, false);							if checktitle(curPrompt) then							begin								OutLine('Title is already in use.', true, 2);								bCR;								if curMesgRec.touserNum = TABBYTOID then									curprompt := curMesgRec.toUserName								else									NumToString(curMesgRec.touserNum, curprompt);								PostDo := PostTwo;								exit(doPosting);							end;						end;						CurMesgRec.title := CurPrompt;						curMesgRec.fromUserNum := thisUser.UserNum;						curMesgrec.fromuserName := thisUser.userName;						curMesgrec.anonyTo := false;						if reply and intMessStuff^^.boards[inforum, inSub].threading then						begin							curMesgRec.toUserNum := replyToNum;							curMesgrec.toUserName := replyToStr;							if replyToAnon then								curMesgRec.anonyTo := true;						end;						curMesgRec.storageType := intMessStuff^^.boards[inforum, insub].storetype;						if useWorkspace = 0 then						begin							maxLines := intSystRec.secLevels[thisUser.secLevel].lnsMessage;							EnterMessage(maxLines);							PostDo := PostFour;							myTrans.startTime := tickCount;						end						else						begin							UseWorkspace := 0;							LoadFileAsMsg('Local Workspace');							OutLine('Workspace text inserted.', true, 3);							bCR;							myTrans.startTime := 0;							bCR;							PostDo := PostFour;						end;					end					else					begin						OutLine('Aborted.', false, 3);						bCR;						GoHome;					end;				end;				PostFour: 				begin					if curWriting <> nil then					begin						if not ((IntSystRec.TabbyNet) and intMessStuff^^.boards[inforum, inSub].echoConf) then						begin							if (not thisUser.Restrics[5]) and (intMessStuff^^.boards[inForum, inSub].anonID = -1) and (endAnony = 0) then							begin								bCR;								YesNoQuestion('Anonymous? ', false);							end							else							begin								CurPrompt := 'N';								if (not thisUser.restrics[5]) and (EndAnony = 1) then									curprompt := 'Y'								else if (not thisUser.restrics[5]) and (EndAnony = -1) then									curprompt := 'N';								if (intMessStuff^^.boards[inForum, inSub].anonID = 0) then									curprompt := 'N';								if (intMessStuff^^.boards[inforum, insub].anonID = 1) then									curprompt := 'Y';							end;						end						else							curPrompt := 'N';						PostDo := PostFive;					end					else					begin						OutLine('Aborted.', true, 3);						bCR;						GoHome;					end;				end;				PostFive: 				begin					OutLine('Saving...', true, 0);					if intMessStuff^^.boards[inforum, insub].echoConf then						SaveNetpost;					if reply and not intMessStuff^^.boards[inforum, insub].threading then					begin						AddLine('');						AddLine(replyStr);					end;					if curPrompt = 'Y' then						curMesgRec.anonyFrom := true					else						curMesgRec.anonyFrom := false;					curMesgRec.deletable := true;					GetDateTime(tempLong);					curMesgRec.daten := templong;					for i := 0 to 9 do						curMesgRec.reserved[i] := char(0);					curMesgRec.qScnPtr := intSystRec.qscanpointer + 1;					IUDateString(tempLong, abbrevdate, tempstring);					IUTimeString(templong, true, tempstring2);					AddLine(concat(tempstring, ' ', tempstring2));					if not SavePost(inForum, inSub) then						OutLine('ERROR: SUB DATABASE FULL', true, 6);					if curWriting <> nil then						DisposHandle(handle(curWriting));					curWriting := nil;					OpenBase(inForum, inSub, false);					if curNumMess > intMessStuff^^.boards[inForum, inSub].maxMessages then					begin						dm := 0;						i := 1;						while (dm = 0) and (i <= curNumMess) do						begin							if curBase^^[i - 1].deletable then								dm := i;							i := i + 1;						end;						if dm = 0 then							dm := 1;						CloseBase;						DeletePost(inForum, inSub, dm, true);						inMessage := inMessage - 1;					end;					readMsgs := true;					thisUser.messagesPosted := thisUser.messagesPosted + 1;					thisUser.MPostedToday := thisUser.MPostedToday + 1;					intSystRec.qScanPointer := intSystRec.qScanPointer + 1;					intSystRec.mPostedToday := intSystRec.mPostedToday + 1;					doSystRec(true);					sysopLog(concat('      +', curMesgRec.title, ' posted on ', intMessStuff^^.boards[inForum, inSub].name), 0);					OutLine(concat('Posted on ', intMessStuff^^.boards[inForum, inSub].Name), false, 0);					bCR;					if (intSystRec.messComp > 0) and (myTrans.startTime > 0) then						GiveTime((tickcount - myTrans.startTime), intSystRec.messcomp, true);					OpenBase(inforum, insub, false);					GoHome;				end;				otherwise			end;		end;	end;	procedure DoRemove;		var			tempString, tempString2: str255;			num, i, tempint, pos: integer;			templong: longInt;	begin		with curglobs^ do		begin			case RmvDo of				rmvOne: 				begin					OpenBase(inForum, inSub, false);					num := curNumMess;					if num > 0 then					begin						i := 0;						tempint := 0;						repeat							i := i + 1;							GetTitle(i, tempString, pos);							if pos = thisUser.UserNum then							begin								if tempInt = 0 then								begin									Outline(concat('Posts by you on ', intMessStuff^^.boards[inForum, inSub].name), true, 0);									bCR;								end;								tempint := tempint + 1;								NumToString(i, tempString2);								OutLine(concat(tempString2, ': ', tempString), true, 0);							end;						until (i = num);						bCR;						if tempint > 0 then						begin							bCR;							NumbersPrompt('Remove which? ', '', 999, 1);							RmvDo := RmvTwo;						end						else						begin							OutLine('You have no messages here.', true, 0);							GoHome;						end;					end					else					begin						OutLine('No messages here.', true, 0);						GoHome;					end;				end;				rmvTwo: 				begin					if (curprompt <> '') and (curPrompt <> 'Q') then					begin						StringToNum(curPrompt, templong);						if templong <= curNumMess then						begin							GetTitle(tempLong, tempString, tempint);							if tempInt = thisUser.UserNum then							begin								DeletePost(inForum, inSub, tempLong, true);								OutLine('Message removed.', true, 0);								thisUser.messagesPosted := thisUser.messagesPosted - 1;							end							else								Outline('Message was not posted by you.', true, 0);						end;						GoHome;					end					else					begin						GoHome;						bCR;					end;				end;				otherwise			end;		end;	end;	procedure DoMailCommand (Pres: str255);		var			tempString, tempString2: str255;			tempInt, tempInt2, i, totEm: integer;			tempEMa: eMailRec;			tempPt: point;			repo: SFReply;			tempLong: longint;	begin		with curglobs^ do		begin			if length(pres) > 0 then			begin				case pres[1] of					'?': 					begin						if (thisUser.coSysop) then						begin							OutLine('SYSOP:   Z)Delete with no acknowledge     E)xtract to file', true, 3);							Outline('         V)alidate user                   O)Send form letter', true, 3);							OutLine(' ', false, 0);						end;						if LoadSpecialText(helpFile, 36) then						begin							if thisUser.canANSI then								doM(0);							BoardAction := ListText;							bCR;						end;						bCR;						ReadDo := readFour;					end;					'V': 					begin						readDo := readFour;						if thisUser.coSysop then						begin							SysopLog('      @Ran Uedit', 0);							BoardSection := UEdit;							UEDo := EnterUE;							MaxLines := -425;							FindMyEMail;							crossInt := theEmail^^[myEmailList^^[atEmail]].fromUser;						end;					end;					'F': 					begin						LettersPrompt('Forward to which user? ', '', 31, false, false, false, char(0));						ReadDo := ReadSeven;					end;					'A', 'O': 					begin						FindMyEmail;						tempEma := theEmail^^[myEmailList^^[atEmail]];						if not (tempEma.fromUser = TABBYTOID) then						begin							if not myUsers^^[tempEma.fromUser - 1].dltd then							begin								HeReadIt(tempEma);								NumToString(tempEma.fromUser, curPrompt);							end							else								curPrompt := '';						end						else						begin							if curwriting <> nil then							begin								DisposHandle(handle(curWriting));							end;							CurWriting := nil;							curWriting := ReadMessage(true, tempEma.storedAs, 0, 0);							curPrompt := takeMsgTop;							tempint := pos(' #', curprompt);							if tempint > 0 then								delete(curPrompt, tempint, 80);						end;						SentAnon := tempEma.anonyFrom;						DeleteMail(myEmailList^^[atEmail]);						BoardSection := EMail;						EmailDo := EMailOne;						CallFMail := true;						ReadDo := ReadFour;						if (pres[1] = 'O') then						begin							replyStr := curPrompt;							EmailDo := EmailFive;							NumbersPrompt('Send which form letter: ', 'Q', 9, 1);						end;					end;					'S': 					begin						FindMyEmail;						tempEma := theEmail^^[myEmailList^^[atEmail]];						BoardSection := EMail;						EmailDo := EMailOne;						CallFMail := true;						if not (tempEma.fromUser = TABBYTOID) then							NumToString(tempEma.fromUser, curPrompt)						else						begin							if curwriting <> nil then							begin								DisposHandle(handle(curWriting));							end;							CurWriting := nil;							curWriting := ReadMessage(true, tempEma.storedAs, 0, 0);							curPrompt := takeMsgTop;							tempint := pos(' #', curprompt);							if tempint > 0 then								delete(curPrompt, tempint, 80);						end;						SentAnon := tempEma.anonyFrom;						ReadDo := ReadFour;					end;					'E': 					begin						if sysopLogon then						begin							SetPt(tempPt, 40, 40);							SFPutFile(tempPt, 'Please name extract file:', 'Text File', nil, repo);							if repo.good then							begin								tempEma := theEmail^^[myEmailList^^[atEmail]];								if curWriting <> nil then								begin									DisposHandle(handle(curWriting));									curWriting := nil;								end;								curWriting := ReadMessage(true, tempEma.storedAs, 0, 0);								result := FSDelete(repo.fName, repo.vrefNum);								result := Create(repo.fname, repo.vrefnum, 'HRMS', 'TEXT');								result := FSOpen(repo.fname, repo.vrefnum, tempint);								templong := gethandleSize(handle(curWriting));								result := FSWrite(tempint, templong, pointer(curWriting^));								result := FSClose(tempint);							end;						end						else							OutLine('Cannot extract remotely.', true, 0);						ReadDo := readFour;					end;					'D', 'Z': 					begin						if (pres[1] <> 'Z') or (thisUser.coSysop) then						begin							FindMyEmail;							tempEma := theEmail^^[myEmailList^^[atEmail]];							if (pres[1] <> 'Z') and (tempEma.fromUser <> TABBYTOID) then								HeReadIt(tempEma);							DeleteMail(myEmailList^^[atEmail]);							if pres[1] <> 'Z' then								OutLine('Deleted.', false, 0)							else								OutLine('Deleted, not acknowledged.', false, 0);							bCR;							FindMyEmail;							totEm := GetHandleSize(handle(myEmailList)) div 2;							if atEmail >= totEm then								atEmail := atEmail - 1							else if atEmail < 0 then								atEmail := 0;							if totEm > 0 then								PrintCurEMail							else								GoHome;							readDo := readFour;						end						else							readDo := readFour;					end;					'Q': 					begin						GoHome;					end;					'R': 					begin						PrintCurEMail;						ReadDo := readFour;					end;					'+', 'I': 					begin						FindMyEmail;						totEm := GetHandleSize(handle(myEmailList)) div 2;						if (atEmail + 1) < totEm then						begin							atEMail := atEMail + 1;							PrintCurEMail;						end						else							goHome;						ReadDo := readFour;					end;					'-': 					begin						if (atEmail > 0) then						begin							atEMail := atEMail - 1;							PrintCurEMail;						end						else							goHome;						ReadDo := readFour;					end;					'G': 					begin						FindMyEmail;						totEm := GetHandleSize(handle(myEmailList)) div 2;						readDo := readSix;						NumToString(totEm, tempString2);						tempString := concat('Go to which (1-', tempString2, ') ? ');						NumbersPrompt(tempstring, '', totEm, 1);					end;					otherwise				end;			end			else			begin				FindMyEmail;				totEm := GetHandleSize(handle(myEmailList)) div 2;				if totEm > (atEMail + 1) then					atEMail := atEmail + 1				else					atEmail := 0;				PrintCurEmail;				ReadDo := readFour;			end;		end;	end;	procedure DoEMail;		var			tempString, tempString2: str255;			tempLong: longInt;			result: OSerr;	begin		with curglobs^ do		begin			if (FreeK(IntSystRec.msgsPath) > 100) then			begin				if (not thisUser.restrics[6] and ((thisuser.emSentToday + thisUser.mPostedToday) <= intSystRec.secLevels[thisUser.secLevel].mesgDay)) or newfeed or (curprompt = '1') then				begin					netMail := FidoNetAccount(curprompt);					if FindUser(curPrompt, MailingUser) or netMail then					begin						if (not (mailingUser.deleting)) or netmail then						begin							if (thisUser.UserNum <> MailingUser.UserNum) or netmail then							begin								if (MailingUser.Mailbox) and not netmail then								begin									NumToString(mailingUser.forwardedTo, curPrompt);									if FindUser(curPrompt, tempuser) then									begin										if not tempUser.mailbox and not tempuser.deleting then											OutLine('Mail Forwarded.', true, 0)										else										begin											OutLine('Can''t forward to a forwarding user!', true, 6);											if not callFMail then											begin												GoHome;											end											else											begin												BoardSection := ReadMail;												bCR;												PrintCurEmail;											end;										end;									end;								end;								if not netmail then								begin									NumToString(MailingUser.UserNum, tempString2);									if not SentAnon or (thisUser.coSysop) then										tempString := concat('E-mailing ', MailingUser.UserName, ' #', tempString2)									else										tempString := 'E-mailing >UNKNOWN<';								end								else								begin									tempString := concat('E-mailing ', myFido.name, ' at node ', myFido.atNode, '.');								end;								OutLine(tempString, true, 0);								bCR;								if not newfeed and (useWorkspace <= 1) then								begin									if not thisUser.canANSI and not thisUser.ANSIcolor then										OutLine('       (---=----=----=----=----=----=----=----=--)', true, 0);									bCR;									LettersPrompt('Title: ', '', 43, false, false, false, char(0));									ANSIPrompter(43);								end								else								begin									OutLine('Title: ', true, 2);									if (useWorkspace > 1) then										OutLine('Loading...', false, 4)									else										OutLine('Validation Feedback', false, 4);									if thisUser.canANSI then										doM(0);									curPrompt := 'VALIDATION FEEDBACK';									bCR;									lnsPause := 0;								end;								CurEMailRec.fromuser := thisUser.Usernum;								curEmailRec.toUser := mailingUser.usernum;								if netMail then									curEmailRec.toUser := TABBYTOID;								CurEMailRec.MType := 1;								curEmailRec.multiMail := false;								GetDateTime(curEMailRec.dateSent);								numMultiUsers := 0;								EMailDo := EmailTwo;							end							else							begin								OutLine('You can''t send E-mail to yourself.', true, 0);								bCR;								bCR;								if not callFMail then								begin									GoHome;								end								else								begin									BoardSection := ReadMail;									bCR;									PrintCurEmail;								end;							end;						end						else						begin							if MailingUser.Deleting then								OutLine('Deleted user.', true, 0)							else								OutLine('Mailbox full.', true, 0);							bCR;							bCR;							if not callFMail then							begin								GoHome;							end							else							begin								BoardSection := ReadMail;								bCR;								PrintCurEmail;							end;						end;					end					else					begin						OutLine('No such user.', true, 0);						bCR;						bCR;						if not callFMail then						begin							GoHome;						end						else						begin							BoardSection := ReadMail;							bCR;							PrintCurEmail;						end;					end;				end				else				begin					OutLine('You can''t send mail.', true, 0);					bCR;					bCR;					if not callFMail then					begin						GoHome;					end					else					begin						BoardSection := ReadMail;						bCR;						PrintCurEmail;					end;				end;			end			else			begin				OutLine(retinstr(17, 64), true, 0);				bCR;				if not callFMail then				begin					GoHome;				end				else				begin					BoardSection := ReadMail;					bCR;					PrintCurEmail;				end;			end;		end;	end;	procedure DoNewUser;		var			WelcomeName, tempstring, tempString2, tempString3, tempString4: str255;			tempInt, tempLong: longInt;			tempDate, tempDate2: DateTimeRec;			tempChar: char;			tempShort, i, LastRef, tempnumem, tempInt2, tempInt3: integer;			tempuser2: UserRec;			teEM, tempEMa: eMailRec;			tempBool, gotIt: boolean;	begin		with curglobs^ do		begin			case NewUserStage of				NewUserPass: 				begin					bCR;					NumRptPrompt := 4;					NewUserStage := CheckNewPass;					LettersPrompt(retinstr(18, 55), '', 9, false, false, true, 'X');					curprompt := '';				end;				CheckNewPass: 				begin					if EqualString(CurPrompt, IntSystRec.NewUserPass, false, false) then					begin						statChanged := true;						NumRptPrompt := 3;						NewUserStage := PromptHandle;						bCR;						ClearScreen;						if ReadTextFile('New User', 1, false) then						begin							BoardAction := ListText;							ListTextFile;						end						else						begin							BoardAction := none;							OutLine('NewUser file not found.', true, -1);						end;					end					else					begin						if numRptPrompt > 0 then						begin							if (numRptPrompt < 5) and (length(curPrompt) > 0) then								LogThis(concat('Wrong newuser password: ', curprompt), 6);							LettersPrompt(retinstr(18, 55), '', 9, false, false, true, 'X');							numRptPrompt := numRptPrompt - 1;						end						else						begin							if (length(curPrompt) > 0) then								LogThis(concat('Wrong newuser password: ', curprompt), 6);							HangupAndReset;						end;					end;				end;				PromptHandle: 				begin					if intSystRec.allowHandles then						OutLine(retinstr(18, 56), true, -1)					else						OutLine(retinstr(18, 57), true, -1);					bCR;					LettersPrompt(': ', '', 31, false, false, true, char(0));					NewUserStage := checkTrash;				end;				CheckTrash: 				begin					DoCapsName(curPrompt);					tempbool := FindUser(curPrompt, tempUser);					if not InTrash(curprompt) and not tempbool and (length(curPrompt) > 0) and ((curPrompt[1] > char(57)) or (curPrompt[1] < char(48))) then					begin						InitUserRec;						thisUser.UserName := curPrompt;						NewUserStage := RealName;					end					else					begin						OutLine(retinstr(18, 58), false, -1);						bCR;						NumRptPrompt := NumRptPrompt - 1;						if NumRptPrompt <> 0 then							NewUserStage := PromptHandle						else							HangupAndReset;					end;				end;				RealName: 				begin					if intSystRec.allowHandles then						OutLine(retinstr(18, 59), true, -1)					else						Outline(retinstr(18, 60), true, -1);					bCR;					LettersPrompt(': ', '', 21, false, false, false, char(0));					NewUserStage := NewPhone;				end;				NewPhone: 				begin					if length(curPrompt) > 0 then					begin						thisUser.RealName := CurPrompt;						if intSystRec.freePhone then						begin							OutLine(retinstr(18, 61), true, -1);						end						else						begin							OutLine(retinstr(18, 62), true, -1);							OutLine('  ###-###-####', true, 0);						end;						bCR;						LettersPrompt(': ', '', 12, false, false, true, char(0));						NewUserStage := Sex;					end					else					begin						OutLine(retinstr(18, 63), true, -1);						NewUserStage := Realname;					end;				end;				Sex: 				begin					if ((length(curprompt) = 12) and (CurPrompt[4] = '-') and (CurPrompt[8] = '-')) or (intSystRec.freePhone) then					begin						thisUser.phone := curPrompt;						bCR;						LettersPrompt(retinstr(18, 64), 'MF', 1, true, false, true, char(0));						NewUserStage := BirtMonth;					end					else					begin						NewUserStage := NewPhone;						CurPrompt := thisUser.realName;						OutLine(retinstr(18, 65), true, -1);						OutLine(retinstr(18, 66), true, -1);						bCR;					end;				end;				BirtMonth: 				begin					thisUser.sex := true;					if (curPrompt = 'F') then						thisUser.sex := false;					bCR;					NumbersPrompt(retinstr(18, 67), '', 12, 1);					NewUserStage := BirtDay;				end;				BirtDay: 				begin					if length(curprompt) > 0 then					begin						StringToNum(curPrompt, tempInt);						thisUser.birthMonth := char(tempint);						bCR;						NumbersPrompt(retinstr(18, 68), '', 31, 1);						NewUserStage := BirtYear;					end					else					begin						if thisUser.sex then							curPrompt := 'M'						else							curprompt := 'F';						NewUserStage := BirtMonth;					end;				end;				BirtYear: 				begin					StringToNum(curPrompt, tempInt);					if (tempint > 0) and (tempint < 32) then					begin						thisUser.birthDay := char(tempint);						bCR;						NumbersPrompt(retinstr(18, 69), '', 99, 1);						NewUserStage := ComputerType;					end					else					begin						NumToString(byte(thisUser.birthmonth), curPrompt);						NewUserStage := BirtDay;					end;				end;				ComputerType: 				begin					StringToNum(curPrompt, tempInt);					if (tempint > 19) and (tempint < 90) then					begin						thisUser.birthYear := char(tempInt);						bufferbCR;						yearsOld(thisUser);						bufferIt(retinstr(18, 70), true, -1);						bufferbCR;						i := 1;						GetIndString(tempString, 15, i);						repeat							NumToString(i, tempString2);							tempstring2 := concat(tempstring2, '. ', tempString);							i := i + 1;							if tempString <> '' then							begin								bufferIt(tempString2, true, -1);								GetIndString(tempString, 15, i);							end;						until (tempString = '');						bufferbCR;						bufferbCR;						bufferIt(retinstr(18, 71), false, -1);						bufferIt(retinstr(18, 72), true, -1);						bufferbCR;						ReleaseBuffer;						NumbersPrompt(': ', '', i - 1, 1);						NewUserStage := ScrnWd;					end					else					begin						OutLine('Invalid birthdate.', true, -1);						bCR;						NumToString(byte(thisUser.birthday), curPrompt);						newuserstage := birtyear;					end;				end;				ScrnWd: 				begin					stringToNum(curPrompt, tempint);					GetIndString(tempString, 15, tempInt);					if (length(tempString) > 0) then					begin						thisUser.computerType := tempString;						bCR;						OutLine(retinstr(18, 73), true, -1);						bCR;						Numbersprompt(': ', '', 199, 1);						NewUserStage := ScrnHg;					end					else					begin						tempInt := byte(thisUser.birthYear);						NumToString(tempInt, curprompt);						NewUserStage := ComputerType;					end;				end;				ScrnHg: 				begin					if length(curPrompt) = 0 then						thisUser.scrnWdth := 80					else					begin						StringToNum(curprompt, tempInt);						if tempInt < 20 then							tempInt := 20						else							thisUser.scrnWdth := tempInt;					end;					bCR;					OutLine(retinstr(18, 74), true, -1);					bCR;					NumbersPrompt(': ', '', 60, 1);					NewUserStage := TestANSI;				end;				TestANSI: 				begin					if length(curPrompt) = 0 then						thisUser.scrnHght := 24					else					begin						StringToNum(curprompt, tempInt);						thisUser.scrnHght := tempInt;					end;					if thisUser.scrnHght < 5 then						thisUser.scrnHght := 5;					bCR;					bCR;					OutANSItest;					bCR;					OutLine('Is the above line either colored, italicized,', false, 0);					bCR;					YesNoQuestion('bold, inversed, or blinking? ', false);					NewUserStage := CheckColor;				end;				CheckColor: 				begin					if curPrompt = 'Y' then						thisUser.canANSI := true					else						thisUser.canANSI := false;					bCR;					if thisUser.canANSI then					begin						YesNoQuestion('Do you want color? ', false);					end					else						curprompt := 'N';					NewUserStage := IsAllCorrect;				end;				IsAllCorrect: 				begin					if curPrompt = 'Y' then						thisUser.ANSIColor := true					else						thisUser.ANSIColor := false;					bufferbCR;					BufClearScreen;					bufferIt(retinstr(18, 75), true, 0);					bufferIt(thisUser.UserName, false, 0);					if intSystRec.allowHandles then						bufferIt(retinstr(18, 76), true, 0)					else						bufferIt(retinstr(18, 77), true, 0);					bufferIt(thisUser.RealName, false, 0);					bufferIt(retinstr(18, 78), true, 0);					bufferIt(thisUser.phone, false, 0);					bufferIt(retinstr(18, 79), true, 0);					if thisUser.sex then						bufferIt('Male', false, 0)					else						bufferIt('Female', false, 0);					NumToString(integer(thisUser.birthMonth), tempString);					tempString := concat(tempString, '/');					NumToString(integer(thisUser.birthDay), tempString2);					tempString := concat(tempString, tempString2, '/');					NumToString(integer(thisUser.birthYear), tempString2);					tempString := concat(tempString, tempString2);					bufferIt(concat('Birthdate     : ', tempString), true, 0);					bufferIt('Computer type : ', true, 0);					bufferIt(thisUser.computerType, false, 0);					numToString(thisuser.scrnWdth, tempstring);					numToString(thisUser.scrnHght, tempString2);					bufferIt(concat('Screen size   : ', tempString, ' X ', tempString2), true, 0);					bufferbCR;					bufferbCR;					ReleaseBuffer;					YesNoQuestion('Is this correct? ', false);					NewUserStage := PassQuest;				end;				PassQuest: 				begin					if (CurPrompt = 'Y') then					begin						bCR;						bCR;						bCR;						GetTime(TempDate);						NumToString(tempDate.second, tempString);						if length(tempString) < 2 then							tempString := concat(tempString, '0');						tempInt := (ABS(RANDOM) mod 25) + 1;						TempString[0] := char(6);						TempString[3] := char(tempInt + 65);						tempInt := (ABS(RANDOM) mod 25) + 1;						TempString[4] := char(tempInt + 65);						tempInt := (ABS(RANDOM) mod 25) + 1;						TempString[5] := char(tempInt + 65);						tempInt := (ABS(RANDOM) mod 25) + 1;						TempString[6] := char(tempInt + 65);						OutLine(concat('Random password: ', tempString), true, 0);						bCR;						bCR;						ThisUser.password := tempString;						YesNoQuestion('Enter new password (Y/N)? ', false);						NewUserStage := NewPassword;						thisUser.userNum := -1;					end					else					begin						numRptPrompt := 3;						NewUserStage := PromptHandle;					end;				end;				NewPassword: 				begin					if (CurPrompt = 'Y') then					begin						OutLine('Please enter a password, 3-9 chars.', true, 0);						bCR;						LettersPrompt(': ', '', 9, false, false, true, char(0));					end					else						curPrompt := thisUser.password;					newUserStage := GiveInfo;				end;				GiveInfo: 				begin					if length(curPrompt) > 2 then					begin						OutLine('Please wait...', true, 0);						if thisUser.userNum = -1 then						begin							thisUser.Password := curPrompt;							if myUsers = nil then							begin								myUsers := UListHand(NewHandle(0));								MoveHHi(handle(myUsers));								HNoPurge(handle(myUsers));							end;							tempshort := 1;							gotIt := false;							while (tempshort <= numUserRecs) and not gotIt do							begin								if myUsers^^[tempShort - 1].dltd then									gotIt := true								else									tempShort := tempShort + 1;							end;							if not gotIt then							begin								SetHandleSize(handle(myusers), getHandleSize(handle(myUsers)) + SizeOf(ULR));								numUserRecs := numUserRecs + 1;								tempShort := numUserRecs;							end;							thisUser.userNum := tempShort;							myUsers^^[tempshort - 1].UName := thisUser.UserName;							myUsers^^[tempshort - 1].dltd := false;							myUsers^^[tempshort - 1].real := thisUser.realName;							GetDateTime(myUsers^^[tempshort - 1].last);							myUsers^^[tempshort - 1].SL := thisUser.secLevel;							myUsers^^[tempshort - 1].DSL := thisUser.transferLevel;							myUsers^^[tempshort - 1].first := thisUser.firstOn;							IntSystRec.numUsers := IntSystRec.numUsers + 1;							doSystRec(true);							WriteUser(thisUser);						end;						timebegin := tickCount;						bCR;						NumToString(thisUser.userNum, tempString);						OutLine(concat('Your user number is ', tempString, '.'), true, 0);						OutLine(concat('Your password is ''', thisUser.password, ''''), true, 0);						bCR;						bCR;						OutLine('Please write down this information, and', false, 0);						OutLine('re-enter your password for verification.', true, 0);						OutLine('You will need to know this password in', true, 0);						OutLine('order to log on again.', true, 0);						bCR;						bCR;						LettersPrompt(retinstr(17, 18), '', 9, false, false, true, char(0));						NewUserStage := NewTransition;					end					else					begin						OutLine('Your password must be more than three characters.', true, 0);						NewUserStage := NewPassword;						curPrompt := 'Y';					end;				end;				NewTransition: 				begin					if CurPrompt = thisUser.password then					begin						GetDateTime(templong);						IUDateString(templong, shortDate, tempstring);						IUTimeString(tempLong, true, tempstring2);						tempstring := concat(tempstring, ' ', tempstring2);						NumToString(currentBaud, tempString2);						sysopLog(concat('###   NEW USER  ', tempString2, '  ', tempString), 0);						bCR;						if readTextFile('Feedback', 1, false) then						begin							boardAction := ListText;							ListTextFile;						end						else							OutLine('Can''t find ''Feedback'' file.', true, 0);						NewUserStage := TwoTrans;					end					else					begin						NewUserStage := GiveInfo;						OutLine('Please enter your password correctly.', true, 0);						curPrompt := thisUser.password;					end;				end;				TwoTrans: 				begin					CurPrompt := '1';					if FindUser(curPrompt, tempuser) then					begin						BoardSection := EMail;						EmailDo := EmailOne;						CurPrompt := '1';						sentAnon := false;						callFMail := false;						newFeed := true;					end;				end;				otherwise			end;		end;	end;end.