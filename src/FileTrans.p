unit FileTrans;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, FileTrans2, inpOut2, InpOut, User, terminal, SystemPrefs, Message_Editor, NodePrefs;	procedure DoUpload;	procedure DoGFiles;	procedure ListFil;	procedure DoDownload;	function GetProtMenStr: str255;	procedure DoSort;	procedure PrintUserDefaults;	procedure ReadAutoMessage;	procedure enterLastUser;	procedure MamaPrompt (var MaPro: str255);	procedure OutANSItest;	procedure doKillMail;	procedure ScanOpenFiles;	function isDAWindow (window: WindowPtr): BOOLEAN;	function isAppWindow (window: WindowPtr): BOOLEAN;	procedure AdjustCursor (mouse: Point; region: RgnHandle);	procedure GetGlobalMouse (var mouse: Point);implementation	function isDAWindow (window: WindowPtr): BOOLEAN;	begin		if window = nil then			IsDAWindow := FALSE		else			IsDAWindow := (WindowPeek(window)^.windowKind < 0);	end;	function isAppWindow (window: WindowPtr): BOOLEAN;	begin		if window = nil then			IsAppWindow := FALSE		else			with WindowPeek(window)^ do				IsAppWindow := (windowKind = userKind);	end;	procedure GetGlobalMouse (var mouse: Point);		var			event: EventRecord;	begin		if OSEventAvail(kNoEvents, event) then			;	{we aren't interested in any events}		mouse := event.where;					{just the mouse position}	end;	procedure AdjustCursor (mouse: Point; region: RgnHandle);{Change the cursor's shape, depending on its position. This also calculates the region}{ where the current cursor resides (for WaitNextEvent). If the mouse is ever outside of}{ that region, an event is generated, causing this routine to be called. This}{ allows us to change the region to the region the mouse is currently in. If}{ there is more to the event than just Òthe mouse movedÓ, we get called before the}{ event is processed to make sure the cursor is the right one. In any (ahem) event,}{ this is called again before we fall back into WNE.}		var			window: WindowPtr;			arrowRgn: RgnHandle;			iBeamRgn: RgnHandle;			crossHairRgn: rgnHandle;			iBeamRect: Rect;			windI: integer;	begin		window := FrontWindow;	{we only adjust the cursor when we are in front}		if (not gInBackground) and (not IsDAWindow(window)) then		begin		{calculate regions for different cursor shapes}			arrowRgn := NewRgn;			iBeamRgn := NewRgn;		{start with a big, big rectangular region}			SetRectRgn(arrowRgn, -32767, -32767, 32765, 32765);		{calculate iBeamRgn}			windI := isMyTextWindow(window);			if IsAppWindow(window) and (windI >= 0) then			begin				with textWinds[windI] do				begin					iBeamRect := t^^.viewRect;					SetPort(w);					{make a global version of the viewRect}					with iBeamRect do					begin						LocalToGlobal(topLeft);						LocalToGlobal(botRight);					end;					RectRgn(iBeamRgn, iBeamRect);					with w^.portBits.bounds do						SetOrigin(-left, -top);					SectRgn(iBeamRgn, w^.visRgn, iBeamRgn);					SetOrigin(0, 0);				end;			end;			windI := ismyBBSwindow(window);			if isAppWindow(window) and (windI >= 1) then			begin				iBeamRect := gBBSwindows[windI]^.ansiRect;				SetPort(window);				with iBeamRect do				begin					LocalToGlobal(topLeft);					LocalToGlobal(botRight);				end;				RectRgn(iBeamRgn, iBeamRect);				with window^.portBits.bounds do					SetOrigin(-left, -top);				SetOrigin(0, 0);			end;		{subtract other regions from arrowRgn}			DiffRgn(arrowRgn, iBeamRgn, arrowRgn);		{change the cursor and the region parameter}			if PtInRgn(mouse, iBeamRgn) then			begin				SetCursor(GetCursor(iBeamCursor)^^);				CopyRgn(iBeamRgn, region);			end			else			begin				SetCursor(arrow);				CopyRgn(arrowRgn, region);			end;		{get rid of our local regions}			DisposeRgn(arrowRgn);			DisposeRgn(iBeamRgn);		end;	end; {AdjustCursor}	procedure ScanOpenFiles;		var			myFCBPBRec: FCBPBRec;			t1: str255;	begin		with myFCBPBRec do		begin			ioCompletion := nil;			ioNamePtr := @t1;			ioVRefNum := 0;			ioRefNum := 0;			ioFCBIndx := 1;		end;		repeat			result := PBGetFCBInfo(@myFCbPBRec, false);			myFCbPBRec.ioFCBIndx := myFCbPBRec.ioFCBIndx + 1;		until result <> noerr;	end;	procedure FindEmailKill;		var			i: integer;			numOfEm: integer;	begin		with curGlobs^ do		begin			if myEmailList <> nil then				SetHandleSize(handle(myEmailList), 0)			else				myEmailList := intListHand(NewHandle(0));			HNoPurge(handle(myEmailList));			if (theEmail <> nil) and (availEmails > 0) then			begin				numOfEm := 0;				for i := 1 to availEmails do				begin					if (theEmail^^[i - 1].fromUser = thisUser.userNum) and (theEmail^^[i - 1].MType = 1) then					begin						numOfEm := numOfEm + 1;						SetHandleSize(handle(myEmailList), getHandleSize(handle(myEmailList)) + 2);						myEmailList^^[numOfEm - 1] := i - 1;					end;				end;			end;		end;	end;	procedure doKillMail;		var			t1: str255;			templong: longint;			totEm: integer;			printEmail: emailrec;	begin		with curglobs^ do		begin			case KillDo of				KillOne: 				begin					YesNoQuestion('List mail starting at most recent? ', true);					KillDo := KillTwo;				end;				KillTwo: 				begin					FindEmailKill;					totEm := GetHandleSize(handle(myEmailList)) div 2;					atEmail := 0;					if totEm > 0 then					begin						if curPrompt = 'Y' then						begin							atEmail := totEm - 1;							crossInt3 := 1;						end						else						begin							atEmail := 0;							crossInt3 := -1;						end;						KillDo := KillThree;					end					else					begin						OutLine('No mail.', true, 0);						goHome;					end;				end;				KillThree: 				begin					FindEmailKill;					printEmail := theEmail^^[myEmailList^^[atEmail]];					bCR;					NumToString(printEmail.toUser, t1);					if not printEmail.anonyTo then						OutLine(concat('To   : ', myUsers^^[printEmail.toUser - 1].Uname, ' #', t1), true, 0)					else						OutLine('To   : <<UNKNOWN>>', true, 0);					OutLine(concat('Title: ', printEmail.title), true, 0);					getDateTime(templong);					templong := (tempLong - printEmail.dateSent) div 60 div 60 div 24;					NumToString(templong, t1);					OutLine(concat('Sent : ', t1, ' days ago.'), true, 0);					bCR;					bCR;					LettersPrompt('R:ead, D:elete, N:ext, Q:uit : ', 'RDNQ', 1, true, false, true, char(0));					KillDo := KillFour;				end;				KillFour: 				begin					if length(curprompt) > 0 then					begin						case curPrompt[1] of							'Q': 								GoHome;							'D': 							begin								FindEmailKill;								DeleteMail(myEmailList^^[atEmail]);								OutLine('Mail deleted.', true, 0);								SysopLog('      Deleted mail.', 0);								FindEmailKill;								totEm := GetHandleSize(handle(myEmailList)) div 2;								if totEm > 0 then								begin									if crossInt3 < 0 then										atEmail := atEmail + 1									else										atEmail := atEmail - 1;									KillDo := KillThree;									if (atEmail < 0) or (atEmail > totEm - 1) then										GoHome;								end								else									GoHome;							end;							'N': 							begin								FindEmailKill;								totEm := GetHandleSize(handle(myEmailList)) div 2;								if crossInt3 < 0 then									atEmail := atEmail + 1								else									atEmail := atEmail - 1;								KillDo := KillThree;								if (atEmail < 0) or (atEmail > totEm - 1) then									GoHome;							end;							'R': 							begin								if textHnd <> nil then								begin									disposHandle(handle(textHnd));									texthnd := nil;								end;								FindEmailKill;								Outline(concat('Title: ', theEmail^^[myEmailList^^[atEmail]].title), true, 0);								bCR;								textHnd := textHand(ReadMessage(TRUE, theEmail^^[myEmailList^^[atEmail]].storedAs, 0, 0));								if textHnd <> nil then								begin									curtextPos := 0;									OpenTextSize := GethandleSize(handle(textHnd));									BoardAction := ListText;									ListTextFile;								end								else									OutLine('Message not found.', true, 0);								KillDo := KillFive;							end;							otherwise								KillDo := KillThree;						end;					end					else						KillDo := KillThree;				end;				KillFive: 				begin					bCR;					bCR;					LettersPrompt('R:ead, D:elete, N:ext, Q:uit : ', 'RDNQ', 1, true, false, true, char(0));					KillDo := KillFour;				end;				otherwise			end;		end;	end;	procedure OutANSItest;	begin		ansiCode('0;34;3m');		OutLine('TEST', false, -1);		ansiCode('C');		ansiCode('0;30;45m');		OutLine('TEST', false, -1);		ansiCode('C');		ansiCode('0;1;31;44m');		OutLine('TEST', false, -1);		ansiCode('C');		ansiCode('0;32;7m');		OutLine('TEST', false, -1);		ansiCode('C');		ansiCode('0;1;5;33;46m');		OutLine('TEST', false, -1);		ansiCode('C');		ansiCode('0;4m');		Outline('TEST', false, -1);		ansiCode('0m');	end;	procedure MamaPrompt (var MaPro: str255);		var			tempString, tempString2, tempString3: str255;			tb2: boolean;	begin		with curglobs^ do		begin			if not inTransfer then			begin				HelpNum := 1;				MaPro := '[] No Subs Available :';				if thisUser.msgFrmAccess[inForum] then				begin					if intMessStuff^^.numBoards[inForum] >= inSub then					begin						tb2 := true;						if intMessStuff^^.boards[inforum, inSub].restrict <> char(0) then							if thisUser.restrics[(byte(intMessStuff^^.boards[inforum, inSub].restrict) - byte(64))] then								tb2 := true							else								tb2 := false;						if tb2 and (intMessStuff^^.Boards[inForum, inSub].SLtoRead <= thisUser.SecLevel) and (intMessStuff^^.boards[inforum, insub].minage <= thisUser.age) then						begin							NumToString(inSub, tempString);							tempString3 := IntMessStuff^^.Boards[inForum, inSub].name;							maPro := concat('[', tempString, '] [', tempString3, '] :');						end;					end;				end;			end			else			begin				HelpNum := 2;				MaPro := '() No Dirs Available :';				if intDLStuff^^.numDirs > inDir then				begin					tb2 := true;					if intDLStuff^^.dr[inDir].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[inDir].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (intDLStuff^^.dr[inDir].minDSL <= thisUser.transferLevel) and (thisUser.age >= intDLStuff^^.dr[inDir].minAge) then					begin						NumToString(inDir, tempString);						tempString3 := IntDLStuff^^.dr[inDir].DirName;						MAPRO := concat('(', tempstring, ')-(', tempString3, ') :');					end;				end;			end;		end;	end;	procedure DoGFiles;		var			i, index, B: integer;			t1: str255;			tl: longint;			myCPB: CInfoPBRec;			myHPB: HParamBlockRec;			fName: str255;	begin		with curglobs^ do		begin			case GFileDo of				G1: 				begin					if intGFileHand^^.numSecs > 0 then					begin						helpNum := 34;						OutLine('G-File sections available:', true, 0);						bCR;						b := 0;						for i := 1 to intGFileHand^^.numSecs do						begin							if (intGFileHand^^.sections[i].minSL <= thisUser.secLevel) and (intGFileHand^^.sections[i].minAge <= thisUser.age) then							begin								b := b + 1;								NumToString(b, t1);								OutLine(concat(t1, ': ', intGFileHand^^.sections[i].secName), true, 0);							end;						end;						GFileDo := G2;					end					else					begin						OutLine('No G-File sections available.', true, 0);						GoHome;					end;				end;				G2: 				begin					bCR;					bCR;					NumbersPrompt('Which section (Q=Quit) ? ', 'Q?', intGFileHand^^.numSecs, 1);					GFileDo := G3;				end;				G3: 				begin					if curPrompt = '?' then						GFileDo := G1					else if (length(curPrompt) > 0) and (curprompt <> 'Q') then					begin						StringToNum(curprompt, tl);						i := 1;						b := 0;						while (i <= intGFileHand^^.numSecs) and (b <> tl) do						begin							if (intGFileHand^^.sections[i].minSL <= thisUser.secLevel) and (intGFileHand^^.sections[i].minAge <= thisUser.age) then								b := b + 1;							i := i + 1;						end;						tl := i - 1;						if (tl > 0) and (tl <= intGFileHand^^.numSecs) and (intGFileHand^^.sections[tl].minSL <= thisUser.secLevel) and (intGFileHand^^.sections[tl].minAge <= thisUser.age) then						begin							crossInt := tl;							GFileDo := G4;						end						else						begin							GFileDo := G2;							OutLine('Invalid section.', true, 0);						end;					end					else					begin						GoHome;					end;				end;				G4: 				begin					bCR;					OutLine(concat('G-Files in ', intGFileHand^^.sections[crossInt].secName, ':'), true, 0);					bCR;					fName := concat(sharedPath, 'GFiles:', intGFileHand^^.sections[crossInt].secName, ':');					myHPB.ioCompletion := nil;					myHPB.ioNamePtr := @fName;					myHPB.ioVRefNum := 0;					myHPB.ioVolIndex := -1;					result := PBHGetVInfo(@myHPB, false);					fName := concat(sharedPath, 'GFiles:', intGFileHand^^.sections[crossInt].secName, ':');					myCPB.ioCompletion := nil;					myCPB.ioNamePtr := @fname;					myCPB.ioVRefNum := myHPB.ioVRefNum;					myCPB.ioFDirIndex := 0;					result := PBGetCatInfo(@myCPB, false);					myCPB.ioNamePtr := @fName;					crossLong := myCPB.ioDrDirID;					crossInt2 := myHPB.ioVRefNum;					index := 1;					repeat						FName := '';						myCPB.ioFDirIndex := index;						myCPB.ioDrDirID := crossLong;						myCPB.ioVrefNum := crossInt2;						result := PBGetCatInfo(@myCPB, FALSE);						if result = noErr then						begin							NumToString(index, t1);							OutLine(concat(' ', t1, ': ', fName), true, 0);						end;						index := index + 1;					until (result <> noErr);					GFileDo := G5;				end;				G5: 				begin					bCR;					bCR;					NumbersPrompt('Which G-File (Q=Quit) ? ', 'Q?', 99, 1);					GFileDo := G6;				end;				G6: 				begin					if curprompt = '?' then						GFileDO := G4					else if (curprompt <> '') and (curprompt <> 'Q') then					begin						GFileDo := G5;						StringToNum(curPrompt, tl);						index := tl;						if (index > 0) and (index < 100) then						begin							myCPB.ioCompletion := nil;							myCPB.ioNamePtr := @fName;							myCPB.ioFDirIndex := index;							myCPB.ioDrDirID := crossLong;							myCPB.ioVrefNum := crossInt2;							result := PBGetCatInfo(@myCPB, FALSE);							if result = noErr then							begin								if readTextFile(concat(sharedPath, 'GFiles:', intGFileHand^^.sections[crossInt].secName, ':', fName), 0, false) then									BoardAction := ListText								else									OutLine('File not found.', true, 0);							end;						end;					end					else						GFileDo := G2;				end;				otherwise			end;		end;	end;	procedure enterLastUser;		var			t2, t1, tempString, tempString2: str255;			templong, tl2, tl3: longint;			tempDate: DateTimeRec;			i: integer;			luRef, luCount: integer;			luText: CharsHandle;	begin		with curglobs^ do		begin			if thisUser.userNum > 1 then			begin				LUText := nil;				t1 := concat(sharedpath, 'Last Users');				result := FSOpen(t1, 0, luRef);				if (result <> noErr) then				begin					result := Create(t1, 0, 'HRMS', 'DATA');					result := FSOpen(t1, 0, luRef);					t1 := '';					t2 := '0: ';					t2[3] := char(13);					for i := 1 to 8 do						t1 := concat(t2, t1);					templong := length(t1);					result := FSWrite(luref, templong, @t1[1]);					result := SetFPos(luref, fsFromStart, 0);				end;				if result = noErr then				begin					LUcount := 0;					result := GetEOF(luRef, tempLong);					LUtext := CharsHandle(NewHandle(tempLong));					HLock(handle(LUtext));					result := FSRead(luRef, tempLong, pointer(LUtext^));					repeat						LUcount := LUcount + 1;					until (LUtext^^[LUcount] = char(13)) or (LUcount = tempLong);					NumToString(intSystRec.numCalls, tempString);					NumToString(thisUser.UserNum, tempString2);					tempString := concat(tempString, ': ', thisUser.UserName, ' #', tempstring2);					GetTime(tempDate);					NumToString(tempDate.hour, tempString2);					tempString := concat(tempString, ' ', tempString2, ':');					NumToString(tempDate.minute, tempString2);					if length(tempString2) = 1 then						tempstring2 := concat('0', tempstring2);					tempString := concat(tempString, tempString2, ':');					NumToString(tempDate.second, tempString2);					if length(tempString2) = 1 then						tempstring2 := concat('0', tempstring2);					tempString := concat(tempString, tempString2, '    ');					if currentBaud > 0 then						tempString2 := curBaudNote					else						tempString2 := 'KB';					tempString := concat(tempString, tempString2, ' - ');					NumToString(thisUser.onToday, tempString2);					tempString := concat(tempString, tempString2, char(13));					result := SetFPos(luRef, fsFromStart, 0);					tl3 := tempLong - (LUcount + 1);					result := FSWrite(luRef, tl3, pointer(ord4(LUtext^) + (LUcount + 1)));					tl2 := length(tempString);					result := FSWrite(luRef, tl2, pointer(ord4(@tempstring) + 1));					result := SetEOF(luRef, tl3 + tl2);					result := FSClose(luRef);					DisposHandle(handle(LUText));					result := FSOpen(concat(sharedPath, 'Brief Log'), 0, luRef);					if result = noErr then					begin						result := GetEOF(luRef, tempLong);						result := SetFPos(luRef, fsFromLEOF, 0);						result := FSWrite(luRef, tl2, pointer(ord4(@tempstring) + 1));						result := FSClose(luRef);					end;				end;			end;		end;	end;	procedure ReadAutoMessage;		var			tempString, tempString2: str255;			result: OSerr;			tempInt, AutoRef: integer;	begin		with curglobs^ do		begin			if intSystRec.AnonyAuto and not IntSystRec.SecLevels[thisUser.SecLevel].readAnon then				tempString := '>UNKNOWN<'			else			begin				NumToString(IntSystRec.anonyUser, tempString2);				if FindUser(tempString2, tempUser) then				begin					NumToString(tempUser.UserNum, tempString2);					tempString := concat(tempUser.UserName, ' #', tempString2);				end				else					tempString := '>>>USER NOT FOUND<<<';			end;			if intSystRec.AnonyAuto and IntSystRec.SecLevels[thisUser.SecLevel].readAnon then				tempString := concat('<<< ', tempString, ' >>>');			OutLine(concat('Auto message by: ', tempString), false, 0);			bCR;			bCR;			if ReadTextFile('Auto Message', 0, true) then			begin				boardAction := ListText;				listTextFile;			end			else				OutLine('No auto-message.', true, 0);		end;	end;	procedure PrintUserDefaults;		var			tempString, tempString2: str255;			tempUser: UserRec;	begin		with curglobs^ do		begin			bufferbCR;			BufClearScreen;			NumToString(thisUser.scrnWdth, tempString);			NumToString(thisUser.scrnHght, tempString2);			bufferIt(concat('1.  Screen size       : ', tempString, ' X ', tempString2), false, 0);			if thisUser.canANSI then			begin				if thisUser.ANSIcolor then					tempString := 'Color'				else					tempString := 'Monochrome';			end			else				tempString := 'No ANSI';			bufferIt(concat('2.  ANSI              : ', tempString), true, 0);			if thisUser.PauseScreen then				tempString2 := 'Yes'			else				tempString2 := 'No';			bufferIt(concat('3.  Pause on screen   : ', tempString2), true, 0);			if thisUser.Mailbox then			begin				NumToString(thisUser.ForwardedTo, tempString2);				if FindUser(tempString2, tempUser) then				begin					NumToString(tempUser.UserNum, tempString);					tempString2 := concat('[F]', tempUser.UserName, ' #', tempString);				end				else				begin					thisUser.MailBox := false;					tempString2 := 'Normal';				end;			end			else				tempString2 := 'Normal';			bufferIt(concat('4.  Mailbox           : ', tempString2), true, 0);			if thisuser.screenClears then				tempString2 := 'Yes'			else				tempstring2 := 'No';			bufferIt(concat('5.  Screen Clears     : ', tempString2), true, 0);			bufferIt('6.  Configure Q-scan', true, 0);			bufferIt('7.  Change password', true, 0);			if thisuser.notifyLogon then				tempString2 := 'Yes'			else				tempString2 := 'No';			bufferIt(concat('8.  Notify login/out  : ', tempString2), true, 0);			bufferIt(concat('9.  Computer type     : ', thisUser.computerType), true, 0);			if thisUser.canANSI then				bufferIt('10. Change colors', true, 0);			bufferIt('Q.  Quit to main menu', true, 0);			ReleaseBuffer;		end;	end;	function NumFilesinDir (dirNum: integer): integer;		var			templong: longInt;			tempRef: integer;			result: OSerr;			tempString: str255;	begin		NumToString(dirNum, tempString);		result := FSOpen(concat(sharedPath, 'Data:', intDLStuff^^.dr[dirNum].dirname), 0, tempRef);		if result = noErr then		begin			result := GetEOF(tempRef, tempLong);			result := FSClose(tempRef);			numFilesinDir := tempLong div SizeOf(filEntryRec);		end		else			NumFilesInDir := 0;	end;	procedure ListFil;		var			tempInt, i: integer;			tempFile: filEntryRec;			tempString, s2, s3: Str255;			tb2: boolean;	begin		with curglobs^ do		begin			case ListDo of				ListOne: 				begin					tb2 := true;					if intDLStuff^^.dr[inDir].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[inDir].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.transferLevel >= intDLStuff^^.dr[inDir].minDSL) and (thisUser.age >= intDLStuff^^.dr[inDir].minAge) then					begin						CloseDirectory;						bCR;						HelpNum := 9;						LettersPrompt('File mask: ', '', intDLStuff^^.dr[inDir].fileNameLength, false, false, false, char(0));						ListDo := ListTwo;						inNScan := false;					end					else					begin						OutLine('No directory available.', true, 0);						GoHome;					end;				end;				ListTwo: 				begin					UprString(curPrompt, true);					fileMask := curPrompt;					tempDir := inDir;					ListDo := ListThree;					allDirSearch := false;					descSearch := false;					flsListed := 0;				end;				ListThree: 				begin					curDirPos := 0;					if OpenDirectory(tempDir) then						;					ListDo := ListFour;					curTextPos := 0;					fListedCurDir := 0;				end;				ListFour: 				begin					BoardAction := repeating;					if (myBlocker.ioResult <> 1) or (curTextPos = -100) then					begin						if not inNScan then							GetNextFile(tempDir, fileMask, curDirPos, tempFile, 0)						else						begin							if intDLStuff^^.dr[tempDir].mode = 0 then								GetNextFile(tempDir, fileMask, curDirPos, tempFile, lastFScan)							else if intDLStuff^^.dr[tempDir].mode = -1 then								tempFile.flName := ''							else								GetNextFile(tempDir, fileMask, curDirPos, tempFile, 0);						end;						if (tempFile.flName <> '') then						begin							fListedCurDir := fListedCurDir + 1;							flsListed := flsListed + 1;							if fListedCurDir = 1 then							begin								bufferbCR;								NumToString(tempDir, s2);								NumToString(curNumFiles, s3);								tempString := concat(intDLStuff^^.dr[tempDir].dirName, ' - #', s2, ', ', s3, ' files');								S2 := '';								for i := 1 to length(tempString) do									s2 := concat(s2, '=');								bufferIt(tempString, true, 2);								bufferIt(s2, true, 2);								bufferbCR;							end;							s3 := tempFile.flName;							if length(S3) < intDLStuff^^.dr[tempDir].fileNameLength then								for i := length(s3) to (intDLStuff^^.dr[tempDir].fileNameLength - 1) do									s3 := concat(s3, ' ');							if length(S3) > intDLStuff^^.dr[tempDir].fileNameLength then							begin								s3[intDLStuff^^.dr[tempDir].fileNameLength] := '*';								s3[0] := char(intDLStuff^^.dr[tempDir].fileNameLength);							end;							if tempFile.fileStat <> 'F' then							begin								tempInt := tempFile.byteLen div 1024;								if (tempInt < 1) and (tempFile.bytelen <> 0) then								begin									tempInt := 1;									NumToString(tempInt, s2);									s2 := concat(s2, 'k+');								end								else if (tempFile.byteLen = -1) then									s2 := 'ASK'								else								begin									NumToString(tempInt, s2);									s2 := concat(s2, 'k+');								end;								if length(s2) < 7 then									for i := length(s2) to 7 do										s2 := concat(' ', s2);							end							else							begin								s2 := 'U/L FRAG';							end;							tempString := tempFile.flDesc;							bufferIt(s3, true, 1);							bufferIt(':', false, 2);							bufferIt(s2, false, 3);							bufferIt(':', false, 2);							i := length(tempstring) + 10 + intDLStuff^^.dr[tempDir].fileNameLength;							if i > 80 then								delete(tempstring, length(tempstring) - (i - 80), i - 80);							bufferIt(tempString, false, 5);							if (thisUser.extendedLines > 0) and (tempFile.hasExtended) then							begin								ReadExtended(tempFile, tempDir);								if curWriting <> nil then								begin									PrintExtended(true);								end;							end;						end						else						begin							if (not allDirSearch) or (curtextPos = -100) then							begin								NumToString(flsListed, s2);								bufferbCR;								bufferbCR;								bufferIt(concat('Files listed: ', s2), true, 2);								inNScan := false;								GoHome;							end							else							begin								tempDir := tempDir + 1;								tb2 := true;								if intDLStuff^^.dr[tempDir].restriction <> char(0) then									if thisUser.restrics[(byte(intDLStuff^^.dr[tempDir].restriction) - byte(64))] then										tb2 := true									else										tb2 := false;								while not tb2 or ((thisUser.age < intDLStuff^^.dr[tempDir].minAge) or (intDLStuff^^.dr[tempDir].minDSL > thisUser.transferlevel)) and (tempDir <= intDLStuff^^.numDirs) do								begin									tempDir := tempDir + 1;									tb2 := true;									if intDLStuff^^.dr[tempDir].restriction <> char(0) then										if thisUser.restrics[(byte(intDLStuff^^.dr[tempDir].restriction) - byte(64))] then											tb2 := true										else											tb2 := false;								end;								tb2 := true;								if intDLStuff^^.dr[tempDir].restriction <> char(0) then									if thisUser.restrics[(byte(intDLStuff^^.dr[tempDir].restriction) - byte(64))] then										tb2 := true									else										tb2 := false;								if tb2 and (tempDir < intDLStuff^^.numDirs) and (intDLStuff^^.dr[tempDir].minDSL <= thisUser.transferlevel) and (thisUser.age >= intDLStuff^^.dr[tempDir].minAge) then								begin									ListDo := ListThree;								end								else								begin									NumToString(flsListed, s2);									bufferbCR;									bufferbCR;									bufferIt(concat('Files listed: ', s2), true, 2);									inNScan := false;									GoHome;								end;							end;						end;						ReleaseBuffer;					end;				end;				ListFive: 				begin					tb2 := true;					if intDLStuff^^.dr[inDir].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[inDir].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.transferLevel >= intDLStuff^^.dr[inDir].minDSL) and (thisUser.age >= intDLStuff^^.dr[inDir].minAge) then					begin						inNScan := true;						fileMask := '';						flsListed := 0;						fListedCurDir := 0;						descSearch := false;						if curprompt = 'Y' then							allDirSearch := true						else							allDirSearch := false;						if (thisUser.coSysop) and allDirSearch then							tempDir := 0						else if allDirSearch then							tempDir := 1						else							tempDir := inDir;						GetDateTime(thisUser.lastFileScan);						ListDo := ListThree;					end					else					begin						OutLine('No Directory available.', true, 0);						gohome;					end;				end;				ListSix: 				begin					tb2 := true;					if intDLStuff^^.dr[inDir].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[inDir].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.transferLevel >= intDLStuff^^.dr[inDir].minDSL) and (thisUser.age >= intDLStuff^^.dr[inDir].minAge) then					begin						inNScan := false;						fileMask := curPrompt;						flsListed := 0;						fListedCurDir := 0;						descSearch := false;						allDirSearch := true;						if (thisUser.coSysop) and allDirSearch then							tempDir := 0						else if allDirSearch then							tempDir := 1;						ListDo := ListThree;					end					else					begin						OutLine('No Directory available.', true, 0);						gohome;					end;				end;				ListSeven: 				begin					tb2 := true;					if intDLStuff^^.dr[inDir].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[inDir].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.transferLevel >= intDLStuff^^.dr[inDir].minDSL) and (thisUser.age >= intDLStuff^^.dr[inDir].minAge) then					begin						inNScan := false;						fileMask := curPrompt;						flsListed := 0;						fListedCurDir := 0;						allDirSearch := true;						descSearch := true;						if (thisUser.coSysop) then							tempDir := 0						else							tempDir := 1;						ListDo := ListThree;					end					else					begin						OutLine('No Directory available.', true, 0);						gohome;					end;				end;				otherwise			end;		end;	end;	function GetProtMenStr: str255;		var			tempString: str255;	begin		with curglobs^ do		begin			if (thisUser.defaultProtocol > 0) and (thisUser.defaultProtocol <= theProts^^.numProtocols) then			begin				tempstring := theProts^^.prots[thisUser.defaultProtocol].ProtoName;				GetProtMenStr := concat('Protocol (?=list, <C/R>=', tempstring, ') : ');			end			else				GetProtMenStr := concat('Protocol (?=list) : ')		end;	end;	procedure DoUpload;		var			abg: point;			dere: SFtypeList;			repo: SFReply;			tempFName, tempString, tempstring2: str255;			NoteDilg: Dialogptr;			result: OSerr;			i, tempint: integer;			templong: longInt;			fragged: boolean;	begin		with curglobs^ do		begin			case UploadDo of				UpOne: 				begin					HelpNum := 17;					descSearch := false;					if numFilesInDir(tempinDir) >= intDLStuff^^.dr[tempInDir].maxFiles then					begin						OutLine('This directory is currently full.', true, 0);						bCR;						GoHome;						exit(doUpload);					end;					if (thisUser.transferlevel < intDLStuff^^.dr[tempInDir].DSLtoUL) then					begin						OutLine('Uploads are not allowed to this directory.', true, 0);						bCR;						GoHome;						exit(doUpload);					end;					tempLong := (FreeK(intDLStuff^^.dr[tempinDir].path) div 1024);					NumToString(tempLong, tempString);					OutLine(concat('Upload - ', tempString, 'K free.'), true, 0);					bCR;					if tempLong < 250 then					begin						OutLine(retinstr(17, 64), true, 0);						bCR;						GoHome;						exit(doUpload);					end;					bCR;					if readTextFile('Upload Message', 1, false) then					begin						BoardAction := ListText;						ListTextFile;					end;					UploadDo := UpTwo;				end;				UpTwo: 				begin					bCR;					LettersPrompt('Filename: ', '', intDLStuff^^.dr[tempinDir].fileNameLength, false, false, false, char(0));					ANSIPrompter(intDLStuff^^.dr[tempinDir].fileNameLength);					UploadDo := UpThree;				end;				UpThree: 				begin					if (length(curprompt) > 0) then					begin						if (pos(':', curprompt) = 0) and (pos('.', curPrompt) <> 1) and (pos('/', curprompt) = 0) then						begin							curFil.flName := curPrompt;							curFil.realFName := curprompt;							GetDateTime(curFil.whenUL);							curFil.uploaderName := thisUser.UserName;							curFil.uploaderNum := thisUser.userNum;							curFil.numDLoads := 0;							curFil.hasExtended := false;							curFil.fileStat := char(0);							curFil.lastDL := 0;							for i := 1 to 4 do								curFil.reserved[i] := char(0);							bCR;							bCR;							YesNoQuestion(concat('Upload ''', curprompt, ''' to ', intDLStuff^^.dr[tempinDir].dirName, '? '), false);							UploadDo := UpFour;						end						else						begin							GoHome;							OutLine('Illegal character in filename.', true, 0);						end;					end					else					begin						OutLine('File transmission aborted.', true, 0);						GoHome;					end;				end;				UpFour: 				begin					if (curprompt = 'Y') then					begin						if (pos(':', curFil.realFName) = 0) then							tempstring := concat(intDLStuff^^.dr[tempinDir].path, curFil.realFname)						else							tempstring := curFil.realFName;						fragged := FragFile(tempstring);						if FExist(tempstring) and not fragged then						begin							bCR;							OutLine('That file is already here.', true, 0);							GoHome;							exit(doUpload);						end						else						begin							if fragged then							begin								bCR;								OutLine('Completing fragmented upload...', true, 2);								bCR;							end;							curPrompt := 'Y';							uploadDo := upFive;							if fragged then								uploadDo := upSeven;						end;					end					else						GoHome;				end;				UpFive: 				begin					if curPrompt = 'Y' then					begin						OutLine('Please enter a one line description.', true, 0);						bCR;						LettersPrompt(': ', '', 70 - intDLStuff^^.dr[tempinDir].fileNameLength, false, false, false, char(0));						ANSIPrompter(70 - intDLStuff^^.dr[tempinDir].fileNameLength);						UploadDo := UpSix;					end					else						GoHome;				end;				UpSix: 				begin					curFil.flDesc := curPrompt;					bCR;					curFil.hasExtended := false;					YesNoQuestion('Enter an extended description? ', false);					BoardSection := Ext;					ExtenDo := ex1;					maxLines := -981;					UploadDo := UpSeven;				end;				UpSeven: 				begin					if theProts^^.numProtocols > 0 then					begin						crossint := theprots^^.numprotocols;						tempstring := ' 0Q?';						tempString[1] := char(13);						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANRECEIVE] or theProts^^.prots[i].pFlags[CANBRECEIVE] then							begin								crossInt := crossInt + 1;								NumToString(crossint, tempstring2);								tempString := concat(tempString, tempstring2);							end;						end;						bCR;						bCR;						NumbersPrompt(getProtMenStr, 'Q?', crossInt, 0);						UploadDo := UpEight;					end					else						GoHome;				end;				UpEight: 				begin					if curPrompt = '?' then					begin						OutLine('Q: Abort Transfer(s)', true, 0);						OutLine('0: Don''t Transfer', true, 0);						crossInt := 0;						tempstring := ' 0Q?';						tempString[1] := char(13);						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANRECEIVE] or theProts^^.prots[i].pFlags[CANBRECEIVE] then							begin								crossInt := crossInt + 1;								NumToString(crossInt, tempstring2);								OutLine(concat(tempstring2, ': ', theProts^^.prots[i].ProtoName), true, 0);								tempString := concat(tempString, tempstring2);							end;						end;						bCR;						bCR;						NumbersPrompt(getProtMenStr, 'Q?', crossInt, 0);						Exit(doUpload);					end					else if (curPrompt = 'Q') or (curPrompt = '0') then					begin						GoHome;						Exit(doUpload);					end					else					begin						StringToNum(curPrompt, tempLong);						activeProtocol := 0;						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANRECEIVE] or theProts^^.prots[i].pFlags[CANBRECEIVE] then							begin								crossInt := crossInt + 1;								if crossInt = tempLong then									activeProtocol := i;							end;						end;						if length(curPrompt) = 0 then							activeProtocol := thisUser.defaultProtocol;						if (theProts^^.prots[activeProtocol].pFlags[CANRECEIVE] or theProts^^.prots[activeProtocol].pFlags[CANBRECEIVE]) and (activeProtocol > 0) then						begin							if not sysopLogon then							begin								bCR;								bCR;								bCR;								if (theProts^^.prots[activeProtocol].pFlags[CANBRECEIVE]) then								begin									if FileTransit^^.numFiles < 50 then									begin										lastBatch := activeProtocol;										if (fileTransit^^.sendingBatch and (fileTransit^^.numFiles > 0)) then										begin											FileTransit^^.numFiles := 0;											FileTransit^^.batchTime := 0;											FileTransit^^.batchKBytes := 0;											OutLine('Download batch cleared.', true, 0);											bCR;										end;										FileTransit^^.filesGoing[fileTransit^^.numFiles + 1].theFile := curFil;										FileTransit^^.filesGoing[fileTransit^^.numFiles + 1].fromDir := tempInDir;										FileTransit^^.numFiles := FileTransit^^.numFiles + 1;										OutLine('File added to batch queue.', true, 0);										NumToString(fileTransit^^.numFiles, tempString);										OutLine(concat('Batch UL: Files - ', tempstring), true, 0);										fileTransit^^.sendingBatch := false;										bCR;										goHome;									end;								end								else								begin									myTrans.active := true;									myTrans.sending := false;									StartTrans;								end;							end							else							begin								OutLine('Cannot upload locally.', true, 0);								GoHome;							end;						end						else						begin							OutLine('Protocol not valid for uploading.', true, 0);							goHome;						end;					end;				end;				otherwise			end;		end;	end;	procedure DoSort;		var			numF: integer;			t1: str255;	begin		with curglobs^ do		begin			case SortDo of				SortOne: 				begin					if curPrompt = 'Y' then       { sort all dirs question is asked in DoMainMenu for speed  }						alldirSearch := true					else						allDirSearch := false;					YesNoQuestion('Sort by date? ', false);					SortDo := SortTwo;				end;				SortTwo: 				begin					if alldirSearch then						tempInDir := 0					else						tempInDir := inDir;					crossInt := 0;					BoardAction := Repeating;					SortDo := SortThree;				end;				SortThree: 				begin					OutLine(concat('Sorting ', intDLStuff^^.dr[tempInDir].dirName, '.'), true, 0);					if curPrompt = 'Y' then						numF := SortDir(tempInDir, false)					else						numF := SortDir(tempInDir, true);					SaveDirectory;					NumToString(numF, t1);					OutLine(concat('..', t1, ' files.'), false, 0);					crossInt := crossInt + numF;					if intDLstuff^^.numDirs > (tempInDir + 1) then						tempInDir := tempInDir + 1					else						allDirSearch := false;					if not alldirsearch or aborted then					begin						NumToString(crossInt, t1);						OutLine(concat('Total files sorted: ', t1), true, 3);						aborted := false;						BoardAction := None;						GoHome;					end;				end;				otherwise			end;		end;	end;	function RestDir (which: integer): boolean;		var			tb2: boolean;	begin		with curGlobs^ do		begin			tb2 := true;			if intDLStuff^^.dr[which].restriction <> char(0) then				if thisUser.restrics[(byte(intDLStuff^^.dr[which].restriction) - byte(64))] then					tb2 := true				else					tb2 := false;			RestDir := tb2;		end;	end;	procedure DoDownload;		label			999;		var			tempString, t2: str255;			tempFil: filEntryRec;			tempLong: longInt;			repo: SFReply;			i: integer;			tempBool, tb2: boolean;	begin		with curglobs^ do		begin			case DownDo of				DownOne: 				begin					tb2 := true;					if intDLStuff^^.dr[tempindir].restriction <> char(0) then						if thisUser.restrics[(byte(intDLStuff^^.dr[tempindir].restriction) - byte(64))] then							tb2 := true						else							tb2 := false;					if tb2 and (thisUser.transferLevel >= intDLStuff^^.dr[tempindir].minDSL) and (thisUser.age >= intDLStuff^^.dr[tempindir].minAge) then					begin						if (thisUser.transferLevel >= intDLStuff^^.dr[tempindir].DSLtoDL) then						begin							descSearch := false;							listedOneFile := false;							bCR;							OutLine('Download -', true, 0);							bCR;							bCR;							LettersPrompt('Filename: ', '', intDLStuff^^.dr[tempinDir].fileNameLength, false, false, false, char(0));							ANSIPrompter(intDLStuff^^.dr[tempinDir].fileNameLength);							DownDo := DownTwo;						end						else						begin							OutLine('You can''t download from this directory.', true, 0);							GoHome;						end;					end					else					begin						OutLine('No directory available.', true, 0);						GoHome;					end;				end;				DownTwo: 				begin					if length(curPrompt) > 0 then					begin						if intDLStuff^^.dr[inDir].freeDir or DLRatioOK then						begin							curDirPos := 0;							if OpenDirectory(inDir) then							begin								DownDo := DownThree;								tempInDir := inDir;								allDirSearch := false;								descSearch := false;								fileMask := curPrompt;							end							else							begin								OutLine('Problem opening directory.', true, 0);								GoHome;							end;						end						else						begin							DLRatioStr(tempString, activeNode);							GoodRatioStr(t2);							bCR;							OutLine(concat('Your ratio is ', tempString, '.  You need a ratio of ', t2, ' to download.'), true, 0);							GoHome;						end;					end					else						GoHome;				end;				DownThree: 				begin					GetNextFile(tempInDir, fileMask, curDirPos, curFil, 0);					if curFil.flName <> '' then					begin						listedOneFile := true;						if PrintFileInfo(curFil, tempInDir, true) then							DownDo := DownFour;					end					else					begin						if not listedOneFile and ((not intDLStuff^^.dr[inDir].freeDir) or DLRatioOK) then						begin							allDirSearch := true;							if (thisUser.coSysop) then								tempInDir := -1							else								tempInDir := 0;							OutLine('Searching all directories.', true, 1);							bCR;							listedOneFile := true;							goto 999;						end						else if alldirSearch then						begin999:							tempInDir := tempInDir + 1;							while ((intDLStuff^^.dr[tempInDir].DSLtoDL > thisUser.transferlevel) or (intDLStuff^^.dr[tempInDir].minDSL > thisUser.transferlevel) or not RestDir(tempInDir) or (thisUser.age < intDLStuff^^.dr[tempInDir].minAge)) and (tempInDir < intDLStuff^^.numdirs) do								tempInDir := tempInDir + 1;							if not ((tempInDir <= (intDLStuff^^.numdirs - 1)) and (intDLStuff^^.dr[tempInDir].DSLtoDL <= thisUser.transferlevel) and (intDLStuff^^.dr[tempInDir].minDSL <= thisUser.transferlevel) and (thisUser.age >= intDLStuff^^.dr[tempInDir].minAge) and (restDir(tempInDir))) then							begin								GoHome;							end							else if OpenDirectory(tempInDir) then								;							curDirPos := 0;						end						else							GoHome;					end;				end;				DownFour: 				begin					bCR;					bCR;					if theprots^^.numProtocols > 0 then					begin						crossint := theprots^^.numprotocols;						tempstring := ' 0Q?';						tempString[1] := char(13);						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANSEND] or theProts^^.prots[i].pFlags[CANBSEND] then							begin								crossInt := crossInt + 1;								NumToString(crossint, t2);								tempString := concat(tempString, t2);							end;						end;						NumbersPrompt(getprotMenStr, 'Q?', crossInt, 0);						DownDo := DownFive;					end					else						GoHome;				end;				DownFive: 				begin					if curPrompt = '?' then					begin						OutLine('Q: Abort Transfer(s)', true, 0);						OutLine('0: Don''t Transfer', true, 0);						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANSEND] or theProts^^.prots[i].pFlags[CANBSEND] then							begin								crossInt := crossInt + 1;								NumToString(crossInt, t2);								OutLine(concat(t2, ': ', theProts^^.prots[i].ProtoName), true, 0);							end;						end;						bCR;						bCR;						crossint := theprots^^.numprotocols;						tempstring := ' 0Q?';						tempString[1] := char(13);						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANSEND] or theProts^^.prots[i].pFlags[CANBSEND] then							begin								crossInt := crossInt + 1;								NumToString(crossint, t2);								tempString := concat(tempString, t2);							end;						end;						NumbersPrompt(getprotMenStr, 'Q?', crossInt, 0);						DownDo := DownFive;					end					else if (curPrompt = 'Q') or (curPrompt = 'q') then					begin						GoHome;						Exit(doDownload);					end					else if (curPrompt = '0') then						DownDo := DownThree					else					begin						StringToNum(curPrompt, tempLong);						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANSEND] or theProts^^.prots[i].pFlags[CANBSEND] then							begin								crossInt := crossInt + 1;								if crossInt = tempLong then									tempLong := i;							end;						end;						if length(curPrompt) = 0 then							tempLong := thisUser.defaultProtocol;						if not sysopLogon then						begin							if ((nodeType <> 2) or ((tempLong <> 2) and (templong <> 3))) and (tempLong > 0) and (theProts^^.numProtocols >= tempLong) and ((theProts^^.prots[tempLong].pFlags[CANSEND]) or (theProts^^.prots[tempLong].pFlags[CANBSEND])) then							begin								if not theProts^^.prots[templong].pFlags[CANBSEND] then								begin									activeProtocol := templong;									bCR;									bCR;									bCR;									myTrans.active := true;									myTrans.sending := true;									StartTrans;								end								else								begin									if FileTransit^^.numFiles < 50 then									begin										activeProtocol := tempLong;										lastBatch := activeProtocol;										if (currentBaud <> 0) and (nodeType = 1) then											tempLong := (fileTransit^^.batchTime + (curFil.bytelen div (modemDrivers^^[modemID].rs[rsIndex].effRate div 10)))										else											tempLong := 0;										if tempLong <= (ticksLeft(activeNode) div 60) then										begin											if not intDLStuff^^.dr[tempInDir].freeDir then											begin												thisUser.downloadedK := thisUser.downloadedK + fileTransit^^.batchKBytes;												tempBool := DLRatioOK;												thisUser.downloadedK := thisUser.downloadedK - fileTransit^^.batchKBytes;											end											else												tempBool := true;											if tempBool then											begin												if (not fileTransit^^.sendingBatch and (fileTransit^^.numFiles > 0)) then												begin													FileTransit^^.numFiles := 0;													FileTransit^^.batchTime := 0;													FileTransit^^.batchKBytes := 0;													OutLine('Upload batch cleared.', true, 0);													bCR;												end;												FileTransit^^.filesGoing[fileTransit^^.numFiles + 1].theFile := curFil;												FileTransit^^.filesGoing[fileTransit^^.numFiles + 1].fromDir := tempInDir;												FileTransit^^.numFiles := FileTransit^^.numFiles + 1;												if (currentBaud <> 0) and (nodeType = 1) then													FileTransit^^.batchTime := fileTransit^^.batchTime + (curFil.bytelen div (modemDrivers^^[modemID].rs[rsIndex].effRate div 10))												else													FileTransit^^.batchTime := 0;												FileTransit^^.batchKBytes := fileTransit^^.batchKBytes + (curFil.byteLen div 1024);												OutLine('File added to batch queue.', true, 0);												NumToString(fileTransit^^.numFiles, tempString);												t2 := secs2time(fileTransit^^.batchTime);												OutLine(concat('Batch DL: Files - ', tempstring, '  Time - ', t2), true, 0);												fileTransit^^.sendingBatch := true;												bCR;											end											else											begin												OutLine('Sorry, your ratio is too low to add that.', true, 0);												bCR;											end;										end										else										begin											Outline('Not enough time left in queue.', true, 0);											bCR;										end;									end									else									begin										OutLine('No room left in batch queue.', true, 0);										bCR;									end;									DownDo := DownThree;								end;							end							else							begin								OutLine('Protocol not valid for downloading.', true, 1);								BCR;								downDo := downThree;							end;						end						else						begin							OutLine('Cannot download locally.', true, 0);							GoHome;						end;					end;				end;				otherwise			end;		end;	end;end.