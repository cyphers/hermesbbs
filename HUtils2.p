unit HUtilsTwo;interface	uses		AppleTalk, ADSP, Serial, Sound, SANE, Initial, inpOut2, InpOut, User, terminal, Message_Editor, NodePrefs, SystemPrefs, FileTrans2, FileTrans;	procedure DoMenuCommand (menuResult: LONGINT);	procedure UnCheckTerm;	procedure DoUserEdit;	procedure doBBSlist;	procedure DoMultiMail;	procedure DoUpMess;	procedure doTransDefs;	procedure SwitchNode (toWhich: integer);	procedure DoDialIdle;implementation	procedure SwitchNode (toWhich: integer);		var			tempString, t2, t3: str255;			ThisEditText: TEHandle;			TheDialogPtr: DialogPeek;			tempInt, i: integer;			aHandle: handle;			temprect: rect;	begin		bullBool := true;		if (toWhich <= intSystRec.numNodes) and (toWhich > 0) then		begin			if gBBSwindows[toWhich]^.ansiPort <> nil then				SelectWindow(gBBSwindows[toWhich]^.ansiPort)			else				OpenANSIWindow(toWhich);			if toWhich <> visibleNode then			begin				closeNodePrefs;				statChanged := true;				if (theNodes[visibleNode]^.myTrans.active) and (theNodes[visibleNode]^.transDilg <> nil) then				begin					DisposDialog(theNodes[visibleNode]^.transDilg);					theNodes[visibleNode]^.transDilg := nil;				end;				result := CallUtility(DISPOSETMENU, ptr(theNodes[visibleNode]^.myProcMenu), 0);				theNodes[visibleNode]^.myProcMenu := nil;				visibleNode := toWhich;				NumToString(visibleNode, tempString);				curGlobs := theNodes[visibleNode];				activeNode := visibleNode;				if gBBSwindows[activeNode]^.ansiPort <> FrontWindow then					SelectWindow(gBBSwindows[activeNode]^.ansiPort);				if (theNodes[visibleNode]^.myTrans.active) and intSystRec.useXWind and (gBBSwindows[activeNode]^.ansiPort <> nil) then				begin					theNodes[visibleNode]^.TransDilg := GetNewDialog(982, nil, pointer(-1));					SetPort(theNodes[visibleNode]^.transDilg);					TextFont(monaco);					TextSize(9);					TheDialogPtr := DialogPeek(theNodes[visibleNode]^.transDilg);					ThisEditText := TheDialogPtr^.textH;					HLock(Handle(ThisEditText));					ThisEditText^^.txSize := 9;					ThisEditText^^.txFont := 4;					ThisEditText^^.fontAscent := 9;					ThisEditText^^.lineHeight := 9 + 2 + 0;					HUnLock(Handle(ThisEditText));					tempstring := theProts^^.prots[theNodes[visibleNode]^.activeProtocol].ProtoName;					if theNodes[visibleNode]^.myTrans.sending then						tempstring := concat(tempstring, ' Send')					else						tempstring := concat(tempstring, ' Receive');					SetWTitle(theNodes[visibleNode]^.transdilg, tempstring);					GetDItem(theNodes[visibleNode]^.transDilg, 6, tempInt, aHandle, tempRect);					t2 := theNodes[visibleNode]^.extTrans^^.fPaths[theNodes[visibleNode]^.extTrans^^.filesDone + 1].fname^^;					i := length(t2);					t3 := '';					while (t2[i] <> ':') and (i > 0) do					begin						i := i - 1;					end;					if t2[i] = ':' then						t3 := copy(t2, i + 1, length(t2) - i)					else						t3 := t2;					SetIText(aHandle, t3);					GetDItem(theNodes[visibleNode]^.transDilg, 9, tempInt, aHandle, tempRect);					SetIText(aHandle, theNodes[visibleNode]^.lastTransError);					ShowWindow(theNodes[visibleNode]^.transDilg);					DrawDialog(theNodes[visibleNode]^.transDilg);					UpdateProgress;					DisableItem(getMHandle(mDisconnects), 0);				end				else					EnableItem(getMHandle(mDisconnects), 0);				if (curglobs^.boardMode = Terminal) then					result := CallUtility(BUILDMENU, pointer(@curglobs^.myProcMenu), longint($03F10000))				else					result := CallUtility(BUILDMENU, pointer(@curglobs^.myProcMenu), longint($03F10001));				if curglobs^.boardMode = User then					EnableItem(getMHandle(mUser), 0)				else					DisableItem(getMHandle(mUser), 0);				if curglobs^.boardMode = terminal then				begin					EnableItem(getMHandle(mTerminal), 0);					DisableItem(getMHandle(mSysop), 1);					DisableItem(getMHandle(mSysop), 2);					if curglobs^.myTrans.active then					begin						DisableItem(getMHandle(1009), 0);						DisableItem(getMHandle(mTerminal), 0);					end					else					begin						EnableItem(getMHandle(1009), 0);						EnableItem(getMHandle(mTerminal), 0);					end;				end				else				begin					DisableItem(getMHandle(mTerminal), 0);					EnableItem(getMHandle(mSysop), 1);					EnableItem(getMHandle(mSysop), 2);				end;				if curglobs^.nodeType = 1 then					EnableItem(getMHandle(mSysop), 8)				else					DisableItem(getMHandle(mSysop), 8);				if curglobs^.capturing then					CheckItem(GetMHandle(mFile), 8, true)				else					CheckItem(GetMHandle(mFile), 8, false);				DrawMenuBar;			end;		end;	end;	procedure UncheckTerm;		var			i: integer;	begin		for i := 1 to 19 do			CheckItem(getMHandle(55), i, false);	end;	function HU2ProtocolCall (message: integer; ExtRecPtr: ptr; refcon: longint; PP: procptr): OSerr;	inline		$205f,  	{   movea.l (a7)+,a0  }		$4e90;	{	jsr(a0)			   }	procedure DoDialIdle;		label			400;		var			alreadyHere: boolean;			ts: str255;			i: integer;	begin		with curGlobs^ do		begin			alreadyHere := false;400:			i := 0;			while (i < 10) and ((theDials^^.dialed[i]) or not (theDials^^.dialIt[i])) do				i := i + 1;			if i = 10 then			begin				for i := 0 to 9 do					theDials^^.dialed[i] := false;				if alreadyHere then					dialing := false				else				begin					alreadyHere := true;					goto 400;				end;			end;			if dialing and (dialDelay < (tickCount - 200)) then			begin				theDials^^.dialed[i] := true;				ts := concat('ATDT', theDials^^.numbers[i], char(13));				result := AsyncMWrite(outputRef, length(ts), @ts[1]);				waitDialResponse := true;				frontCharElim := 5;				crossInt := i;			end;		end;	end;	procedure PasteSysopBuffer;		type			twoChar = packed array[0..1] of char;			twoChPtr = ^twoChar;		var			p, e, lp: twoChPtr;			l1: longint;			i: integer;	begin		with curGlobs^ do		begin			p := pointer(@sysopKeyBuffer^^);			lp := p;			e := pointer(ord4(@sysopKeyBuffer^^) + GetHandleSize(handle(sysopKeyBuffer)));			while (longint(p) < longint(e)) do			begin				l1 := 0;				while (p^[0] <> char(13)) and (longint(p) < longint(e)) do				begin					p := pointer(ord4(p) + 1);					l1 := l1 + 1;				end;				if l1 > 0 then				begin					for i := 1 to l1 do						curMessage^^[online] := concat(curMessage^^[online], twoChPtr(ord4(lp) + (i - 1))^[0]);					ProcessData(activeNode, ptr(lp), l1);				end;				if p^[0] = char(13) then				begin					p := pointer(ord4(p) + 1);					bCR;					onLine := onLine + 1;					curMessage^^[onLine] := '';					if (online + 1) > maxLines then					begin						e := p;						OutLine('-= No more lines =-', false, 0);						OutLine('/ES to save.', true, 0);						bCR;						online := online - 1;					end;				end;				lp := p;			end;			SetHandleSize(handle(sysopKeyBuffer), 0);		end;	end;	procedure DoMenuCommand;		label			47;		var			menuID, menuItem, tempint: integer;			daName, freeMemStr, tempString: Str255;			daRefNum: integer;			handledByDA: boolean;			userPickDilg: DialogPtr;			tempLong, tempLong2: LongInt;			tempRect, tempRect2: Rect;			dType, i: Integer;			dItem, aHandle: Handle;			tempPt: point;			repo: SFReply;			typeList: SFTypeList;			mySavedBD: BDAct;			oldSize, newSize: LongInt;	begin		with curglobs^ do		begin			menuID := HiWrd(menuResult);			menuItem := LoWrd(menuResult);			if menuID <> 0 then			begin				case menuID of					mApple: 						case menuItem of							1: 							begin								if OptionDown then								begin									FlashyAboutBox;								end								else								begin									OpenaboutBox;									repeat									until button;									CloseAboutBox;								end;							end;							otherwise							begin								GetItem(GetMHandle(mApple), menuItem, daName);								daRefNum := OpenDeskAcc(daName);							end;						end;					mFile: 						case menuItem of							1: 							begin								SetPt(tempPt, 40, 40);								SFPutFile(tempPt, 'Please name your text file:', 'Text File', nil, repo);								if repo.good then								begin									result := FSDelete(repo.fName, repo.vrefNum);									result := Create(repo.fname, repo.vrefnum, 'HRMS', 'TEXT');									freeMemStr := PathnameFromWD(repo.vRefNum);									OpenTextWindow(freeMemStr, repo.fName, false, true);								end								else								begin									HiLiteMenu(0);									exit(doMenuCommand);								end;							end;							4: 							begin								i := isMyTextWindow(frontwindow);								dtype := ismyBBSwindow(frontwindow);								if i >= 0 then									CloseTextWindow(i)								else if dtype > 0 then									CloseANSIWindow(dtype);							end;							5: 							begin								i := isMyTextWindow(frontwindow);								if i >= 0 then									SaveTextWindow(i);							end;							6: 							begin								i := isMyTextWindow(frontwindow);								if i >= 0 then								begin									SetPt(tempPt, 40, 40);									SFPutFile(tempPt, 'Save text file as', '', nil, repo);									if repo.good then									begin										result := FSDelete(repo.fName, repo.vrefNum);										result := Create(repo.fname, repo.vrefnum, 'HRMS', 'TEXT');										freeMemStr := PathnameFromWD(repo.vRefNum);										SetWTitle(textWinds[i].w, repo.fname);										textWinds[i].origPath := freeMemStr;										textWinds[i].wasResource := false;										textWinds[i].dirty := true;										SaveTextWindow(i);									end;								end;							end;							8: 							begin								if capturing then									CloseCapture								else if (BoardMode = Terminal) or (BoardMode = User) then								begin									OpenCapture;									CheckItem(GetMHandle(mFile), 8, capturing);								end								else									SysBeep(10);							end;							10: 							begin								quit := 1;							end;							otherwise						end;					mEdit: 					begin						if menuItem <= 6 then							handledbyDA := SystemEdit(menuItem - 1)						else							handledbyDA := false;						if not handledbyDA then						begin							i := isMyTextWindow(frontWindow);							if (ismyBBSwindow(frontWindow) > 0) then							begin								if (menuItem = 3) or (menuItem = 4) then								begin									result := ZeroScrap;									if gBBSwindows[activeNode]^.selectActive then										CopySelection(activeNode);								end								else if (menuItem = 5) and ((BoardMode = User) or (BoardMode = Terminal)) then								begin									if GetScrap(handle(sysopKeyBuffer), 'TEXT', tempLong) > 0 then									begin										if ((BoardMode = User) and (BoardAction = Writing)) then										begin											PasteSysopBuffer;										end										else if BoardMode = Terminal then										begin											result := AsyncMWrite(outputRef, getHandleSize(handle(sysopKeyBuffer)), ptr(sysopKeyBuffer^));											if inHalfDuplex then												ProcessData(activeNode, ptr(sysopKeyBuffer^), getHandleSize(handle(sysopKeyBuffer)));											SetHandleSize(handle(sysopKeyBuffer), 0);										end;									end;								end								else									SysBeep(10);							end							else if (i >= 0) then							begin								case menuitem of									3: 									begin										with textWinds[i] do										begin											if ZeroScrap = noErr then											begin												PurgeSpace(tempLong, tempLong2);												if (t^^.selEnd - t^^.selStart) + 1024 > tempLong2 then   {1024 is just for safety}												begin													SysBeep(10);													SysBeep(10);												end												else												begin													dirty := true;													TECut(t);													if TEToScrap <> noErr then													begin														SysBeep(10);														if ZeroScrap = noErr then															;													end;												end;											end;										end;									end;									4: 									begin										if ZeroScrap = noErr then										begin											TECopy(textWinds[i].t);											if TEToScrap <> noErr then											begin												SysBeep(10);												if ZeroScrap = noErr then													;											end;										end;									end;									5: 									begin										with textWinds[i] do										begin											if TEFromScrap = noErr then											begin												if TEGetScrapLen + (t^^.teLength - (t^^.selEnd - t^^.selStart)) > 32000 then													SysBeep(10)												else												begin													aHandle := Handle(TEGetText(t));													oldSize := GetHandleSize(aHandle);													newSize := oldSize + TEGetScrapLen + 1024;  {1024 just for safety}													SetHandleSize(aHandle, newSize);													result := MemError;													SetHandleSize(aHandle, oldSize);													dirty := true;													if result <> noErr then														SysBeep(10)													else														TEPaste(t);												end;											end											else												SysBeep(10);										end;									end;									6: 									begin										textWinds[i].dirty := true;										TEDelete(textWinds[i].t);									end;									7: 										TESetSelect(0, 32767, textWinds[i].t);									9: 										DoTextSearch(i);									10: 										mySearchTE(i, true);									otherwise								end;							end							else								SysBeep(10);						end;					end;					10: 					begin						if menuItem > 1 then							GetItem(GetMHandle(10), menuItem, tempString)						else if menuItem = 1 then						begin							SetPt(tempPt, 40, 40);							typeList[0] := 'TEXT';							if optionDown then								SFGetFile(tempPt, 'What file?', nil, -1, typeList, nil, repo)							else								SFGetFile(tempPt, 'What file?', nil, 1, typeList, nil, repo);							if repo.good then							begin								tempString := '';							end							else							begin								HiLiteMenu(0);								exit(doMenuCommand);							end;						end;						if (tempString <> '') then							OpenTextWindow('', tempstring, true, true)						else						begin							freeMemStr := PathnameFromWD(repo.vRefNum);							OpenTextWindow(freeMemStr, repo.fName, false, true);						end;					end;					58: 					begin						DoAutoValChoice(menuitem);						UpdateAutoValMenu;					end;					mUser: 						case menuitem of							1: 							begin								if BoardAction <> chat then								begin									if not myTrans.active then									begin										SavedBD2 := BoardAction;										BoardAction := chat;										bCR;										prompting := false;										CheckItem(GetMHandle(mUser), 1, true);										StartedChat := tickCount;										triedChat := false;										DoChatShow(true, true, '0');									end;								end								else								begin									bCR;									if thisUser.canANSI then									begin										ANSICode('2J');										ANSICode('H');									end;									OutLine('Chat mode over.', false, 1);									bCR;									CheckItem(GetMHandle(mUser), 1, false);									GiveTime((tickCount - startedchat), 1, false);									BoardAction := savedBD2;									if thisUser.canANSI then										dom(0);									if BoardAction = Writing then										ListLine(online)									else if boardAction = Prompt then										ReprintPrompt;								end;							end;							2: 							begin								if getUSelection = nil then								begin									Single := true;									if thisUser.UserNum > 0 then									begin										EditingUser := thisUser;										Open_User_Edit;									end									else										SysBeep(10);								end								else									SelectWindow(getUSelection);							end;							3: 							begin								if not sysopLogon then								begin									if not stopRemote then									begin										stopRemote := true;										SavedBDaction := BoardAction;										BoardAction := none;										OutLineSysop('< REMOTE KB DISABLED >', true);										BoardAction := savedBDaction;									end									else									begin										stopRemote := false;										if not sysopLogon then										begin											clearInBuf;										end;										SavedBDaction := BoardAction;										BoardAction := none;										OutLineSysop('< REMOTE KB ENABLED >', true);										BoardAction := savedBDaction;									end;								end;							end;							4: 							begin								if thisUser.UserNum > -1 then								begin									GiveTime(-18000, 1, false);									statChanged := true;								end;							end;							5: 							begin								if thisUser.UserNum > -1 then								begin									GiveTime(18000, 1, false);									statChanged := true;								end;							end;							6: 							begin								if (thisUser.UserNum > 1) and (RealSL > 0) then								begin									wasMadeTempSysop := not wasMadeTempSysop;									thisUser.coSysop := not thisUser.coSysop;									if thisUser.SecLevel <> RealSL then										thisUser.SecLevel := RealSL									else										thisUser.SecLevel := 255;									statChanged := true;								end;							end;							otherwise						end;					mDisconnects: 						if (boardMode = User) then							case menuitem of								1: 								begin									HangupAndReset;								end;								2: 								begin									mySavedBD := BoardAction;									BoardAction := none;									bCR;									OutLine(concat(char(7), retinstr(17, 68)), false, 6);									if thisUser.canANSI then										dom(0);									bCR;									BoardAction := mySavedBD;									ShutdownSoon := true;									extraTime := extraTime + 18000 - ticksLeft(activeNode);									if BoardAction = Writing then										ListLine(online)									else if boardAction = Prompt then										ReprintPrompt;								end;								3: 								begin									tempInt := (ABS(Random) mod 40) + 1;									for i := 1 to tempInt do										OutLine(char((ABS(Random) mod 100) + 27), false, -1);									Delay(45, tempLong);									HangupAndReset;								end;								4: 								begin									OutLine('Time expired.', true, 0);									delay(60, tempLong);									HangUpAndReset;								end;								otherwise							end;					55: 					begin						doBaudReset(menuItem);						UnCheckTerm;						CheckItem(GetMHandle(55), menuItem, true);						NumToBaud(menuItem, currentBaud);						statChanged := true;					end;					50: 						case menuItem of							1: 							begin								ANSIterm := false;								checkItem(getMHandle(50), 1, true);								checkItem(getMHandle(50), 2, false);								statChanged := true;								gBBSwindows[activeNode]^.ansiEnable := false;							end;							2: 							begin								ANSIterm := true;								checkItem(getMHandle(50), 1, false);								checkItem(getMHandle(50), 2, true);								statChanged := true;								gBBSwindows[activeNode]^.ansiEnable := true;							end;							otherwise						end;					mView: 					begin						if menuItem = (intSystRec.numNodes + 2) then							OpenStatWindow						else							SwitchNode(menuItem);					end;					mTerminal: 					begin						if menuitem = 3 then						begin							checkItem(GetMHandle(mTerminal), 3, not inHalfDuplex);							inHalfDuplex := not inHalfDuplex;							statChanged := true;						end						else if menuItem = 4 then						begin							checkItem(GetMHandle(mTerminal), 4, in8BitTerm);							in8BitTerm := not in8BitTerm;							statChanged := true;						end						else if menuItem = 5 then						begin							if dialing then							begin								dialing := false;								waitDialResponse := false							end							else							begin								DoDialDialog;								if dialing then								begin									dialDelay := tickCount - 300;									DoDialIdle;								end;							end;							CheckItem(GetMHandle(mTerminal), 5, dialing);						end;					end;					mLog: 					begin						case menuItem of							1: 								OpenTextWindow(sharedPath, 'Usage Record', false, false);							3: 								OpenTextWindow(sharedPath, 'Today Log', false, false);							otherwise							begin								GetItem(getMHandle(mLog), menuItem, tempstring);								OpenTextWindow(concat(sharedPath, 'Logs:'), tempstring, false, false);							end;						end;					end;					mSysop: 					begin						case menuitem of							1: 							begin47:								if ((BoardMode = Failed) or (BoardMode = Waiting)) and (ismyBBSwindow(frontWindow) > 0) then								begin									sysopLogon := true;									ClearScreen;									curBaudNote := '';									currentBaud := 0;									if goOffinLocal then										TellModem('ATM0H1');									DoLogon;									ClearInBuf;								end								else									SysBeep(10);							end;							2: 							begin								if (intSystRec.numUsers > 0) then								begin									if (not UserOnSystem(myUsers^^[0].Uname)) and ((BoardMode = Failed) or (BoardMode = Waiting)) and (ismyBBSwindow(frontWindow) > 0) then									begin										if FindUser('1', thisUser) then										begin											SysopLogOn := true;											if goOffinLocal then												TellModem('ATM0H1');											CurBaudNote := '';											currentBaud := 0;											ClearScreen;											boardmode := user;											EnableItem(GetMHandle(mUser), 0);											DrawMenuBar;											lastKeyPressed := TickCount;											BoardAction := none;											BoardSection := Logon;											LogonStage := ChkSysPass;											EnteredPass := thisUser.password;											enteredPass2 := copy(thisUser.phone, 9, 4);											ClearinBuf;											realSL := 255;										end;									end									else										SysBeep(10);								end								else									goto 47;							end;							3: 							begin								SysopAvailC := not SysopAvailC;							end;							4: 							begin								AnswerCalls := not AnswerCalls;								CheckItem(getMHandle(mSysop), 4, not answerCalls);								if not answerCalls then									for i := 1 to 10 do										held[i] := false;							end;							6: 							begin								if GetUSelection = nil then								begin									tempString := '1';									if FindUser(tempString, EditingUser) then									begin										Single := false;										Open_User_Edit;									end;								end								else								begin									SelectWindow(getUSelection);									Sysbeep(10);								end;							end;							7: 							begin								SysopFileConfigure;							end;							8: 							begin								if (ismyBBSwindow(frontWindow) > 0) and ((BoardMode = Waiting) or (BoardMode = Failed)) then								begin									BoardMode := Terminal;									Flowie(true);									EnableItem(GetMHandle(mTerminal), 0);									UnCheckTerm;									NumToBaud(maxBaud, currentBaud);									CheckItem(getMHandle(55), maxBaud, true);									CheckItem(GetMHandle(mTerminal), 4, false);									CheckItem(GetMHandle(mTerminal), 3, false);									checkItem(getMHandle(50), 2, true);									inHalfDuplex := false;									in8BitTerm := true;									ANSIterm := true;									DisableItem(GetMHandle(mSysop), 1);									DisableItem(getMHandle(mSysop), 2);									result := CallUtility(DISPOSETMENU, ptr(myProcMenu), 0);									myProcMenu := nil;									result := CallUtility(BUILDMENU, pointer(@myProcMenu), longint($03F10000));									DrawMenuBar;									freeMemStr := modemDrivers^^[modemID].termInit;									freememstr := concat(freeMemStr, char(13));									templong := length(freememStr);									Result := AsyncMWrite(outputRef, tempLong, @freeMemStr[1]);									statChanged := true;								end								else if BoardMode = Terminal then								begin									gBBSwindows[activeNode]^.ansiEnable := true;									currentBaud := 0;									dialing := false;									waitDialResponse := false;									UncheckTerm;									DisableItem(GetMHandle(mTerminal), 0);									EnableItem(GetMHandle(mSysop), 1);									EnableItem(getMHandle(mSysop), 2);									result := CallUtility(DISPOSETMENU, ptr(myProcMenu), 0);									myProcMenu := nil;									result := CallUtility(BUILDMENU, pointer(@myProcMenu), longint($03F10001));									DrawMenuBar;									HangupAndReset;								end;							end;							11: 								OpenTransferSections;							12: 								Open_Message_Editor;							14: 								OpenNodePrefs;							15: 								OpenSystemConfig(1);							16: 							begin								userPickDilg := GetNewDialog(415, nil, pointer(-1));								NumToString(intSystRec.numNodes, tempString);								ParamText(tempString, '', '', '');								repeat									ModalDialog(nil, i);								until (i = 1);								GetDItem(userPickDilg, 3, DType, DItem, tempRect);								GetIText(DItem, tempString);								DisposDialog(userPickDilg);								StringToNum(tempString, tempLong);								i := tempLong;								if (i > 0) and (i < 11) then									setNewNodes := i								else									ProblemRep('Number of nodes invalid; not changed.');							end;							otherwise						end;					end;					otherwise					begin						result := CallUtility(DOMENU, ptr(myProcMenu), menuResult);						if myProcMenu^^.proto <> nil then						begin							tempLong := -1;							for i := 1 to theProts^^.numProtocols do							begin								if (myProcMenu^^.theProcList[myProcMenu^^.transIndex].itemID = theProts^^.prots[i].resID) and (myProcMenu^^.transRefCon = theProts^^.prots[i].refCon) then									tempLong := i;							end;							if tempLong > 0 then							begin								activeProtocol := templong;								if myProcMenu^^.transMessage = 2 then								begin									myProcMenu^^.proto^^.modemInput := inputRef;									myProcMenu^^.proto^^.modemOutput := outputRef;									myProcMenu^^.proto^^.timeout := intSystRec.protocolTime;									theProts^^.prots[activeProtocol].ProtHand := Get1Resource('PROC', theProts^^.prots[activeProtocol].resID);									theprots^^.prots[activeprotocol].protMode := theprots^^.prots[activeprotocol].protMode + 1;									if theprots^^.prots[activeProtocol].protMode = 1 then									begin										MoveHHi(theProts^^.prots[activeProtocol].ProtHand);										Hlock(theProts^^.prots[activeProtocol].ProtHand);									end;									result := HU2ProtocolCall(2, pointer(myProcMenu^^.proto^), theprots^^.prots[activeProtocol].refCon, StripAddress(pointer(theProts^^.prots[activeProtocol].protHand^)));									theProts^^.prots[activeprotocol].protMode := theProts^^.prots[activeProtocol].protMode - 1;									if theProts^^.prots[activeProtocol].protMode <= 0 then										HUnlock(theProts^^.prots[activeProtocol].protHand);									result := CallUtility(DISPOSEPREC, ptr(myProcMenu), 0);								end								else								begin									if myProcMenu^^.transMessage = UPLOADCALL then										myTrans.sending := false									else										myTrans.sending := true;									myTrans.active := true;									KillXFerRec;									extTrans := myProcMenu^^.proto;									extTrans^^.modemInput := inputRef;									extTrans^^.modemOutput := outputRef;									extTrans^^.timeout := intSystRec.protocolTime;									StartTrans;								end;							end;						end;					end;				end;				HiliteMenu(0);					{unhighlight what MenuSelect (or MenuKey) hilited}			end;		end;	end;	procedure DoUpMess;		var			tempString, tempstring2: str255;			hhh: paramBlockRec;			i: integer;			tempLong: longint;	begin		with curglobs^ do		begin			case upMess of				MessUpOne: 				begin					if not sysopLogon then					begin						bCR;						bCR;						bCR;						if theProts^^.numProtocols > 0 then						begin							crossint := theprots^^.numprotocols;							tempstring := ' 0Q?';							tempString[1] := char(13);							crossInt := 0;							for i := 1 to theProts^^.numProtocols do							begin								if theProts^^.prots[i].pFlags[CANRECEIVE] then								begin									crossInt := crossInt + 1;									NumToString(crossint, tempstring2);									tempString := concat(tempString, tempstring2);								end;							end;							NumbersPrompt(getProtMenStr, 'Q?', crossInt, 0);						end						else							GoHome;						UpMess := MessUpTwo;					end					else					begin						OutLine('In local mode, please use //LOAD to put a file in the workspace.', true, 0);						GoHome;					end;				end;				MessUpTwo: 				begin					if curPrompt = '?' then					begin						OutLine('Q: Abort Transfer(s)', true, 0);						OutLine('0: Don''t Transfer', true, 0);						crossInt := 0;						tempstring := ' 0Q?';						tempString[1] := char(13);						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANRECEIVE] then							begin								crossInt := crossInt + 1;								NumToString(crossInt, tempstring2);								OutLine(concat(tempstring2, ': ', theProts^^.prots[i].ProtoName), true, 0);								tempString := concat(tempString, tempstring2);							end;						end;						bCR;						bCR;						NumbersPrompt(getProtMenStr, 'Q?', crossInt, 0);						Exit(doUpMess);					end					else if (curPrompt = 'Q') or (curPrompt = '0') then					begin						GoHome;						Exit(doUpMess);					end					else					begin						StringToNum(curPrompt, tempLong);						crossInt := 0;						for i := 1 to theProts^^.numProtocols do						begin							if theProts^^.prots[i].pFlags[CANRECEIVE] then							begin								crossInt := crossInt + 1;								if crossInt = tempLong then									tempLong := i;							end;						end;						if length(curPrompt) = 0 then							tempLong := thisUser.defaultProtocol;						if (tempLong > 0) and (tempLong <= theProts^^.numProtocols) and (theProts^^.prots[templong].pFlags[CANRECEIVE]) then						begin							activeProtocol := templong;							bCR;							Bcr;							tempString := 'Local Workspace';							result := FSDelete(tempString, 0);							myTrans.active := true;							myTrans.sending := false;							upMess := MessUpThree;							StartTrans;						end						else						begin							OutLine('Protocol not valid for uploading.', true, 0);							upMess := MessUpOne;						end;					end;				end;				MessUpThree: 				begin					if crossInt > 0 then					begin						TempString := 'Local Workspace';						hhh.ioNamePtr := @tempString;						hhh.ioVRefNum := 0;						hhh.ioFVersNum := 0;						hhh.ioFDirIndex := 0;						if PBGetFInfo(@hhh, false) = noErr then						begin							tempLong := hhh.ioFLLgLen + hhh.ioFLRLgLen;							if tempLong < 15000 then							begin								OutLine('Message uploaded.  The next post or email will contain that text.', true, 0);								useWorkspace := 1;							end							else							begin								OutLine('Sorry, your message is too long.  Not saved.', true, 0);								result := FSDelete(tempString, 0);								useWorkspace := 0;							end;						end						else							OutLine('Problem with message upload.', true, 0);					end					else						OutLine('Message receive failed.', true, 0);					GoHome;				end;				otherwise			end;		end;	end;	procedure DoTransDefs;		var			t1, T8: str255;			tempint: longint;			i: integer;	begin		with curglobs^ do		begin			case TransDo of				TrOne: 				begin					ClearScreen;					OutLine('1. Set Default Protocol', false, 0);					if thisUser.nTransAfterMess then						t1 := 'Yes'					else						T1 := 'No';					OutLine(concat('2. N-Scan Transfer after Message Base(', t1, ')'), true, 0);					if thisUser.extendedLines > 0 then						t1 := 'Yes'					else						t1 := 'No';					OutLine(concat('3. Print Extended Descriptions in Listing(', t1, ')'), true, 0);					OutLine('Q. Quit', true, 0);					bCR;					bCR;					NumbersPrompt('Which? ', 'Q', 3, 1);					TransDo := TrTwo;				end;				trFour: 				begin				end;				TrTwo: 				begin					if length(curPrompt) > 0 then					begin						case curprompt[1] of							'3': 							begin								if thisUser.extendedLines <> 0 then									thisUser.extendedLines := 0								else									thisUser.extendedLines := 1;								TransDo := TrThree;							end;							'2': 							begin								thisUser.NTransAfterMess := not ThisUser.NTransAfterMess;								TransDo := TrOne;							end;							'1': 							begin								bCR;								OutLine('Enter your Default Protocol, 0 for none.', true, 0);								bCR;								NumbersPrompt('Protocol (?=list) : ', '?', theProts^^.numprotocols, 0);								TransDo := TrThree;							end;							'Q': 								GoHome;							otherwise						end;					end					else						GoHome;				end;				TrThree: 				begin					if length(curprompt) > 0 then					begin						case curPrompt[1] of							'?': 							begin								OutLine('0: No default', true, 0);								for i := 1 to theProts^^.numProtocols do								begin									NumToString(i, t1);									OutLine(concat(t1, ': ', theProts^^.prots[i].ProtoName), true, 0);								end;								bCR;								curPrompt := '1';								TransDo := TrTwo;							end;							otherwise							begin								StringToNum(curPrompt, tempint);								if (tempInt > 0) and (tempInt <= theProts^^.numProtocols) then									thisUser.defaultProtocol := tempint								else									thisUser.defaultProtocol := 0;								TransDo := TrOne;							end;						end;					end					else						GoHome;				end;				otherwise			end;		end;	end;	procedure PrUserStuff (var theUser: UserRec);		var			te1, te2, te3, te4: Str255;			i: integer;	begin		with curglobs^ do		begin			bufferbCR;			BufClearScreen;			if theUser.Deleting then			begin				bufferIt('>>> DELETED <<<', false, 0);				bufferbCR;			end;			if UserOnSystem(theUser.UserName) then			begin				bufferIt('<<< ONLINE >>>', false, 0);				bufferbCR;			end;			NumToString(theUser.UserNum, te1);			if theuser.coSysop then				bufferIt(concat('Name: ', theUser.UserName, ' #', te1, '     SYSOP'), false, 0)			else				bufferIt(concat('Name: ', theUser.UserName, ' #', te1), false, 0);			bufferIt(concat('RN  : ', theUser.realname), true, 0);			bufferIt(concat('PH  : ', theUser.phone), true, 0);			NumToString(theUser.age, te1);			if theUser.sex then				bufferIt(concat('Age : ', te1, ' M'), true, 0)			else				bufferIt(concat('Age : ', te1, ' F'), true, 0);			if realSL = 255 then				bufferIt(concat('PW  : ', theUser.password), true, 0);			bufferIt(concat('Comp: ', theUser.computerType), true, 0);			IUDateString(theUser.lastOn, shortDate, te1);			IUDateString(theUser.firstOn, shortDate, te2);			NumToString(theUser.lastBaud, te3);			bufferIt(concat('Last: ', te1, '   ', te2, '   ', te3), true, 0);			NumToString(theUser.messagesPosted, te1);			te1 := concat('Msgs: P=', te1, ' E=');			NumToString(theUser.eMailSent, te2);			te1 := concat(te1, te2);			bufferIt(te1, true, 0);			NumToString(theUser.totalLogons, te1);			te1 := concat('Log : ', te1, '  ');			NumToString(theUser.onToday, te2);			te1 := concat(te1, te2, '  I=');			NumToString(theUser.illegalLogons, te2);			bufferIt(concat(te1, te2), true, 0);			NumToString(theUser.numUploaded, te1);			NumToString(theUser.uploadedK, te2);			NumToString(theUser.numDownloaded, te3);			NumToString(theUser.downloadedK, te4);			bufferIt(concat('UpDn: U=', te1, '-', te2, 'k  D=', te3, '-', te4, 'k'), true, 0);			if length(theUser.sysopNote) > 0 then				bufferIt(concat('Note: ', theUser.sysopNote), true, 0);			NumToString(theuser.seclevel, te1);			NumToString(theUser.transferLevel, te2);			bufferIt(concat('SL  : ', te1, '  DSL=', te2), true, 0);			RestrictString(theUser, te1);			bufferIt(concat('Rest: ', te1), true, 0);			te1 := '----------';			for i := 1 to 10 do			begin				if tempUser.msgFrmAccess[i] then					te1[i] := 'X';			end;			bufferIt(concat('MeFr: ', te1), true, 0);			bufferbCR;			ReleaseBuffer;		end;	end;	procedure GetOnlineUser (var tobegat: UserRec);		var			i: integer;	begin		i := 1;		while (i <= intSystRec.numNodes) do		begin			if theNodes[i]^.thisUser.userNum = toBegat.userNum then				toBegat := theNodes[i]^.thisUser;			i := i + 1;		end;	end;	procedure SetOnlineUser (var tobegat: UserRec);		var			i: integer;	begin		i := 1;		while (i <= intSystRec.numNodes) do		begin			if theNodes[i]^.thisUser.userNum = toBegat.userNum then				theNodes[i]^.thisUser := toBegat;			i := i + 1;		end;	end;	procedure DoUserEdit;		var			t1, t2: str255;			tempInt, i: integer;			TempEMa: eMailRec;			templong: longint;	begin		with curglobs^ do		begin			case UEDo of				EnterUE: 				begin					if thisUser.coSysop then					begin						if not sysoplogon and (thisUser.secLevel < 255) then							LettersPrompt('SY: ', '', 9, false, false, true, 'X')						else							curPrompt := intSystrec.overridePass;						UEDo := UOne;					end					else						GoHome;				end;				UOne: 				begin					if EqualString(curPrompt, intSystRec.overridePass, false, false) then					begin						NumToString(crossint, t1);						if FindUser(t1, tempuser) then						begin							if UserOnSystem(tempuser.userName) then								GetOnlineUser(tempUser);							PrUserStuff(tempUser);							UEDo := UTwo;						end						else							GoHome;					end					else						GoHome;				end;				UTwo: 				begin					bCR;					LettersPrompt('Uedit : ', 'Q[]{}DRSTMOZFUN~GPLYA:?', 1, true, false, true, char(0));					UEDo := UThree;				end;				UThree: 				begin					if (length(curPrompt) > 0) then					begin						case curPrompt[1] of							'~': 							begin								if thisUser.secLevel = 255 then								begin									tempUser.coSysop := not tempUser.coSysop;									PrUserStuff(tempuser);									UEDo := UTwo;								end;							end;							'Q': 							begin								WriteUser(tempuser);								myUsers^^[tempuser.userNum - 1].UName := tempuser.userName;								myUsers^^[tempuser.userNum - 1].dltd := tempuser.deleting;								myUsers^^[tempuser.userNum - 1].real := tempuser.realName;								myUsers^^[tempuser.userNum - 1].SL := tempuser.secLevel;								myUsers^^[tempuser.userNum - 1].DSL := tempuser.transferLevel;								if UserOnSystem(tempUser.userName) then									SetOnlineUser(tempUser);								GoHome;							end;							'?': 							begin								UEDo := UTwo;								if LoadSpecialText(helpFile, 35) then								begin									if thisUser.canANSI then										doM(0);									BoardAction := ListText;									bCR;								end;							end;							'F': 							begin								NumbersPrompt('Toggle which? ', '', intMessStuff^^.numForums, 1);								UEDo := U17;							end;							'A': 							begin								if (thisUser.secLevel = 255) then								begin									LettersPrompt('Enter new password: ', '', 9, false, false, true, 'X');									UEDo := U20;								end								else								begin									PrUserStuff(tempUser);									UEDo := UTwo;								end;							end;							'N': 							begin								LettersPrompt('New name? ', '', 30, false, false, true, char(0));								UEDo := UEleven;							end;							']', '}': 							begin								WriteUser(tempuser);								myUsers^^[tempuser.userNum - 1].UName := tempuser.userName;								myUsers^^[tempuser.userNum - 1].dltd := tempuser.deleting;								myUsers^^[tempuser.userNum - 1].real := tempuser.realName;								myUsers^^[tempuser.userNum - 1].SL := tempuser.secLevel;								myUsers^^[tempuser.userNum - 1].DSL := tempuser.transferLevel;								if UserOnSystem(tempUser.userName) then									SetOnlineUser(tempUser);								tempInt := tempuser.UserNum + 1;								NumToString(tempint, t1);								if FindUser(t1, tempUser) then								begin									PrUserStuff(tempUser);									UEDo := UTwo;								end								else								begin									t1 := '1';									if FindUser(t1, tempuser) then									begin										PrUserStuff(tempuser);										UEdo := UTwo;									end									else										GoHome;								end;							end;							'[', '{': 							begin								WriteUser(tempuser);								myUsers^^[tempuser.userNum - 1].UName := tempuser.userName;								myUsers^^[tempuser.userNum - 1].dltd := tempuser.deleting;								myUsers^^[tempuser.userNum - 1].real := tempuser.realName;								myUsers^^[tempuser.userNum - 1].SL := tempuser.secLevel;								myUsers^^[tempuser.userNum - 1].DSL := tempuser.transferLevel;								if UserOnSystem(tempUser.userName) then									SetOnlineUser(tempUser);								tempInt := tempuser.UserNum - 1;								if tempInt < 1 then									tempint := numUserRecs;								NumToString(tempint, t1);								if FindUser(t1, tempUser) then								begin									PrUserStuff(tempUser);									UEDo := UTwo;								end								else									goHome;							end;							':': 							begin								tempUser.lastPWChange := 0;								PrUserStuff(tempUser);								UEDo := UTwo;							end;							'D': 							begin								if tempUser.secLevel < 255 then								begin									UEDo := UFour;									YesNoQuestion('Delete? ', false);								end								else								begin									PrUserStuff(tempUser);									UEDo := UTwo;								end;							end;							'R': 							begin								tempUser.deleting := false;								IntSystRec.numUsers := IntSystRec.numUsers + 1;								doSystRec(true);								OutLine('Restored.', true, 0);								PrUserStuff(tempUser);								UEDo := UTwo;							end;							'Y': 							begin								UEDo := U19;								curprompt := '';								if (thisUser.secLevel = 255) then								begin									if (tempuser.cosysop) then										t1 := 'Un-'									else										t1 := '';									YesNoQuestion(concat(t1, 'Mark as a sysop? '), false);								end;							end;							'S': 							begin								NumbersPrompt('New SL? ', '', 255, 1);								UEDo := UFive;							end;							'T': 							begin								NumbersPrompt('New DSL? ', '', 255, 1);								UEDo := USix;							end;							'O': 							begin								LettersPrompt('New note? ', '', 39, false, false, false, char(0));								UEDo := USeven;							end;							'M': 							begin								OutLine('Known computer types:', true, 0);								bCR;								i := 1;								GetIndString(t1, 15, i);								repeat									NumToString(i, t2);									t2 := concat(t2, '. ', t1);									i := i + 1;									if t1 <> '' then									begin										OutLine(t2, true, 0);										GetIndString(t1, 15, i);									end;								until (t1 = '');								bCR;								bCR;								NumbersPrompt('Enter new computer type: ', '', i - 1, 1);								UEdo := UEight;							end;							'Z': 							begin								RestrictString(tempUser, t1);								OutLine(concat('        ', t1), true, 0);								bCR;								NumbersPrompt('Toggle? ', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', -1, 0);								UEDo := UNine;							end;							'U': 							begin								LettersPrompt('User name/number: ', '', 30, false, false, true, char(0));								UEdo := UTen;							end;							'L': 							begin								LettersPrompt('New real name? ', '', 20, false, false, false, char(0));								UEdo := UTwelve;							end;							'P': 							begin								LettersPrompt('New phone number? ', '', 12, false, false, true, char(0));								UEdo := U13;							end;							'G': 							begin								NumToString(integer(tempUser.birthMonth), t1);								NumToString(integer(tempuser.birthDay), t2);								t1 := concat(t1, '/', t2, '/');								NumToString(integer(tempUser.birthYear), t2);								t1 := concat('Current birthdate: ', t1, t2);								OutLine(t1, true, 0);								bCR;								NumbersPrompt('Month you were born (1-12) : ', '', 12, 1);								UEDo := U14;							end;							otherwise							begin								PrUserStuff(tempUser);								UEDo := UTwo;							end;						end;					end					else					begin						PrUserStuff(tempUser);						UEDo := UTwo;					end;				end;				U20: 				begin					if length(curPrompt) > 0 then					begin						tempuser.password := curprompt;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				U19: 				begin					if (curPrompt = 'Y') then						tempUser.coSysop := not tempUser.coSysop;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				U18: 				begin					PrUserStuff(tempUser);					UEDo := UTwo;				end;				U14: 				begin					StringToNum(curPrompt, tempLong);					if tempLong > 0 then						tempUser.birthMonth := char(templong);					bCR;					NumbersPrompt('Day of month you were born (1-31) : ', '', 31, 1);					UEDo := U15;				end;				U15: 				begin					StringToNum(curPrompt, templong);					if (tempLong > 0) then						tempUser.birthDay := char(templong);					bCR;					NumbersPrompt('Year you were born (1900-) : ', '', 2000, 1);					UEDo := U16;				end;				U16: 				begin					StringToNum(curPrompt, templong);					if templong > 1900 then						tempLong := tempLong - 1900;					if (tempLong > 0) and (tempLong < 1995) then						tempUser.birthyear := char(templong);					yearsOld(tempUser);					PrUserStuff(tempUser);					UEDo := UTwo;				end;				U17: 				begin					if (curPrompt <> 'Q') and (curprompt <> '') then					begin						StringToNum(curprompt, tempLong);						if (tempLong > 0) and (tempLong < 11) then							if tempUser.msgFrmAccess[tempLong] then								tempUser.msgFrmAccess[templong] := false							else								tempUser.msgFrmAccess[templong] := true;						UEDo := UThree;						CurPrompt := 'F';					end					else					begin						PrUserStuff(tempUser);						UEDo := UTwo;					end;				end;				U13: 				begin					if length(curprompt) > 0 then					begin						tempUser.phone := curPrompt;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				UTwelve: 				begin					if length(curPrompt) > 0 then					begin						tempuser.realName := curprompt;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				UEleven: 				begin					if length(curPrompt) > 0 then					begin						DoCapsName(curPrompt);						if FindUser(curPrompt, MailingUser) then							OutLine('Sorry, you cannot use that name.', true, 0)						else							tempuser.userName := curPrompt;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				UTen: 				begin					tempInt := tempuser.userNum;					writeuser(tempUser);					myUsers^^[tempuser.userNum - 1].UName := tempuser.userName;					myUsers^^[tempuser.userNum - 1].dltd := tempuser.deleting;					myUsers^^[tempuser.userNum - 1].real := tempuser.realName;					myUsers^^[tempuser.userNum - 1].SL := tempuser.secLevel;					myUsers^^[tempuser.userNum - 1].DSL := tempuser.transferLevel;					if UserOnSystem(tempUser.userName) then						SetOnlineUser(tempUser);					if FindUser(curPrompt, tempuser) then					else					begin						OutLine('Unknown user.', true, 0);						NumToString(tempint, t1);						if FindUser(t1, tempUser) then							;					end;					if UserOnSystem(tempuser.userName) then						GetOnlineUser(tempUser);					PrUserStuff(tempUser);					UEDo := UTwo;				end;				UNine: 				begin					if (length(curPrompt) > 0) then					begin						if (curPrompt[1] >= char(65)) and (curPrompt[1] <= char(90)) then						begin							tempUser.restrics[byte(curPrompt[1]) - 64] := not tempUser.restrics[byte(curPrompt[1]) - 64];							curPrompt := 'Z';							UEdo := UThree;						end;					end					else					begin						PrUserStuff(tempUser);						UEDo := UTwo;					end;				end;				UEight: 				begin					if length(curPrompt) > 0 then					begin						StringToNum(curprompt, templong);						if (tempLong >= 0) then						begin							GetIndString(t1, 15, tempLong);							tempUser.computerType := t1;						end;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				USeven: 				begin					tempUser.sysopNote := curPrompt;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				USix: 				begin					if length(curPrompt) > 0 then					begin						StringToNum(curprompt, templong);						if (templong >= 0) and (templong <= thisUser.TransferLevel) then							tempUser.transferLevel := templong;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				UFive: 				begin					if length(curprompt) > 0 then					begin						StringToNum(curprompt, templong);						if (templong <= thisUser.secLevel) and (templong >= 0) then							tempUser.SecLevel := templong;					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				UFour: 				begin					if curPrompt = 'Y' then					begin						IntSystRec.numUsers := IntSystRec.numUsers - 1;						doSystRec(true);						tempUser.deleting := true;						OutLine('Deleting mail', true, 0);						i := 0;						while (i < availEmails) do						begin							if theEmail^^[i].toUser = tempUser.userNum then							begin								OutLine('.', false, 0);								DeleteMail(i);							end							else								i := i + 1;						end;						OutLine('.', false, 0);						OutLine('Deleted.', true, 0);					end;					PrUserStuff(tempUser);					UEDo := UTwo;				end;				otherwise			end;		end;	end;	procedure DoMultiMail;		var			i: integer;			tempBool: boolean;			temps1: str255;	begin		with curglobs^ do		begin			case MultiDo of				MultiOne: 				begin					netMail := false;					if (thisuser.emSentToday + thisUser.mPostedToday) > intSystRec.secLevels[thisUser.secLevel].mesgDay then					begin						OutLine('You have sent too many messages today.', true, 0);						GoHome;						exit(doMultiMail);					end;					if freeK(intsystRec.msgsPath) < 50 then					begin						OutLine(retinstr(17, 64), true, 0);						GoHome;						exit(doMultiMail);					end;					if (thisUser.restrics[6]) then					begin						OutLine('You cannot send e-mail.', true, 0);						GoHome;						exit(doMultiMail);					end;					OutLine(retinstr(17, 66), true, 0);					MultiDo := MultiTwo;					numMultiUsers := 0;					for i := 1 to 20 do						multiUsers[i] := 0;				end;				MultiTwo: 				begin					if ((thisuser.emSentToday + thisUser.mPostedToday) + numMultiUsers) <= intSystRec.secLevels[thisUser.secLevel].mesgDay then					begin						if numMultiUsers < 20 then						begin							bCR;							LettersPrompt('> ', '', 31, false, false, true, char(0));							myPrompt.wrapsonCR := false;							MultiDo := MultiThree;						end						else						begin							OutLine('List full.', true, 0);							MultiDo := MultiFour;						end;					end					else					begin						OutLine('Sorry, you have reached your message limit for today.', true, 0);						MultiDo := MultiFour;					end;				end;				MultiThree: 				begin					if length(curPrompt) > 0 then					begin						if FindUser(curPrompt, tempUser) then						begin							if not tempuser.deleting then							begin								if not tempUser.mailbox and not (tempUser.usernum = thisuser.usernum) then								begin									tempBool := false;									if numMultiUsers > 0 then									begin										i := 1;										while (i <= crossint) and (multiUsers[i] <> tempUser.userNum) do											i := i + 1;										if (i < 21) and (multiUsers[i] = tempuser.userNum) then											tempBool := true;									end;									if not tempBool then									begin										BackSpace(gBBSwindows[activeNode]^.cursor.h - 2);										NumToString(tempUser.userNum, temps1);										OutLine(concat('     -> ', tempUser.userName, ' #', temps1), false, 0);										numMultiUsers := numMultiUsers + 1;										multiUsers[numMultiUsers] := tempUser.userNum;										MultiDo := MultiTwo;									end									else									begin										OutLine('Already in list, not added.', true, 0);										MultiDo := MultiTwo;									end;								end								else								begin									if (tempuser.usernum = thisuser.usernum) then										OutLine('Cannot send E-Mail to yourself.', true, 0)									else										OutLine('Cannot send multi-mail to a user forwarding mail.', true, 0);									MultiDo := MultiTwo;								end;							end							else							begin								OutLine('Deleted user.', true, 0);								MultiDo := MultiTwo;							end;						end						else						begin							OutLine('Unknown user.', true, 0);							MultiDo := MultiTwo;						end;					end					else						MultiDo := MultiFour;				end;				MultiFour: 				begin					if numMultiUsers > 0 then					begin						Outline('E-mailing:', true, 0);						for i := 1 to numMultiUsers do						begin							NumToString(multiUsers[i], temps1);							OutLine(concat('     ', myUsers^^[multiUsers[i] - 1].UName, ' #', temps1), true, 0);						end;						bCR;						if not thisUser.canANSI and not thisUser.ANSIcolor then							OutLine('       (---=----=----=----=----=----=----=----=--)', true, 0);						bCR;						LettersPrompt('Title: ', '', 43, false, false, false, char(0));						ANSIPrompter(43);						CurEMailRec.fromuser := thisUser.Usernum;						curEmailRec.toUser := -1;						curEMailRec.anonyTo := false;						curEmailRec.anonyFrom := false;						CurEMailRec.MType := 1;						curEmailRec.multimail := true;						GetDateTime(CurEMailRec.dateSent);						for i := 0 to 9 do							curEmailRec.reserved[i] := char(0);						sentAnon := false;						callFMail := false;						EMailDo := EmailTwo;						BoardSection := Email;					end					else					begin						OutLine('No users specified.', true, 0);						GoHome;					end;				end;				otherwise			end;		end;	end;	function compareBBSEntry (first, second: BBSListEntry): boolean;		var			t1, t2: str255;			tl1, tl2: longint;			i: integer;	begin		compareBBSentry := false;		t1 := '';		t2 := '';		for i := 1 to 12 do		begin			t1 := concat(t1, ' ');			t2 := concat(t2, ' ');		end;		BlockMove(@first.number[0], @t1[1], 12);		BlockMove(@second.number[0], @t2[1], 12);		t1[0] := char(3);		t2[0] := char(3);		StringToNum(t1, tl1);		StringToNum(t2, tl2);		if (tl1 = tl2) then		begin			delete(t1, 1, 4);			delete(t2, 1, 4);			t1[0] := char(7);			t2[0] := char(7);			StringToNum(t1, tl1);			StringToNum(t2, tl2);			if (tl1 < tl2) then				compareBBSentry := true;		end		else if (tl1 < tl2) then			compareBBSentry := true;	end;	procedure BBSQuickSort (myBBSList: BBSListPtr; start, finish: integer);		var			left, right: integer;			starterValue, temp: BBSListEntry;	begin		left := start;		right := finish;		starterValue := myBBSList^[(start + finish) div 2];		repeat			while compareBBSEntry(myBBSList^[left], starterValue) do				left := left + 1;			while compareBBSEntry(starterValue, myBBSList^[right]) do				right := right - 1;			if left <= right then			begin				temp := myBBSList^[left];				myBBSList^[left] := myBBSList^[right];				myBBSList^[right] := temp;				left := left + 1;				right := right - 1;			end;		until right <= left;		if start < right then			BBSQuickSort(myBBSList, start, right);		if left < finish then			BBSQuickSort(myBBSList, left, finish);	end;	function SortBBSList: boolean;		var			BBStemp: BBSListPtr;			BBSRef, i, entries: integer;			bbsListSize: longint;			badFormat: boolean;	begin		badFormat := false;		result := FSOpen(concat(sharedPath, 'BBS List'), 0, BBSRef);		if result = noErr then		begin			result := GetEOF(BBSRef, bbsListSize);			entries := ((bbsListSize div SizeOf(BBSListEntry)) - 1);			BBSTemp := BBSListPtr(NewPtr(bbsListSize));			if (memError = noErr) then			begin				result := FSRead(BBSRef, bbsListSize, ptr(BBStemp));				for i := 0 to entries do					if bbstemp^[i].theRest[67] <> char(13) then						badFormat := true;				if not badFormat then					BBSQuickSort(bbsTemp, 0, entries);				result := SetFPos(BBSref, fsFromStart, 0);				result := FSWrite(BBSref, bbsListSize, ptr(BBStemp));				DisposPtr(ptr(BBStemp));			end			else				SysBeep(1);			result := FSClose(BBSRef);		end;		sortBBSList := badFormat;	end;	function inBBSlist (theNum: str255): boolean;		var			result: OSerr;			bbsLRef: integer;			tempString: str255;			place, tempLeng: longint;			bbsListings: TextHand;			found: boolean;	begin		inBBSlist := false;		result := FSOpen(concat(sharedPath, 'BBS List'), 0, BBSlRef);		if result <> noErr then		begin			result := FSDelete(concat(sharedPath, 'BBS List'), 0);			result := Create(concat(sharedPath, 'BBS List'), 0, 'HRMS', 'TEXT');			result := FSOpen(concat(sharedPath, 'BBS List'), 0, BBSlRef);		end;		if result = noErr then		begin			place := -1;			result := GetEOF(BBSLRef, tempLeng);			if tempLeng > 0 then			begin				bbsListings := TextHand(newHandle(tempLeng));				if memError = noErr then				begin					HLock(handle(bbsListings));					result := FSRead(BBSLref, tempLeng, pointer(bbsListings^));					found := false;					tempString := '            ';					repeat						repeat							place := place + 1;						until (bbsListings^^[place] = theNum[1]) or (place >= tempLeng - 1);						if (place < tempLeng) then						begin							BlockMove(@bbsListings^^[place], @tempString[1], 12);							if EqualString(theNum, tempString, false, false) then								found := true;						end;					until found or (place >= tempLeng - 1);					HUnlock(handle(BBSlistings));					DisposHandle(handle(bbsListings));					if found then						inBBSlist := true;				end;			end;			result := FSClose(BBSlRef);		end		else		begin			OutLine('Couldn''t open BBS list!', true, 6);			GoHome;		end;	end;	procedure doBBSlist;		var			tempString: str255;			i, tempInt: integer;			result: OSerr;			count: longint;	begin		with curglobs^ do		begin			case BBSlDo of				bone: 				begin					bCR;					bCR;					if (thisUser.coSysop) then						LettersPrompt('BBS list: R:ead, A:dd, S:ort, Q:uit  : ', 'RASQ', 1, true, false, true, char(0))					else if (not thisUser.restrics[9]) then						LettersPrompt('BBS list: R:ead, A:dd, Q:uit  : ', 'RAQ', 1, true, false, true, char(0))					else						LettersPrompt('BBS list: R:ead, Q:uit  : ', 'RQ', 1, true, false, true, char(0));					BBSLDo := Btwo;				end;				BTwo: 				begin					if length(curPrompt) > 0 then					begin						case curPrompt[1] of							'Q': 								goHome;							'S': 							begin								bCR;								if (not SortBBSList) then									OutLine('Sorted.', true, 0)								else									OutLine('BBS List has a bad format.', true, 0);								BBSlDo := BOne;							end;							'R': 							begin								bCR;								if readTextFile('BBS List', 0, true) then								begin									BoardAction := ListText;									ListTextFile;								end								else									OutLine('There are no entries in the BBS list.', true, 0);								BBSlDo := BOne;							end;							'A': 							begin								OutLine('Please enter phone number:', true, 0);								OutLine('  ###-###-####', true, 0);								bCR;								LettersPrompt(': ', '', 12, false, false, true, char(0));								ANSIPrompter(12);								BBSlDo := bThree;							end;							otherwise								goHome;						end;					end					else						BBSLdo := BOne;				end;				bThree: 				begin					if length(curPrompt) > 0 then					begin						if (intSystRec.freePhone or ((curprompt[4] = '-') and (curprompt[8] = '-'))) and (length(curprompt) = 12) then						begin							if not inBBSList(curprompt) then							begin								fileMask := curPrompt;								OutLine('Number not yet in BBS list.', true, 0);								bCR;								OutLine('Enter BBS name and comments:', true, 0);								bCR;								LettersPrompt(': ', '', 50, false, false, false, char(0));								ANSIPrompter(50);								BBSlDo := BFour;							end							else							begin								OutLine('It''s already in the BBS list.', true, 0);								bCR;								BBSlDo := BOne;							end;						end						else						begin							bCR;							OutLine('Please enter number in correct format.', true, 0);							bCR;							BBSLdo := BTwo;							Curprompt := 'A';						end;					end					else						bbsLDo := bOne;				end;				BFour: 				begin					fileMask := concat(fileMask, '  ', curPrompt);					if length(filemask) < 67 then						for i := 1 to (67 - length(filemask)) do							fileMask := concat(fileMask, ' ');					OutLine('Enter maximum speed of the BBS:', true, 0);					OutLine('ie, 300,1200,2400,9600,14.4,19.2', true, 0);					bCR;					LettersPrompt(': ', '', 4, false, false, true, char(0));					ANSIPrompter(4);					BBSlDo := BFive;				end;				bFive: 				begin					if (length(curprompt) < 4) then						for i := 1 to (4 - length(curprompt)) do							curprompt := concat(' ', curprompt);					fileMask := concat(fileMask, '[', curprompt, ']');					OutLine('Enter BBS type (ie, HRMS):', true, 0);					bCR;					LettersPrompt(': ', '', 4, false, false, true, char(0));					ANSIPrompter(4);					BBSlDo := bSix;				end;				bSix: 				begin					if (length(curprompt) < 4) then						for i := 1 to (4 - length(curprompt)) do							curprompt := concat(' ', curprompt);					fileMask := concat(fileMask, '(', curPrompt, ')');					OutLine(fileMask, true, 0);					bCR;					bCR;					YesNoQuestion('Is this correct? ', false);					BBSlDo := bSeven;				end;				bSeven: 				begin					if curprompt = 'N' then						BBSlDO := bOne					else					begin						result := FSOpen(concat(sharedPath, 'BBS List'), 0, tempint);						if result = noErr then						begin							LogThis('      Added to BBS List:', 0);							LogThis(fileMask, 0);							fileMask := concat(fileMask, char(13));							result := SetFPos(tempint, fsFromLEOF, 0);							count := length(fileMask);							result := FSWrite(tempInt, count, @fileMask[1]);							result := FSClose(tempint);							Outline('Number added to BBS list.', true, 0);						end						else							OutLine('Problem adding number to BBS list!', true, 6);						bbsLDo := bOne;					end;				end;				otherwise			end;		end;	end;end.